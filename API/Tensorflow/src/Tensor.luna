import Tensorflow.CWrappers.Tensor

import Std.Foreign
import Std.Foreign.C.Value

import Tensorflow.CWrappers.Helpers

# Internal.
# Arguments:
# len :: Int
# list :: List a
# splitInPacksOf :: Int -> List a -> List List a
def splitInPacksOf len list:
    if list.isEmpty then Empty else Prepend (list.take len) (splitInPacksOf len (list.drop len))

# Tensor structure, which is TF container unit, used in computations.
class Tensor a:
    wrapper :: TensorWrapper a

    # Internal.
    # ptr :: ManagedPointer None
    def ptr:
        self.wrapper.ptr

    # Returns tensor's shape.
    # dims :: List Int
    def dims:
        self.wrapper.dims

    # Returns value of tensor at given list of indices.
    # Arguments: 
    # indices :: List Int
    # at :: List Int -> T
    def at indices:
        self.wrapper.at indices


    # Returns value of tensor at given index.
    # Arguments: 
    # index :: Int
    # atIndex :: Int -> T
    def atIndex index:
        self.wrapper.atIndex index

    # Returns multidimensional list from tensor.
    # toList :: List T
    def toList:
        throw "Function toList is deprecated and will be removed" # TODO remove

    # Returns flatten list from tensor.
    # toFlatList :: List T
    def toFlatList:
        self.wrapper.toFlatList

    # Returns Tensor in JSON type.
    # toJSON :: JSON
    def toJSON:
        dims = self.dims
        flat = self.toFlatList

        def toNested dims list:
            case dims of
                Empty:
                    list.head.get.toJSON
                Prepend last Empty:
                    list.toJSON
                Prepend h t:
                    packsize = list.length / h
                    parts = splitInPacksOf packsize list
                    jsons = parts.each (toNested t)
                    JSONArray jsons

        res = toNested dims flat
        res

    # toText :: Text
    def toText:
        "Tensor " + (self.dims.toText)

    def typetag:
        self.wrapper.typetag

# Creating tensors and operations on them.
class Tensors:
    Tensors

    # Creates tensor of given type from pointer to other tensor.
    # Arguments: 
    # `typetag` :: TypeTag
    # `tensorPtr` :: ManagedPointer None
    # fromPtr :: TypeTag a -> ManagedPointer None -> Tensor a
    def fromPtr typetag managedTensorPtr:
        wrapper = TensorWrapper managedTensorPtr typetag
        Tensor wrapper

    # Creates 1D tensor of given type, from given list of values.
    # Arguments: 
    # `typetag` :: TypeTag
    # `list` :: List a
    # fromList1d :: TypeTag a -> List a -> Tensor a
    def fromList1d typetag list:
        wrapper = createTensorWrapper typetag [list.length] list
        Tensor wrapper

    # Creates 2D tensor of given type, from given 2D list of values.
    # Arguments: 
    # `typetag` :: TypeTag
    # `list` :: List (List a)
    # fromList2d :: TypeTag a -> List (List a) -> Tensor a
    def fromList2d typetag list:
        lengths = list.each (l: l.length)
        w = list.length
        h = lengths.getAt 0
        if (lengths.all (l: l == h)).not then throw "tensorFromList2d: All lists have to be of equal lengts" else None
        flat = list.concat
        self.fromList typetag [w, h] flat

    # Creates const tensor of given type and dimensions, from list of values.
    # Arguments: 
    # `typetag` :: TypeTag
    # `dims` :: List Int
    # `list` :: List a
    # fromList :: TypeTag a -> List Int -> List a -> Tensor a
    def fromList typetag dims list:
        wrapper = createTensorWrapper typetag dims list
        Tensor wrapper

    # Creates random tensor with given type and dimensions.
    # Arguments: 
    # `typetag` :: TypeTag
    # `dims` :: List Int
    # `minVal` :: a
    # `maxVal` :: a
    # random :: TypeTag a -> List Int -> a -> a -> Tensor a
    def random typetag dims minVal maxVal:
        wrapper = createRandomTensorWrapper typetag dims minVal maxVal
        Tensor wrapper

    # Creates const tensor of zeros with given type and dimensions.
    # Arguments: 
    # `typetag` :: TypeTag
    # `dims` :: List Int
    # zeros :: Typetag a -> List Int -> Tensor a
    def zeros typetag dims:
        wrapper = createConstTensorWrapper typetag dims (typetag.fromReal 0.0)
        Tensor wrapper

    # Creates const tensor of zeros with given type and shape of given tensor.
    # Arguments: 
    # `typetag` :: TypeTag
    # `x` :: Tensor a
    # zerosLike :: Typetag a -> Tensor a -> Tensor a
    def zerosLike typetag x:
        wrapper = createConstTensorWrapper typetag x.dims (typetag.fromReal 0.0)
        Tensor wrapper

    # Creates const tensor of ones with given type and dimensions.
    # Arguments: 
    # `typetag` :: TypeTag
    # `dims` :: List Int
    # ones :: Typetag a -> List Int -> Tensor a
    def ones typetag dims:
        wrapper = createConstTensorWrapper typetag dims (typetag.fromReal 1.0)
        Tensor wrapper

    # Creates const tensor of ones with given type and shape of given tensor.
    # Arguments: 
    # `typetag` :: TypeTag
    # `x` :: Tensor a
    # onesLike :: Typetag a -> Tensor a -> Tensor a
    def onesLike typetag x:
        wrapper = createConstTensorWrapper typetag x.dims (typetag.fromReal 1.0)
        Tensor wrapper

    # Transposes a tensor (TODO better description)
    # Arguments:
    # `t` :: Tensor
    # transpose :: Tensor a -> Tensor a
    def transpose t:
        c = Operations.makeConst t
        perm = Operations.constFromList Int64Type [1,0]
        transposed = transposeGen "" c perm c.typetag perm.typetag
        t' = transposed.eval
        t'

    # Converts tensor to 2D list, but only if it's of expected shape.
    # Arguments: 
    # `tensor` :: Tensor 
    # to2dList :: Tensor a -> List (List a)
    def to2dList tensor:
        dims = tensor.dims
        if (dims.length == 2).not then throw "Only tensors with shape [w,h] can be converted to a 2d list" else None
        [w,h] = dims
        flat = tensor.toFlatList
        res = splitInPacksOf h flat
        res

    # Saves given tensor to file.
    # Arguments:
    # `filename` :: Text
    # `tensor` :: Tensor
    # save :: Text -> Tensor -> ()
    def save filename tensor:
        saveTensorsWrapper filename [tensor.wrapper.ptr]

    # Loads from file tensor of given type.
    # Arguments:
    # `filename` :: Text
    # 'typetag' :: Typetag
    # load :: Text -> Typetag -> Tensor
    def load filename typetag:
        [ptr] = loadTensorsWrapper filename 1
        Tensor (TensorWrapper ptr typetag)

    # Loads tensor from PNG file in RGB format
    # Arguments:
    # `filename` :: Text
    # fromPng :: Text -> Tensor
    def fromPng filename:
        wrapper = fromPngWrapper filename
        res = Tensor wrapper
        res

    # Converts a Dataframes Table consisting of only float values into a 2D float tensor
    # Arguments:
    # `table` :: Dataframes.Table.Table
    # fromTable :: Table -> Tensor FloatType
    def fromTable table:
        lst = table.toList . each (col: col.toList)
        t = Tensors.fromList2d FloatType lst
        t

    # Converts a Dataframes Table into a list of 1d tensors, each tensor representing a row from the table
    # Arguments:
    # `table` :: Dataframes.Table.Table
    # fromTableRows :: Table -> List (Tensor FloatType)
    def fromTableRows table:
        t1 = Tensors.fromTable table
        t2 = Tensors.transpose t1
        lst' = Tensors.to2dList t2
        cols = table.columnNames.length
        shape = [cols, 1]
        samples = lst'.each(l: Tensors.fromList FloatType shape l)
        samples
