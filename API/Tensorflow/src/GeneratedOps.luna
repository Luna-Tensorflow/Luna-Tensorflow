import Std.Foreign
import Std.Foreign.C.Value
import Tensorflow.CWrappers.Operations
import Tensorflow.Types
import Tensorflow.Operations

def fractionalAvgPoolGradGen chosenName origxinputxtensorxshape outxbackprop rowxpoolingxsequence colxpoolingxsequence overlapping t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "overlapping"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if overlapping then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "FractionalAvgPoolGrad" [origxinputxtensorxshape, outxbackprop, rowxpoolingxsequence, colxpoolingxsequence] [outxbackprop.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def fractionalAvgPoolGen chosenName value poolingxratio pseudoxrandom overlapping deterministic seed seed2 t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrInt = lookupSymbol "TFL" "add_attr_int"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrFloatList = lookupSymbol "TFL" "add_attr_float_list"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "pooling_ratio"
    cvalues = poolingxratio.map CFloat.fromReal
    cvaluesArray = (Array CFloat) . fromList cvalues
    addAttrFloatList.call None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt poolingxratio.length . toCArg]
    cvaluesArray.free
    nameCStr.free
    nameCStr = CString.fromText "pseudo_random"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if pseudoxrandom then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "overlapping"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if overlapping then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "deterministic"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if deterministic then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "seed"
    addAttrInt.call None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt seed . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "seed2"
    addAttrInt.call None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt seed2 . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "FractionalAvgPool" [value] [value.wrapper.typetag, Int64Type, Int64Type] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def fractionalMaxPoolGradGen chosenName origxinput origxoutput outxbackprop rowxpoolingxsequence colxpoolingxsequence overlapping t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "overlapping"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if overlapping then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "FractionalMaxPoolGrad" [origxinput, origxoutput, outxbackprop, rowxpoolingxsequence, colxpoolingxsequence] [origxinput.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def topKV2Gen chosenName input k sorted t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "sorted"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if sorted then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "TopKV2" [input, k] [input.wrapper.typetag, Int32Type] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def inTopKV2Gen chosenName predictions targets k t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "InTopKV2" [predictions, targets, k] [BoolType] attrList chosenName
    TFOutput wrappers.head.get

def inTopKGen chosenName predictions targets k t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrInt = lookupSymbol "TFL" "add_attr_int"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "k"
    addAttrInt.call None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt k . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "InTopK" [predictions, targets] [BoolType] attrList chosenName
    TFOutput wrappers.head.get

def sparseSoftmaxCrossEntropyWithLogitsGen chosenName features labels t tlabels:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tlabels"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tlabels.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "SparseSoftmaxCrossEntropyWithLogits" [features, labels] [features.wrapper.typetag, features.wrapper.typetag] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def softmaxCrossEntropyWithLogitsGen chosenName features labels t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "SoftmaxCrossEntropyWithLogits" [features, labels] [features.wrapper.typetag, features.wrapper.typetag] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def softmaxGen chosenName logits t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Softmax" [logits] [logits.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def softsignGradGen chosenName gradients features t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "SoftsignGrad" [gradients, features] [gradients.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def softsignGen chosenName features t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Softsign" [features] [features.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def eluGen chosenName features t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Elu" [features] [features.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def relu6GradGen chosenName gradients features t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Relu6Grad" [gradients, features] [gradients.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def relu6Gen chosenName features t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Relu6" [features] [features.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def reluGradGen chosenName gradients features t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "ReluGrad" [gradients, features] [gradients.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def dilation2DBackpropInputGen chosenName input filter outxbackprop t strides rates padding:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrIntList = lookupSymbol "TFL" "add_attr_int_list"
    addAttrString = lookupSymbol "TFL" "add_attr_string"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "strides"
    cvalues = strides.map CInt64.fromInt
    cvaluesArray = (Array CInt64) . fromList cvalues
    addAttrIntList.call None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
    cvaluesArray.free
    nameCStr.free
    nameCStr = CString.fromText "rates"
    cvalues = rates.map CInt64.fromInt
    cvaluesArray = (Array CInt64) . fromList cvalues
    addAttrIntList.call None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt rates.length . toCArg]
    cvaluesArray.free
    nameCStr.free
    nameCStr = CString.fromText "padding"
    valCStr = CString.fromText padding
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    wrappers = makeOutputWrappers "Dilation2DBackpropInput" [input, filter, outxbackprop] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def maxPoolGradGradWithArgmaxGen chosenName input grad argmax ksize strides padding targmax t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrIntList = lookupSymbol "TFL" "add_attr_int_list"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrString = lookupSymbol "TFL" "add_attr_string"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "ksize"
    cvalues = ksize.map CInt64.fromInt
    cvaluesArray = (Array CInt64) . fromList cvalues
    addAttrIntList.call None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt ksize.length . toCArg]
    cvaluesArray.free
    nameCStr.free
    nameCStr = CString.fromText "strides"
    cvalues = strides.map CInt64.fromInt
    cvaluesArray = (Array CInt64) . fromList cvalues
    addAttrIntList.call None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
    cvaluesArray.free
    nameCStr.free
    nameCStr = CString.fromText "padding"
    valCStr = CString.fromText padding
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    nameCStr = CString.fromText "Targmax"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt targmax.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "MaxPoolGradGradWithArgmax" [input, grad, argmax] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def maxPoolGradWithArgmaxGen chosenName input grad argmax ksize strides padding targmax t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrIntList = lookupSymbol "TFL" "add_attr_int_list"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrString = lookupSymbol "TFL" "add_attr_string"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "ksize"
    cvalues = ksize.map CInt64.fromInt
    cvaluesArray = (Array CInt64) . fromList cvalues
    addAttrIntList.call None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt ksize.length . toCArg]
    cvaluesArray.free
    nameCStr.free
    nameCStr = CString.fromText "strides"
    cvalues = strides.map CInt64.fromInt
    cvaluesArray = (Array CInt64) . fromList cvalues
    addAttrIntList.call None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
    cvaluesArray.free
    nameCStr.free
    nameCStr = CString.fromText "padding"
    valCStr = CString.fromText padding
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    nameCStr = CString.fromText "Targmax"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt targmax.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "MaxPoolGradWithArgmax" [input, grad, argmax] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def maxPoolGradGradV2Gen chosenName origxinput origxoutput grad ksize strides padding dataxformat t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrString = lookupSymbol "TFL" "add_attr_string"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "padding"
    valCStr = CString.fromText padding
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    nameCStr = CString.fromText "data_format"
    valCStr = CString.fromText dataxformat
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "MaxPoolGradGradV2" [origxinput, origxoutput, grad, ksize, strides] [origxinput.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def maxPoolGradGen chosenName origxinput origxoutput grad ksize strides padding dataxformat t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrIntList = lookupSymbol "TFL" "add_attr_int_list"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrString = lookupSymbol "TFL" "add_attr_string"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "ksize"
    cvalues = ksize.map CInt64.fromInt
    cvaluesArray = (Array CInt64) . fromList cvalues
    addAttrIntList.call None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt ksize.length . toCArg]
    cvaluesArray.free
    nameCStr.free
    nameCStr = CString.fromText "strides"
    cvalues = strides.map CInt64.fromInt
    cvaluesArray = (Array CInt64) . fromList cvalues
    addAttrIntList.call None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
    cvaluesArray.free
    nameCStr.free
    nameCStr = CString.fromText "padding"
    valCStr = CString.fromText padding
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    nameCStr = CString.fromText "data_format"
    valCStr = CString.fromText dataxformat
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "MaxPoolGrad" [origxinput, origxoutput, grad] [origxinput.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def maxPoolGen chosenName input t ksize strides padding dataxformat:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrIntList = lookupSymbol "TFL" "add_attr_int_list"
    addAttrString = lookupSymbol "TFL" "add_attr_string"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "ksize"
    cvalues = ksize.map CInt64.fromInt
    cvaluesArray = (Array CInt64) . fromList cvalues
    addAttrIntList.call None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt ksize.length . toCArg]
    cvaluesArray.free
    nameCStr.free
    nameCStr = CString.fromText "strides"
    cvalues = strides.map CInt64.fromInt
    cvaluesArray = (Array CInt64) . fromList cvalues
    addAttrIntList.call None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
    cvaluesArray.free
    nameCStr.free
    nameCStr = CString.fromText "padding"
    valCStr = CString.fromText padding
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    nameCStr = CString.fromText "data_format"
    valCStr = CString.fromText dataxformat
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    wrappers = makeOutputWrappers "MaxPool" [input] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def lRNGen chosenName input depthxradius bias alpha beta t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrInt = lookupSymbol "TFL" "add_attr_int"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrFloat = lookupSymbol "TFL" "add_attr_float"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "depth_radius"
    addAttrInt.call None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt depthxradius . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "bias"
    addAttrFloat.call None [attrList.toCArg, nameCStr.toCArg, CFloat.fromReal bias . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "alpha"
    addAttrFloat.call None [attrList.toCArg, nameCStr.toCArg, CFloat.fromReal alpha . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "beta"
    addAttrFloat.call None [attrList.toCArg, nameCStr.toCArg, CFloat.fromReal beta . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "LRN" [input] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def maxPool3DGradGen chosenName origxinput origxoutput grad ksize strides padding dataxformat t tInput:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrIntList = lookupSymbol "TFL" "add_attr_int_list"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrString = lookupSymbol "TFL" "add_attr_string"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "ksize"
    cvalues = ksize.map CInt64.fromInt
    cvaluesArray = (Array CInt64) . fromList cvalues
    addAttrIntList.call None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt ksize.length . toCArg]
    cvaluesArray.free
    nameCStr.free
    nameCStr = CString.fromText "strides"
    cvalues = strides.map CInt64.fromInt
    cvaluesArray = (Array CInt64) . fromList cvalues
    addAttrIntList.call None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
    cvaluesArray.free
    nameCStr.free
    nameCStr = CString.fromText "padding"
    valCStr = CString.fromText padding
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    nameCStr = CString.fromText "data_format"
    valCStr = CString.fromText dataxformat
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "TInput"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tInput.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "MaxPool3DGrad" [origxinput, origxoutput, grad] [grad.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def maxPool3DGradGradGen chosenName origxinput origxoutput grad ksize strides padding dataxformat t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrIntList = lookupSymbol "TFL" "add_attr_int_list"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrString = lookupSymbol "TFL" "add_attr_string"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "ksize"
    cvalues = ksize.map CInt64.fromInt
    cvaluesArray = (Array CInt64) . fromList cvalues
    addAttrIntList.call None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt ksize.length . toCArg]
    cvaluesArray.free
    nameCStr.free
    nameCStr = CString.fromText "strides"
    cvalues = strides.map CInt64.fromInt
    cvaluesArray = (Array CInt64) . fromList cvalues
    addAttrIntList.call None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
    cvaluesArray.free
    nameCStr.free
    nameCStr = CString.fromText "padding"
    valCStr = CString.fromText padding
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    nameCStr = CString.fromText "data_format"
    valCStr = CString.fromText dataxformat
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "MaxPool3DGradGrad" [origxinput, origxoutput, grad] [origxinput.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def conv3DBackpropFilterV2Gen chosenName input filterxsizes outxbackprop t strides padding dataxformat dilations:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrIntList = lookupSymbol "TFL" "add_attr_int_list"
    addAttrString = lookupSymbol "TFL" "add_attr_string"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "strides"
    cvalues = strides.map CInt64.fromInt
    cvaluesArray = (Array CInt64) . fromList cvalues
    addAttrIntList.call None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
    cvaluesArray.free
    nameCStr.free
    nameCStr = CString.fromText "padding"
    valCStr = CString.fromText padding
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    nameCStr = CString.fromText "data_format"
    valCStr = CString.fromText dataxformat
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    nameCStr = CString.fromText "dilations"
    cvalues = dilations.map CInt64.fromInt
    cvaluesArray = (Array CInt64) . fromList cvalues
    addAttrIntList.call None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt dilations.length . toCArg]
    cvaluesArray.free
    nameCStr.free
    wrappers = makeOutputWrappers "Conv3DBackpropFilterV2" [input, filterxsizes, outxbackprop] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def conv3DGen chosenName input filter t strides padding dataxformat dilations:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrIntList = lookupSymbol "TFL" "add_attr_int_list"
    addAttrString = lookupSymbol "TFL" "add_attr_string"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "strides"
    cvalues = strides.map CInt64.fromInt
    cvaluesArray = (Array CInt64) . fromList cvalues
    addAttrIntList.call None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
    cvaluesArray.free
    nameCStr.free
    nameCStr = CString.fromText "padding"
    valCStr = CString.fromText padding
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    nameCStr = CString.fromText "data_format"
    valCStr = CString.fromText dataxformat
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    nameCStr = CString.fromText "dilations"
    cvalues = dilations.map CInt64.fromInt
    cvaluesArray = (Array CInt64) . fromList cvalues
    addAttrIntList.call None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt dilations.length . toCArg]
    cvaluesArray.free
    nameCStr.free
    wrappers = makeOutputWrappers "Conv3D" [input, filter] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def depthwiseConv2dNativeBackpropFilterGen chosenName input filterxsizes outxbackprop t strides padding dataxformat dilations:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrIntList = lookupSymbol "TFL" "add_attr_int_list"
    addAttrString = lookupSymbol "TFL" "add_attr_string"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "strides"
    cvalues = strides.map CInt64.fromInt
    cvaluesArray = (Array CInt64) . fromList cvalues
    addAttrIntList.call None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
    cvaluesArray.free
    nameCStr.free
    nameCStr = CString.fromText "padding"
    valCStr = CString.fromText padding
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    nameCStr = CString.fromText "data_format"
    valCStr = CString.fromText dataxformat
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    nameCStr = CString.fromText "dilations"
    cvalues = dilations.map CInt64.fromInt
    cvaluesArray = (Array CInt64) . fromList cvalues
    addAttrIntList.call None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt dilations.length . toCArg]
    cvaluesArray.free
    nameCStr.free
    wrappers = makeOutputWrappers "DepthwiseConv2dNativeBackpropFilter" [input, filterxsizes, outxbackprop] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def depthwiseConv2dNativeBackpropInputGen chosenName inputxsizes filter outxbackprop t strides padding dataxformat dilations:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrIntList = lookupSymbol "TFL" "add_attr_int_list"
    addAttrString = lookupSymbol "TFL" "add_attr_string"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "strides"
    cvalues = strides.map CInt64.fromInt
    cvaluesArray = (Array CInt64) . fromList cvalues
    addAttrIntList.call None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
    cvaluesArray.free
    nameCStr.free
    nameCStr = CString.fromText "padding"
    valCStr = CString.fromText padding
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    nameCStr = CString.fromText "data_format"
    valCStr = CString.fromText dataxformat
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    nameCStr = CString.fromText "dilations"
    cvalues = dilations.map CInt64.fromInt
    cvaluesArray = (Array CInt64) . fromList cvalues
    addAttrIntList.call None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt dilations.length . toCArg]
    cvaluesArray.free
    nameCStr.free
    wrappers = makeOutputWrappers "DepthwiseConv2dNativeBackpropInput" [inputxsizes, filter, outxbackprop] [filter.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def depthwiseConv2dNativeGen chosenName input filter t strides padding dataxformat dilations:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrIntList = lookupSymbol "TFL" "add_attr_int_list"
    addAttrString = lookupSymbol "TFL" "add_attr_string"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "strides"
    cvalues = strides.map CInt64.fromInt
    cvaluesArray = (Array CInt64) . fromList cvalues
    addAttrIntList.call None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
    cvaluesArray.free
    nameCStr.free
    nameCStr = CString.fromText "padding"
    valCStr = CString.fromText padding
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    nameCStr = CString.fromText "data_format"
    valCStr = CString.fromText dataxformat
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    nameCStr = CString.fromText "dilations"
    cvalues = dilations.map CInt64.fromInt
    cvaluesArray = (Array CInt64) . fromList cvalues
    addAttrIntList.call None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt dilations.length . toCArg]
    cvaluesArray.free
    nameCStr.free
    wrappers = makeOutputWrappers "DepthwiseConv2dNative" [input, filter] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def fusedResizeAndPadConv2DGen chosenName input size paddings filter t resizexalignxcorners mode strides padding:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrIntList = lookupSymbol "TFL" "add_attr_int_list"
    addAttrString = lookupSymbol "TFL" "add_attr_string"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "resize_align_corners"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if resizexalignxcorners then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "mode"
    valCStr = CString.fromText mode
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    nameCStr = CString.fromText "strides"
    cvalues = strides.map CInt64.fromInt
    cvaluesArray = (Array CInt64) . fromList cvalues
    addAttrIntList.call None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
    cvaluesArray.free
    nameCStr.free
    nameCStr = CString.fromText "padding"
    valCStr = CString.fromText padding
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    wrappers = makeOutputWrappers "FusedResizeAndPadConv2D" [input, size, paddings, filter] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def dataFormatVecPermuteGen chosenName x t srcxformat dstxformat:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrString = lookupSymbol "TFL" "add_attr_string"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "src_format"
    valCStr = CString.fromText srcxformat
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    nameCStr = CString.fromText "dst_format"
    valCStr = CString.fromText dstxformat
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    wrappers = makeOutputWrappers "DataFormatVecPermute" [x] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def conv2DBackpropFilterGen chosenName input filterxsizes outxbackprop t strides usexcudnnxonxgpu padding dataxformat dilations:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrIntList = lookupSymbol "TFL" "add_attr_int_list"
    addAttrString = lookupSymbol "TFL" "add_attr_string"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "strides"
    cvalues = strides.map CInt64.fromInt
    cvaluesArray = (Array CInt64) . fromList cvalues
    addAttrIntList.call None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
    cvaluesArray.free
    nameCStr.free
    nameCStr = CString.fromText "use_cudnn_on_gpu"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if usexcudnnxonxgpu then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "padding"
    valCStr = CString.fromText padding
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    nameCStr = CString.fromText "data_format"
    valCStr = CString.fromText dataxformat
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    nameCStr = CString.fromText "dilations"
    cvalues = dilations.map CInt64.fromInt
    cvaluesArray = (Array CInt64) . fromList cvalues
    addAttrIntList.call None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt dilations.length . toCArg]
    cvaluesArray.free
    nameCStr.free
    wrappers = makeOutputWrappers "Conv2DBackpropFilter" [input, filterxsizes, outxbackprop] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def biasAddGen chosenName value bias t dataxformat:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrString = lookupSymbol "TFL" "add_attr_string"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "data_format"
    valCStr = CString.fromText dataxformat
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    wrappers = makeOutputWrappers "BiasAdd" [value, bias] [value.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def fusedBatchNormGen chosenName x scale offset mean variance t epsilon dataxformat isxtraining:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrFloat = lookupSymbol "TFL" "add_attr_float"
    addAttrString = lookupSymbol "TFL" "add_attr_string"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "epsilon"
    addAttrFloat.call None [attrList.toCArg, nameCStr.toCArg, CFloat.fromReal epsilon . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "data_format"
    valCStr = CString.fromText dataxformat
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    nameCStr = CString.fromText "is_training"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if isxtraining then 1 else 0) . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "FusedBatchNorm" [x, scale, offset, mean, variance] [x.wrapper.typetag, x.wrapper.typetag, x.wrapper.typetag, x.wrapper.typetag, x.wrapper.typetag] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def avgPoolGradGen chosenName origxinputxshape grad ksize strides padding dataxformat t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrIntList = lookupSymbol "TFL" "add_attr_int_list"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrString = lookupSymbol "TFL" "add_attr_string"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "ksize"
    cvalues = ksize.map CInt64.fromInt
    cvaluesArray = (Array CInt64) . fromList cvalues
    addAttrIntList.call None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt ksize.length . toCArg]
    cvaluesArray.free
    nameCStr.free
    nameCStr = CString.fromText "strides"
    cvalues = strides.map CInt64.fromInt
    cvaluesArray = (Array CInt64) . fromList cvalues
    addAttrIntList.call None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
    cvaluesArray.free
    nameCStr.free
    nameCStr = CString.fromText "padding"
    valCStr = CString.fromText padding
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    nameCStr = CString.fromText "data_format"
    valCStr = CString.fromText dataxformat
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "AvgPoolGrad" [origxinputxshape, grad] [grad.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def clipByValueGen chosenName t clipxvaluexmin clipxvaluexmax t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "ClipByValue" [t, clipxvaluexmin, clipxvaluexmax] [t.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def cumprodGen chosenName x axis exclusive reverse t tidx:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "exclusive"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if exclusive then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "reverse"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if reverse then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tidx"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tidx.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Cumprod" [x, axis] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def cumsumGen chosenName x axis exclusive reverse t tidx:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "exclusive"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if exclusive then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "reverse"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if reverse then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tidx"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tidx.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Cumsum" [x, axis] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def bincountGen chosenName arr size weights t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Bincount" [arr, size, weights] [weights.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def histogramFixedWidthGen chosenName values valuexrange nbins t dtype:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "dtype"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt dtype.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "HistogramFixedWidth" [values, valuexrange, nbins] [dtype] attrList chosenName
    TFOutput wrappers.head.get

def rangeGen chosenName start limit delta tidx:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "Tidx"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tidx.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Range" [start, limit, delta] [start.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def lRNGradGen chosenName inputxgrads inputximage outputximage depthxradius bias alpha beta t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrInt = lookupSymbol "TFL" "add_attr_int"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrFloat = lookupSymbol "TFL" "add_attr_float"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "depth_radius"
    addAttrInt.call None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt depthxradius . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "bias"
    addAttrFloat.call None [attrList.toCArg, nameCStr.toCArg, CFloat.fromReal bias . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "alpha"
    addAttrFloat.call None [attrList.toCArg, nameCStr.toCArg, CFloat.fromReal alpha . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "beta"
    addAttrFloat.call None [attrList.toCArg, nameCStr.toCArg, CFloat.fromReal beta . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "LRNGrad" [inputxgrads, inputximage, outputximage] [inputxgrads.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def anyGen chosenName input reductionxindices keepxdims tidx:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "keep_dims"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if keepxdims then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tidx"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tidx.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Any" [input, reductionxindices] [BoolType] attrList chosenName
    TFOutput wrappers.head.get

def sparseSegmentSqrtNGradGen chosenName grad indices segmentxids outputxdim0 t tidx:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tidx"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tidx.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "SparseSegmentSqrtNGrad" [grad, indices, segmentxids, outputxdim0] [grad.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def sparseSegmentSqrtNGen chosenName data indices segmentxids t tidx:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tidx"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tidx.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "SparseSegmentSqrtN" [data, indices, segmentxids] [data.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def sparseSegmentMeanGen chosenName data indices segmentxids t tidx:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tidx"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tidx.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "SparseSegmentMean" [data, indices, segmentxids] [data.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def sparseSegmentSumWithNumSegmentsGen chosenName data indices segmentxids numxsegments t tidx tnumsegments:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tidx"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tidx.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tnumsegments"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tnumsegments.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "SparseSegmentSumWithNumSegments" [data, indices, segmentxids, numxsegments] [data.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def sparseSegmentSumGen chosenName data indices segmentxids t tidx:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tidx"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tidx.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "SparseSegmentSum" [data, indices, segmentxids] [data.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def unsortedSegmentProdGen chosenName data segmentxids numxsegments t tindices tnumsegments:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tindices"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tnumsegments"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tnumsegments.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "UnsortedSegmentProd" [data, segmentxids, numxsegments] [data.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def unsortedSegmentMinGen chosenName data segmentxids numxsegments t tindices tnumsegments:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tindices"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tnumsegments"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tnumsegments.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "UnsortedSegmentMin" [data, segmentxids, numxsegments] [data.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def nthElementGen chosenName input n reverse t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "reverse"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if reverse then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "NthElement" [input, n] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def unsortedSegmentMaxGen chosenName data segmentxids numxsegments t tindices tnumsegments:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tindices"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tnumsegments"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tnumsegments.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "UnsortedSegmentMax" [data, segmentxids, numxsegments] [data.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def unsortedSegmentSumGen chosenName data segmentxids numxsegments t tindices tnumsegments:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tindices"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tnumsegments"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tnumsegments.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "UnsortedSegmentSum" [data, segmentxids, numxsegments] [data.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def segmentMinGen chosenName data segmentxids t tindices:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tindices"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "SegmentMin" [data, segmentxids] [data.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def segmentMeanGen chosenName data segmentxids t tindices:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tindices"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "SegmentMean" [data, segmentxids] [data.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def argMinGen chosenName input dimension t tidx outputxtype:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tidx"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tidx.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "output_type"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt outputxtype.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "ArgMin" [input, dimension] [outputxtype] attrList chosenName
    TFOutput wrappers.head.get

def maxGen chosenName input reductionxindices keepxdims t tidx:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "keep_dims"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if keepxdims then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tidx"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tidx.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Max" [input, reductionxindices] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def sumGen chosenName input reductionxindices keepxdims t tidx:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "keep_dims"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if keepxdims then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tidx"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tidx.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Sum" [input, reductionxindices] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def sparseMatMulGen chosenName a b transposexa transposexb axisxsparse bxisxsparse ta tb:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "transpose_a"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if transposexa then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "transpose_b"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if transposexb then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "a_is_sparse"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if axisxsparse then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "b_is_sparse"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if bxisxsparse then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Ta"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt ta.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tb"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tb.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "SparseMatMul" [a, b] [FloatType] attrList chosenName
    TFOutput wrappers.head.get

def matMulGen chosenName a b transposexa transposexb t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "transpose_a"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if transposexa then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "transpose_b"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if transposexb then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "MatMul" [a, b] [a.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def selectGen chosenName condition t e t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Select" [condition, t, e] [t.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def logicalOrGen chosenName x y:
    wrappers = makeOutputWrappers "LogicalOr" [x, y] [BoolType] attrList chosenName
    TFOutput wrappers.head.get

def logicalAndGen chosenName x y:
    wrappers = makeOutputWrappers "LogicalAnd" [x, y] [BoolType] attrList chosenName
    TFOutput wrappers.head.get

def approximateEqualGen chosenName x y t tolerance:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrFloat = lookupSymbol "TFL" "add_attr_float"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "tolerance"
    addAttrFloat.call None [attrList.toCArg, nameCStr.toCArg, CFloat.fromReal tolerance . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "ApproximateEqual" [x, y] [BoolType] attrList chosenName
    TFOutput wrappers.head.get

def notEqualGen chosenName x y t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "NotEqual" [x, y] [BoolType] attrList chosenName
    TFOutput wrappers.head.get

def greaterEqualGen chosenName x y t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "GreaterEqual" [x, y] [BoolType] attrList chosenName
    TFOutput wrappers.head.get

def greaterGen chosenName x y t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Greater" [x, y] [BoolType] attrList chosenName
    TFOutput wrappers.head.get

def lessEqualGen chosenName x y t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "LessEqual" [x, y] [BoolType] attrList chosenName
    TFOutput wrappers.head.get

def lessGen chosenName x y t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Less" [x, y] [BoolType] attrList chosenName
    TFOutput wrappers.head.get

def betaincGen chosenName a b x t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Betainc" [a, b, x] [a.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def polygammaGen chosenName a x t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Polygamma" [a, x] [a.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def zetaGen chosenName x q t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Zeta" [x, q] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def meanGen chosenName input reductionxindices keepxdims t tidx:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "keep_dims"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if keepxdims then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tidx"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tidx.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Mean" [input, reductionxindices] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def initializeTableFromTextFileGen chosenName tablexhandle filename keyxindex valuexindex vocabxsize delimiter:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrInt = lookupSymbol "TFL" "add_attr_int"
    addAttrString = lookupSymbol "TFL" "add_attr_string"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "key_index"
    addAttrInt.call None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt keyxindex . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "value_index"
    addAttrInt.call None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt valuexindex . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "vocab_size"
    addAttrInt.call None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt vocabxsize . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "delimiter"
    valCStr = CString.fromText delimiter
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    wrappers = makeOutputWrappers "InitializeTableFromTextFile" [tablexhandle, filename] [] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def fakeQuantWithMinMaxVarsGradientGen chosenName gradients inputs min max numxbits narrowxrange:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrInt = lookupSymbol "TFL" "add_attr_int"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "num_bits"
    addAttrInt.call None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt numxbits . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "narrow_range"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if narrowxrange then 1 else 0) . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "FakeQuantWithMinMaxVarsGradient" [gradients, inputs, min, max] [FloatType, FloatType, FloatType] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def minimumGen chosenName x y t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Minimum" [x, y] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def batchCholeskyGen chosenName input t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "BatchCholesky" [input] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def resizeBilinearGradGen chosenName grads originalximage t alignxcorners:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "align_corners"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if alignxcorners then 1 else 0) . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "ResizeBilinearGrad" [grads, originalximage] [originalximage.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def lookupTableSizeGen chosenName tablexhandle:
    wrappers = makeOutputWrappers "LookupTableSize" [tablexhandle] [Int64Type] attrList chosenName
    TFOutput wrappers.head.get

def bucketizeGen chosenName input t boundaries:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrFloatList = lookupSymbol "TFL" "add_attr_float_list"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "boundaries"
    cvalues = boundaries.map CFloat.fromReal
    cvaluesArray = (Array CFloat) . fromList cvalues
    addAttrFloatList.call None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt boundaries.length . toCArg]
    cvaluesArray.free
    nameCStr.free
    wrappers = makeOutputWrappers "Bucketize" [input] [Int32Type] attrList chosenName
    TFOutput wrappers.head.get

def lookupTableInsertGen chosenName tablexhandle keys values tin tout:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "Tin"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tin.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tout"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tout.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "LookupTableInsert" [tablexhandle, keys, values] [] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def tPUReplicateMetadataGen chosenName numxreplicas topology usextpu devicexassignment computationxshape hostxcomputexcore:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrIntList = lookupSymbol "TFL" "add_attr_int_list"
    addAttrInt = lookupSymbol "TFL" "add_attr_int"
    addAttrString = lookupSymbol "TFL" "add_attr_string"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    addAttrStringList = lookupSymbol "TFL" "add_attr_string_list"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "num_replicas"
    addAttrInt.call None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt numxreplicas . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "topology"
    valCStr = CString.fromText topology
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    nameCStr = CString.fromText "use_tpu"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if usextpu then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "device_assignment"
    cvalues = devicexassignment.map CInt64.fromInt
    cvaluesArray = (Array CInt64) . fromList cvalues
    addAttrIntList.call None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt devicexassignment.length . toCArg]
    cvaluesArray.free
    nameCStr.free
    nameCStr = CString.fromText "computation_shape"
    cvalues = computationxshape.map CInt64.fromInt
    cvaluesArray = (Array CInt64) . fromList cvalues
    addAttrIntList.call None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt computationxshape.length . toCArg]
    cvaluesArray.free
    nameCStr.free
    nameCStr = CString.fromText "host_compute_core"
    len = hostxcomputexcore.length
    cValues = ManagedPointer (Pointer CInt64) . mallocElems len
    indexed = 0.upto (len - 1) . zip hostxcomputexcore
    indexed.each (idx, elem):
            cValues.moveElems idx . write (CString.fromText elem)
    addAttrStringList.call None [attrList.toCArg, nameCStr.toCArg, cValues.toCArg, CUInt32.fromInt len . toCArg]
    0.upto (len - 1) . each (idx: cValues.moveElems idx . read . free)
    nameCStr.free
    wrappers = makeOutputWrappers "TPUReplicateMetadata" [] [] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def batchMatrixTriangularSolveGen chosenName matrix rhs lower adjoint t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "lower"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if lower then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "adjoint"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if adjoint then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "BatchMatrixTriangularSolve" [matrix, rhs] [matrix.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def batchSelfAdjointEigGen chosenName input t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "BatchSelfAdjointEig" [input] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def choleskyGradGen chosenName l grad t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "CholeskyGrad" [l, grad] [l.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def fusedBatchNormGradGen chosenName yxbackprop x scale reservexspacex1 reservexspacex2 t epsilon dataxformat isxtraining:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrFloat = lookupSymbol "TFL" "add_attr_float"
    addAttrString = lookupSymbol "TFL" "add_attr_string"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "epsilon"
    addAttrFloat.call None [attrList.toCArg, nameCStr.toCArg, CFloat.fromReal epsilon . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "data_format"
    valCStr = CString.fromText dataxformat
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    nameCStr = CString.fromText "is_training"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if isxtraining then 1 else 0) . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "FusedBatchNormGrad" [yxbackprop, x, scale, reservexspacex1, reservexspacex2] [yxbackprop.wrapper.typetag, yxbackprop.wrapper.typetag, yxbackprop.wrapper.typetag, yxbackprop.wrapper.typetag, yxbackprop.wrapper.typetag] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def cosGen chosenName x t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Cos" [x] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def choleskyGen chosenName input t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Cholesky" [input] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def sparseApplyFtrlV2Gen chosenName var accum linear grad indices lr l1 l2 l2xshrinkage lrxpower t tindices usexlocking:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tindices"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "use_locking"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if usexlocking then 1 else 0) . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "SparseApplyFtrlV2" [var, accum, linear, grad, indices, lr, l1, l2, l2xshrinkage, lrxpower] [var.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def maxPoolGradV2Gen chosenName origxinput origxoutput grad ksize strides padding dataxformat t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrString = lookupSymbol "TFL" "add_attr_string"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "padding"
    valCStr = CString.fromText padding
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    nameCStr = CString.fromText "data_format"
    valCStr = CString.fromText dataxformat
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "MaxPoolGradV2" [origxinput, origxoutput, grad, ksize, strides] [origxinput.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def readerNumRecordsProducedGen chosenName readerxhandle:
    wrappers = makeOutputWrappers "ReaderNumRecordsProduced" [readerxhandle] [Int64Type] attrList chosenName
    TFOutput wrappers.head.get

def matrixInverseGen chosenName input adjoint t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "adjoint"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if adjoint then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "MatrixInverse" [input] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def statelessTruncatedNormalGen chosenName shape seed dtype t tseed:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "dtype"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt dtype.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tseed"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tseed.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "StatelessTruncatedNormal" [shape, seed] [dtype] attrList chosenName
    TFOutput wrappers.head.get

def noOpGen chosenName:
    wrappers = makeOutputWrappers "NoOp" [] [] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def nonMaxSuppressionV4Gen chosenName boxes scores maxxoutputxsize iouxthreshold scorexthreshold padxtoxmaxxoutputxsize:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "pad_to_max_output_size"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if padxtoxmaxxoutputxsize then 1 else 0) . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "NonMaxSuppressionV4" [boxes, scores, maxxoutputxsize, iouxthreshold, scorexthreshold] [Int32Type, Int32Type] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def nonMaxSuppressionGen chosenName boxes scores maxxoutputxsize iouxthreshold:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrFloat = lookupSymbol "TFL" "add_attr_float"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "iou_threshold"
    addAttrFloat.call None [attrList.toCArg, nameCStr.toCArg, CFloat.fromReal iouxthreshold . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "NonMaxSuppression" [boxes, scores, maxxoutputxsize] [Int32Type] attrList chosenName
    TFOutput wrappers.head.get

def nonMaxSuppressionWithOverlapsGen chosenName overlaps scores maxxoutputxsize overlapxthreshold scorexthreshold:
    wrappers = makeOutputWrappers "NonMaxSuppressionWithOverlaps" [overlaps, scores, maxxoutputxsize, overlapxthreshold, scorexthreshold] [Int32Type] attrList chosenName
    TFOutput wrappers.head.get

def computeAccidentalHitsGen chosenName truexclasses sampledxcandidates numxtrue seed seed2:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrInt = lookupSymbol "TFL" "add_attr_int"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "num_true"
    addAttrInt.call None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt numxtrue . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "seed"
    addAttrInt.call None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt seed . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "seed2"
    addAttrInt.call None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt seed2 . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "ComputeAccidentalHits" [truexclasses, sampledxcandidates] [Int32Type, Int64Type, FloatType] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def cropAndResizeGradBoxesGen chosenName grads image boxes boxxind t method:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrString = lookupSymbol "TFL" "add_attr_string"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "method"
    valCStr = CString.fromText method
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    wrappers = makeOutputWrappers "CropAndResizeGradBoxes" [grads, image, boxes, boxxind] [FloatType] attrList chosenName
    TFOutput wrappers.head.get

def extractGlimpseGen chosenName input size offsets centered normalized uniformxnoise:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "centered"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if centered then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "normalized"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if normalized then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "uniform_noise"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if uniformxnoise then 1 else 0) . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "ExtractGlimpse" [input, size, offsets] [FloatType] attrList chosenName
    TFOutput wrappers.head.get

def sparseSliceGradGen chosenName backpropxvalxgrad inputxindices inputxstart outputxindices t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "SparseSliceGrad" [backpropxvalxgrad, inputxindices, inputxstart, outputxindices] [backpropxvalxgrad.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def batchSvdGen chosenName input computexuv fullxmatrices t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "compute_uv"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if computexuv then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "full_matrices"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if fullxmatrices then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "BatchSvd" [input] [input.wrapper.typetag, input.wrapper.typetag, input.wrapper.typetag] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def rGBToHSVGen chosenName images t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "RGBToHSV" [images] [images.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def decodeGifGen chosenName contents:
    wrappers = makeOutputWrappers "DecodeGif" [contents] [UInt8Type] attrList chosenName
    TFOutput wrappers.head.get

def decodePngGen chosenName contents channels dtype:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrInt = lookupSymbol "TFL" "add_attr_int"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "channels"
    addAttrInt.call None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt channels . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "dtype"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt dtype.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "DecodePng" [contents] [dtype] attrList chosenName
    TFOutput wrappers.head.get

def adjustSaturationGen chosenName images scale:
    wrappers = makeOutputWrappers "AdjustSaturation" [images, scale] [FloatType] attrList chosenName
    TFOutput wrappers.head.get

def matrixSolveGen chosenName matrix rhs adjoint t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "adjoint"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if adjoint then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "MatrixSolve" [matrix, rhs] [matrix.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def softplusGradGen chosenName gradients features t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "SoftplusGrad" [gradients, features] [gradients.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def selfAdjointEigV2Gen chosenName input computexv t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "compute_v"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if computexv then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "SelfAdjointEigV2" [input] [input.wrapper.typetag, input.wrapper.typetag] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def decodeJpegGen chosenName contents channels ratio fancyxupscaling tryxrecoverxtruncated acceptablexfraction dctxmethod:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrInt = lookupSymbol "TFL" "add_attr_int"
    addAttrFloat = lookupSymbol "TFL" "add_attr_float"
    addAttrString = lookupSymbol "TFL" "add_attr_string"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "channels"
    addAttrInt.call None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt channels . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "ratio"
    addAttrInt.call None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt ratio . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "fancy_upscaling"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if fancyxupscaling then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "try_recover_truncated"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if tryxrecoverxtruncated then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "acceptable_fraction"
    addAttrFloat.call None [attrList.toCArg, nameCStr.toCArg, CFloat.fromReal acceptablexfraction . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "dct_method"
    valCStr = CString.fromText dctxmethod
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    wrappers = makeOutputWrappers "DecodeJpeg" [contents] [UInt8Type] attrList chosenName
    TFOutput wrappers.head.get

def fakeParamGen chosenName dtype shape:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrShape = lookupSymbol "TFL" "add_attr_shape"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "dtype"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt dtype.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "shape"
    cdims = shape.map CInt64.fromInt
    cdimsArray = (Array CInt64) . fromList cdims
    addAttrShape.call None [attrList.toCArg, nameCStr.toCArg, cdimsArray.toCArg, CUInt32.fromInt shape.length . toCArg]
    cdimsArray.free
    nameCStr.free
    wrappers = makeOutputWrappers "FakeParam" [] [dtype] attrList chosenName
    TFOutput wrappers.head.get

def resizeNearestNeighborGen chosenName images size t alignxcorners:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "align_corners"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if alignxcorners then 1 else 0) . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "ResizeNearestNeighbor" [images, size] [images.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def resizeBicubicGradGen chosenName grads originalximage t alignxcorners:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "align_corners"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if alignxcorners then 1 else 0) . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "ResizeBicubicGrad" [grads, originalximage] [originalximage.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def resizeBicubicGen chosenName images size t alignxcorners:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "align_corners"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if alignxcorners then 1 else 0) . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "ResizeBicubic" [images, size] [FloatType] attrList chosenName
    TFOutput wrappers.head.get

def log1pGen chosenName x t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Log1p" [x] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def tPUCompilationResultGen chosenName:
    wrappers = makeOutputWrappers "TPUCompilationResult" [] [StringType] attrList chosenName
    TFOutput wrappers.head.get

def nonMaxSuppressionV2Gen chosenName boxes scores maxxoutputxsize iouxthreshold:
    wrappers = makeOutputWrappers "NonMaxSuppressionV2" [boxes, scores, maxxoutputxsize, iouxthreshold] [Int32Type] attrList chosenName
    TFOutput wrappers.head.get

def reshapeGen chosenName tensor shape t tshape:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tshape"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tshape.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Reshape" [tensor, shape] [tensor.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def avgPool3DGen chosenName input ksize strides padding dataxformat t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrIntList = lookupSymbol "TFL" "add_attr_int_list"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrString = lookupSymbol "TFL" "add_attr_string"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "ksize"
    cvalues = ksize.map CInt64.fromInt
    cvaluesArray = (Array CInt64) . fromList cvalues
    addAttrIntList.call None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt ksize.length . toCArg]
    cvaluesArray.free
    nameCStr.free
    nameCStr = CString.fromText "strides"
    cvalues = strides.map CInt64.fromInt
    cvaluesArray = (Array CInt64) . fromList cvalues
    addAttrIntList.call None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
    cvaluesArray.free
    nameCStr.free
    nameCStr = CString.fromText "padding"
    valCStr = CString.fromText padding
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    nameCStr = CString.fromText "data_format"
    valCStr = CString.fromText dataxformat
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "AvgPool3D" [input] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def crossGen chosenName a b t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Cross" [a, b] [a.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def tensorArrayUnpackGen chosenName handle value flowxin t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "TensorArrayUnpack" [handle, value, flowxin] [FloatType] attrList chosenName
    TFOutput wrappers.head.get

def sinhGen chosenName x t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Sinh" [x] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def dilation2DGen chosenName input filter t strides rates padding:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrIntList = lookupSymbol "TFL" "add_attr_int_list"
    addAttrString = lookupSymbol "TFL" "add_attr_string"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "strides"
    cvalues = strides.map CInt64.fromInt
    cvaluesArray = (Array CInt64) . fromList cvalues
    addAttrIntList.call None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
    cvaluesArray.free
    nameCStr.free
    nameCStr = CString.fromText "rates"
    cvalues = rates.map CInt64.fromInt
    cvaluesArray = (Array CInt64) . fromList cvalues
    addAttrIntList.call None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt rates.length . toCArg]
    cvaluesArray.free
    nameCStr.free
    nameCStr = CString.fromText "padding"
    valCStr = CString.fromText padding
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    wrappers = makeOutputWrappers "Dilation2D" [input, filter] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def tensorArrayConcatV2Gen chosenName handle flowxin dtype elementxshapexexcept0:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrShape = lookupSymbol "TFL" "add_attr_shape"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "dtype"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt dtype.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "element_shape_except0"
    cdims = elementxshapexexcept0.map CInt64.fromInt
    cdimsArray = (Array CInt64) . fromList cdims
    addAttrShape.call None [attrList.toCArg, nameCStr.toCArg, cdimsArray.toCArg, CUInt32.fromInt elementxshapexexcept0.length . toCArg]
    cdimsArray.free
    nameCStr.free
    wrappers = makeOutputWrappers "TensorArrayConcatV2" [handle, flowxin] [dtype, Int64Type] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def atan2Gen chosenName y x t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Atan2" [y, x] [y.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def identityGen chosenName input t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Identity" [input] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def adjustContrastv2Gen chosenName images contrastxfactor:
    wrappers = makeOutputWrappers "AdjustContrastv2" [images, contrastxfactor] [FloatType] attrList chosenName
    TFOutput wrappers.head.get

def nonMaxSuppressionV3Gen chosenName boxes scores maxxoutputxsize iouxthreshold scorexthreshold:
    wrappers = makeOutputWrappers "NonMaxSuppressionV3" [boxes, scores, maxxoutputxsize, iouxthreshold, scorexthreshold] [Int32Type] attrList chosenName
    TFOutput wrappers.head.get

def batchNormWithGlobalNormalizationGradGen chosenName t m v gamma backprop t variancexepsilon scalexafterxnormalization:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrFloat = lookupSymbol "TFL" "add_attr_float"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "variance_epsilon"
    addAttrFloat.call None [attrList.toCArg, nameCStr.toCArg, CFloat.fromReal variancexepsilon . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "scale_after_normalization"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if scalexafterxnormalization then 1 else 0) . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "BatchNormWithGlobalNormalizationGrad" [t, m, v, gamma, backprop] [t.wrapper.typetag, t.wrapper.typetag, t.wrapper.typetag, t.wrapper.typetag, t.wrapper.typetag] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def logMatrixDeterminantGen chosenName input t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "LogMatrixDeterminant" [input] [input.wrapper.typetag, input.wrapper.typetag] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def seluGen chosenName features t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Selu" [features] [features.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def setSizeGen chosenName setxindices setxvalues setxshape validatexindices t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "validate_indices"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if validatexindices then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "SetSize" [setxindices, setxvalues, setxshape] [Int32Type] attrList chosenName
    TFOutput wrappers.head.get

def substrGen chosenName input pos len t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Substr" [input, pos, len] [StringType] attrList chosenName
    TFOutput wrappers.head.get

def debugNumericSummaryGen chosenName input t devicexname tensorxname debugxurls lowerxbound upperxbound mutexifxhealthy gatedxgrpc:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrFloat = lookupSymbol "TFL" "add_attr_float"
    addAttrString = lookupSymbol "TFL" "add_attr_string"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    addAttrStringList = lookupSymbol "TFL" "add_attr_string_list"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "device_name"
    valCStr = CString.fromText devicexname
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    nameCStr = CString.fromText "tensor_name"
    valCStr = CString.fromText tensorxname
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    nameCStr = CString.fromText "debug_urls"
    len = debugxurls.length
    cValues = ManagedPointer (Pointer CInt64) . mallocElems len
    indexed = 0.upto (len - 1) . zip debugxurls
    indexed.each (idx, elem):
            cValues.moveElems idx . write (CString.fromText elem)
    addAttrStringList.call None [attrList.toCArg, nameCStr.toCArg, cValues.toCArg, CUInt32.fromInt len . toCArg]
    0.upto (len - 1) . each (idx: cValues.moveElems idx . read . free)
    nameCStr.free
    nameCStr = CString.fromText "lower_bound"
    addAttrFloat.call None [attrList.toCArg, nameCStr.toCArg, CFloat.fromReal lowerxbound . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "upper_bound"
    addAttrFloat.call None [attrList.toCArg, nameCStr.toCArg, CFloat.fromReal upperxbound . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "mute_if_healthy"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if mutexifxhealthy then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "gated_grpc"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if gatedxgrpc then 1 else 0) . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "DebugNumericSummary" [input] [DoubleType] attrList chosenName
    TFOutput wrappers.head.get

def fusedBatchNormV2Gen chosenName x scale offset mean variance t u epsilon dataxformat isxtraining:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrFloat = lookupSymbol "TFL" "add_attr_float"
    addAttrString = lookupSymbol "TFL" "add_attr_string"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "U"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt u.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "epsilon"
    addAttrFloat.call None [attrList.toCArg, nameCStr.toCArg, CFloat.fromReal epsilon . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "data_format"
    valCStr = CString.fromText dataxformat
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    nameCStr = CString.fromText "is_training"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if isxtraining then 1 else 0) . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "FusedBatchNormV2" [x, scale, offset, mean, variance] [x.wrapper.typetag, scale.wrapper.typetag, scale.wrapper.typetag, scale.wrapper.typetag, scale.wrapper.typetag] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def debugIdentityGen chosenName input t devicexname tensorxname debugxurls gatedxgrpc:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrStringList = lookupSymbol "TFL" "add_attr_string_list"
    addAttrString = lookupSymbol "TFL" "add_attr_string"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "device_name"
    valCStr = CString.fromText devicexname
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    nameCStr = CString.fromText "tensor_name"
    valCStr = CString.fromText tensorxname
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    nameCStr = CString.fromText "debug_urls"
    len = debugxurls.length
    cValues = ManagedPointer (Pointer CInt64) . mallocElems len
    indexed = 0.upto (len - 1) . zip debugxurls
    indexed.each (idx, elem):
            cValues.moveElems idx . write (CString.fromText elem)
    addAttrStringList.call None [attrList.toCArg, nameCStr.toCArg, cValues.toCArg, CUInt32.fromInt len . toCArg]
    0.upto (len - 1) . each (idx: cValues.moveElems idx . read . free)
    nameCStr.free
    nameCStr = CString.fromText "gated_grpc"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if gatedxgrpc then 1 else 0) . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "DebugIdentity" [input] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def accumulatorTakeGradientGen chosenName handle numxrequired dtype:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "dtype"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt dtype.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "AccumulatorTakeGradient" [handle, numxrequired] [dtype] attrList chosenName
    TFOutput wrappers.head.get

def tensorSummaryV2Gen chosenName tag tensor serializedxsummaryxmetadata t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "TensorSummaryV2" [tag, tensor, serializedxsummaryxmetadata] [StringType] attrList chosenName
    TFOutput wrappers.head.get

def tensorArrayConcatGen chosenName handle flowxin dtype elementxshapexexcept0:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrShape = lookupSymbol "TFL" "add_attr_shape"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "dtype"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt dtype.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "element_shape_except0"
    cdims = elementxshapexexcept0.map CInt64.fromInt
    cdimsArray = (Array CInt64) . fromList cdims
    addAttrShape.call None [attrList.toCArg, nameCStr.toCArg, cdimsArray.toCArg, CUInt32.fromInt elementxshapexexcept0.length . toCArg]
    cdimsArray.free
    nameCStr.free
    wrappers = makeOutputWrappers "TensorArrayConcat" [handle, flowxin] [dtype, Int64Type] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def reciprocalGen chosenName x t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Reciprocal" [x] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def qrGen chosenName input fullxmatrices t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "full_matrices"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if fullxmatrices then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Qr" [input] [input.wrapper.typetag, input.wrapper.typetag] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def audioSummaryGen chosenName tag tensor samplexrate maxxoutputs:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrInt = lookupSymbol "TFL" "add_attr_int"
    addAttrFloat = lookupSymbol "TFL" "add_attr_float"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "sample_rate"
    addAttrFloat.call None [attrList.toCArg, nameCStr.toCArg, CFloat.fromReal samplexrate . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "max_outputs"
    addAttrInt.call None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt maxxoutputs . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "AudioSummary" [tag, tensor] [StringType] attrList chosenName
    TFOutput wrappers.head.get

def sparseReduceMaxSparseGen chosenName inputxindices inputxvalues inputxshape reductionxaxes keepxdims t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "keep_dims"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if keepxdims then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "SparseReduceMaxSparse" [inputxindices, inputxvalues, inputxshape, reductionxaxes] [Int64Type, inputxvalues.wrapper.typetag, Int64Type] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def barrierIncompleteSizeGen chosenName handle:
    wrappers = makeOutputWrappers "BarrierIncompleteSize" [handle] [Int32Type] attrList chosenName
    TFOutput wrappers.head.get

def segmentSumGen chosenName data segmentxids t tindices:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tindices"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "SegmentSum" [data, segmentxids] [data.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def roundGen chosenName x t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Round" [x] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def matrixSetDiagGen chosenName input diagonal t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "MatrixSetDiag" [input, diagonal] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def sparseSparseMaximumGen chosenName axindices axvalues axshape bxindices bxvalues bxshape t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "SparseSparseMaximum" [axindices, axvalues, axshape, bxindices, bxvalues, bxshape] [Int64Type, axvalues.wrapper.typetag] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def matrixExponentialGen chosenName input t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "MatrixExponential" [input] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def biasAddGradGen chosenName outxbackprop t dataxformat:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrString = lookupSymbol "TFL" "add_attr_string"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "data_format"
    valCStr = CString.fromText dataxformat
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    wrappers = makeOutputWrappers "BiasAddGrad" [outxbackprop] [outxbackprop.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def queueSizeGen chosenName handle:
    wrappers = makeOutputWrappers "QueueSize" [handle] [Int32Type] attrList chosenName
    TFOutput wrappers.head.get

def sparseDenseCwiseAddGen chosenName spxindices spxvalues spxshape dense t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "SparseDenseCwiseAdd" [spxindices, spxvalues, spxshape, dense] [spxvalues.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def lookupTableFindGen chosenName tablexhandle keys defaultxvalue tin tout:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "Tin"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tin.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tout"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tout.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "LookupTableFind" [tablexhandle, keys, defaultxvalue] [defaultxvalue.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def ensureShapeGen chosenName input shape t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrShape = lookupSymbol "TFL" "add_attr_shape"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "shape"
    cdims = shape.map CInt64.fromInt
    cdimsArray = (Array CInt64) . fromList cdims
    addAttrShape.call None [attrList.toCArg, nameCStr.toCArg, cdimsArray.toCArg, CUInt32.fromInt shape.length . toCArg]
    cdimsArray.free
    nameCStr.free
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "EnsureShape" [input] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def stackCloseGen chosenName handle:
    wrappers = makeOutputWrappers "StackClose" [handle] [] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def readerSerializeStateGen chosenName readerxhandle:
    wrappers = makeOutputWrappers "ReaderSerializeState" [readerxhandle] [StringType] attrList chosenName
    TFOutput wrappers.head.get

def tanGen chosenName x t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Tan" [x] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def decodeBmpGen chosenName contents channels:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrInt = lookupSymbol "TFL" "add_attr_int"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "channels"
    addAttrInt.call None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt channels . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "DecodeBmp" [contents] [UInt8Type] attrList chosenName
    TFOutput wrappers.head.get

def rsqrtGen chosenName x t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Rsqrt" [x] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def cTCLossGen chosenName inputs labelsxindices labelsxvalues sequencexlength preprocessxcollapsexrepeated ctcxmergexrepeated ignorexlongerxoutputsxthanxinputs:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "preprocess_collapse_repeated"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if preprocessxcollapsexrepeated then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "ctc_merge_repeated"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if ctcxmergexrepeated then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "ignore_longer_outputs_than_inputs"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if ignorexlongerxoutputsxthanxinputs then 1 else 0) . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "CTCLoss" [inputs, labelsxindices, labelsxvalues, sequencexlength] [FloatType, FloatType] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def quantizedResizeBilinearGen chosenName images size min max t alignxcorners:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "align_corners"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if alignxcorners then 1 else 0) . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "QuantizedResizeBilinear" [images, size, min, max] [images.wrapper.typetag, FloatType, FloatType] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def stackPopGen chosenName handle elemxtype:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "elem_type"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt elemxtype.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "StackPop" [handle] [elemxtype] attrList chosenName
    TFOutput wrappers.head.get

def svdGen chosenName input computexuv fullxmatrices t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "compute_uv"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if computexuv then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "full_matrices"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if fullxmatrices then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Svd" [input] [input.wrapper.typetag, input.wrapper.typetag, input.wrapper.typetag] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def batchSelfAdjointEigV2Gen chosenName input computexv t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "compute_v"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if computexv then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "BatchSelfAdjointEigV2" [input] [input.wrapper.typetag, input.wrapper.typetag] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def invGen chosenName x t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Inv" [x] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def populationCountGen chosenName x t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "PopulationCount" [x] [UInt8Type] attrList chosenName
    TFOutput wrappers.head.get

def decodeAndCropJpegGen chosenName contents cropxwindow channels ratio fancyxupscaling tryxrecoverxtruncated acceptablexfraction dctxmethod:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrInt = lookupSymbol "TFL" "add_attr_int"
    addAttrFloat = lookupSymbol "TFL" "add_attr_float"
    addAttrString = lookupSymbol "TFL" "add_attr_string"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "channels"
    addAttrInt.call None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt channels . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "ratio"
    addAttrInt.call None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt ratio . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "fancy_upscaling"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if fancyxupscaling then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "try_recover_truncated"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if tryxrecoverxtruncated then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "acceptable_fraction"
    addAttrFloat.call None [attrList.toCArg, nameCStr.toCArg, CFloat.fromReal acceptablexfraction . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "dct_method"
    valCStr = CString.fromText dctxmethod
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    wrappers = makeOutputWrappers "DecodeAndCropJpeg" [contents, cropxwindow] [UInt8Type] attrList chosenName
    TFOutput wrappers.head.get

def xMklAddGen chosenName x y mklxx mklxy t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "_MklAdd" [x, y, mklxx, mklxy] [x.wrapper.typetag, UInt8Type] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def reluGen chosenName features t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Relu" [features] [features.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def loopCondGen chosenName input:
    wrappers = makeOutputWrappers "LoopCond" [input] [BoolType] attrList chosenName
    TFOutput wrappers.head.get

def squaredDifferenceGen chosenName x y t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "SquaredDifference" [x, y] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def exitGen chosenName data t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Exit" [data] [data.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def cropAndResizeGen chosenName image boxes boxxind cropxsize t method extrapolationxvalue:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrFloat = lookupSymbol "TFL" "add_attr_float"
    addAttrString = lookupSymbol "TFL" "add_attr_string"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "method"
    valCStr = CString.fromText method
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    nameCStr = CString.fromText "extrapolation_value"
    addAttrFloat.call None [attrList.toCArg, nameCStr.toCArg, CFloat.fromReal extrapolationxvalue . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "CropAndResize" [image, boxes, boxxind, cropxsize] [FloatType] attrList chosenName
    TFOutput wrappers.head.get

def refEnterGen chosenName data t framexname isxconstant parallelxiterations:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrInt = lookupSymbol "TFL" "add_attr_int"
    addAttrString = lookupSymbol "TFL" "add_attr_string"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "frame_name"
    valCStr = CString.fromText framexname
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    nameCStr = CString.fromText "is_constant"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if isxconstant then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "parallel_iterations"
    addAttrInt.call None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt parallelxiterations . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "RefEnter" [data] [data.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def shardedFilespecGen chosenName basename numxshards:
    wrappers = makeOutputWrappers "ShardedFilespec" [basename, numxshards] [StringType] attrList chosenName
    TFOutput wrappers.head.get

def extractJpegShapeGen chosenName contents outputxtype:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "output_type"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt outputxtype.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "ExtractJpegShape" [contents] [outputxtype] attrList chosenName
    TFOutput wrappers.head.get

def batchMatrixInverseGen chosenName input adjoint t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "adjoint"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if adjoint then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "BatchMatrixInverse" [input] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def tensorArraySplitGen chosenName handle value lengths flowxin t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "TensorArraySplit" [handle, value, lengths, flowxin] [FloatType] attrList chosenName
    TFOutput wrappers.head.get

def switchGen chosenName data pred t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Switch" [data, pred] [data.wrapper.typetag, data.wrapper.typetag] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def shardedFilenameGen chosenName basename shard numxshards:
    wrappers = makeOutputWrappers "ShardedFilename" [basename, shard, numxshards] [StringType] attrList chosenName
    TFOutput wrappers.head.get

def denseToDenseSetOperationGen chosenName set1 set2 setxoperation validatexindices t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrString = lookupSymbol "TFL" "add_attr_string"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "set_operation"
    valCStr = CString.fromText setxoperation
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    nameCStr = CString.fromText "validate_indices"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if validatexindices then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "DenseToDenseSetOperation" [set1, set2] [Int64Type, set1.wrapper.typetag, Int64Type] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def fusedPadConv2DGen chosenName input paddings filter t mode strides padding:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrIntList = lookupSymbol "TFL" "add_attr_int_list"
    addAttrString = lookupSymbol "TFL" "add_attr_string"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "mode"
    valCStr = CString.fromText mode
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    nameCStr = CString.fromText "strides"
    cvalues = strides.map CInt64.fromInt
    cvaluesArray = (Array CInt64) . fromList cvalues
    addAttrIntList.call None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
    cvaluesArray.free
    nameCStr.free
    nameCStr = CString.fromText "padding"
    valCStr = CString.fromText padding
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    wrappers = makeOutputWrappers "FusedPadConv2D" [input, paddings, filter] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def conv2DBackpropInputGen chosenName inputxsizes filter outxbackprop t strides usexcudnnxonxgpu padding dataxformat dilations:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrIntList = lookupSymbol "TFL" "add_attr_int_list"
    addAttrString = lookupSymbol "TFL" "add_attr_string"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "strides"
    cvalues = strides.map CInt64.fromInt
    cvaluesArray = (Array CInt64) . fromList cvalues
    addAttrIntList.call None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
    cvaluesArray.free
    nameCStr.free
    nameCStr = CString.fromText "use_cudnn_on_gpu"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if usexcudnnxonxgpu then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "padding"
    valCStr = CString.fromText padding
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    nameCStr = CString.fromText "data_format"
    valCStr = CString.fromText dataxformat
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    nameCStr = CString.fromText "dilations"
    cvalues = dilations.map CInt64.fromInt
    cvaluesArray = (Array CInt64) . fromList cvalues
    addAttrIntList.call None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt dilations.length . toCArg]
    cvaluesArray.free
    nameCStr.free
    wrappers = makeOutputWrappers "Conv2DBackpropInput" [inputxsizes, filter, outxbackprop] [filter.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def equalGen chosenName x y t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Equal" [x, y] [BoolType] attrList chosenName
    TFOutput wrappers.head.get

def tensorArrayGatherV2Gen chosenName handle indices flowxin dtype elementxshape:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrShape = lookupSymbol "TFL" "add_attr_shape"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "dtype"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt dtype.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "element_shape"
    cdims = elementxshape.map CInt64.fromInt
    cdimsArray = (Array CInt64) . fromList cdims
    addAttrShape.call None [attrList.toCArg, nameCStr.toCArg, cdimsArray.toCArg, CUInt32.fromInt elementxshape.length . toCArg]
    cdimsArray.free
    nameCStr.free
    wrappers = makeOutputWrappers "TensorArrayGatherV2" [handle, indices, flowxin] [dtype] attrList chosenName
    TFOutput wrappers.head.get

def histogramSummaryGen chosenName tag values t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "HistogramSummary" [tag, values] [StringType] attrList chosenName
    TFOutput wrappers.head.get

def tPUEmbeddingActivationsGen chosenName embeddingxvariable slicedxactivations tablexid lookupxid:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrInt = lookupSymbol "TFL" "add_attr_int"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "table_id"
    addAttrInt.call None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt tablexid . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "lookup_id"
    addAttrInt.call None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt lookupxid . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "TPUEmbeddingActivations" [embeddingxvariable, slicedxactivations] [FloatType] attrList chosenName
    TFOutput wrappers.head.get

def refSwitchGen chosenName data pred t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "RefSwitch" [data, pred] [data.wrapper.typetag, data.wrapper.typetag] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def sparseTensorDenseMatMulGen chosenName axindices axvalues axshape b t tindices adjointxa adjointxb:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tindices"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "adjoint_a"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if adjointxa then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "adjoint_b"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if adjointxb then 1 else 0) . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "SparseTensorDenseMatMul" [axindices, axvalues, axshape, b] [axvalues.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def segmentProdGen chosenName data segmentxids t tindices:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tindices"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "SegmentProd" [data, segmentxids] [data.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def tensorArrayGatherGen chosenName handle indices flowxin dtype elementxshape:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrShape = lookupSymbol "TFL" "add_attr_shape"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "dtype"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt dtype.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "element_shape"
    cdims = elementxshape.map CInt64.fromInt
    cdimsArray = (Array CInt64) . fromList cdims
    addAttrShape.call None [attrList.toCArg, nameCStr.toCArg, cdimsArray.toCArg, CUInt32.fromInt elementxshape.length . toCArg]
    cdimsArray.free
    nameCStr.free
    wrappers = makeOutputWrappers "TensorArrayGather" [handle, indices, flowxin] [dtype] attrList chosenName
    TFOutput wrappers.head.get

def batchCholeskyGradGen chosenName l grad t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "BatchCholeskyGrad" [l, grad] [l.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def generateBigQueryReaderPartitionsGen chosenName projectxid datasetxid tablexid columns timestampxmillis numxpartitions testxendxpoint:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrInt = lookupSymbol "TFL" "add_attr_int"
    addAttrStringList = lookupSymbol "TFL" "add_attr_string_list"
    addAttrString = lookupSymbol "TFL" "add_attr_string"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "project_id"
    valCStr = CString.fromText projectxid
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    nameCStr = CString.fromText "dataset_id"
    valCStr = CString.fromText datasetxid
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    nameCStr = CString.fromText "table_id"
    valCStr = CString.fromText tablexid
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    nameCStr = CString.fromText "columns"
    len = columns.length
    cValues = ManagedPointer (Pointer CInt64) . mallocElems len
    indexed = 0.upto (len - 1) . zip columns
    indexed.each (idx, elem):
            cValues.moveElems idx . write (CString.fromText elem)
    addAttrStringList.call None [attrList.toCArg, nameCStr.toCArg, cValues.toCArg, CUInt32.fromInt len . toCArg]
    0.upto (len - 1) . each (idx: cValues.moveElems idx . read . free)
    nameCStr.free
    nameCStr = CString.fromText "timestamp_millis"
    addAttrInt.call None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt timestampxmillis . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "num_partitions"
    addAttrInt.call None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt numxpartitions . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "test_end_point"
    valCStr = CString.fromText testxendxpoint
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    wrappers = makeOutputWrappers "GenerateBigQueryReaderPartitions" [] [StringType] attrList chosenName
    TFOutput wrappers.head.get

def scatterNdAddGen chosenName ref indices updates t tindices usexlocking:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tindices"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "use_locking"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if usexlocking then 1 else 0) . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "ScatterNdAdd" [ref, indices, updates] [ref.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def assignGen chosenName ref value t validatexshape usexlocking:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "validate_shape"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if validatexshape then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "use_locking"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if usexlocking then 1 else 0) . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Assign" [ref, value] [ref.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def argMaxGen chosenName input dimension t tidx outputxtype:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tidx"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tidx.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "output_type"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt outputxtype.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "ArgMax" [input, dimension] [outputxtype] attrList chosenName
    TFOutput wrappers.head.get

def readerResetGen chosenName readerxhandle:
    wrappers = makeOutputWrappers "ReaderReset" [readerxhandle] [] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def xParallelConcatUpdateGen chosenName value update t loc:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrInt = lookupSymbol "TFL" "add_attr_int"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "loc"
    addAttrInt.call None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt loc . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "_ParallelConcatUpdate" [value, update] [value.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def digammaGen chosenName x t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Digamma" [x] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def lookupTableExportGen chosenName tablexhandle tkeys tvalues:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "Tkeys"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tkeys.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tvalues"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tvalues.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "LookupTableExport" [tablexhandle] [tkeys, tvalues] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def debugGradientRefIdentityGen chosenName input t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "DebugGradientRefIdentity" [input] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def erfGen chosenName x t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Erf" [x] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def floorGen chosenName x t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Floor" [x] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def resizeBilinearGen chosenName images size t alignxcorners:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "align_corners"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if alignxcorners then 1 else 0) . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "ResizeBilinear" [images, size] [FloatType] attrList chosenName
    TFOutput wrappers.head.get

def copyHostGen chosenName input t tensorxname debugxopsxspec:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrStringList = lookupSymbol "TFL" "add_attr_string_list"
    addAttrString = lookupSymbol "TFL" "add_attr_string"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "tensor_name"
    valCStr = CString.fromText tensorxname
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    nameCStr = CString.fromText "debug_ops_spec"
    len = debugxopsxspec.length
    cValues = ManagedPointer (Pointer CInt64) . mallocElems len
    indexed = 0.upto (len - 1) . zip debugxopsxspec
    indexed.each (idx, elem):
            cValues.moveElems idx . write (CString.fromText elem)
    addAttrStringList.call None [attrList.toCArg, nameCStr.toCArg, cValues.toCArg, CUInt32.fromInt len . toCArg]
    0.upto (len - 1) . each (idx: cValues.moveElems idx . read . free)
    nameCStr.free
    wrappers = makeOutputWrappers "CopyHost" [input] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def gcsConfigureBlockCacheGen chosenName maxxcachexsize blockxsize maxxstaleness:
    wrappers = makeOutputWrappers "GcsConfigureBlockCache" [maxxcachexsize, blockxsize, maxxstaleness] [] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def serializeManySparseGen chosenName sparsexindices sparsexvalues sparsexshape t outxtype:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "out_type"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt outxtype.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "SerializeManySparse" [sparsexindices, sparsexvalues, sparsexshape] [outxtype] attrList chosenName
    TFOutput wrappers.head.get

def acoshGen chosenName x t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Acosh" [x] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def isFiniteGen chosenName x t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "IsFinite" [x] [BoolType] attrList chosenName
    TFOutput wrappers.head.get

def batchMatrixSolveLsGen chosenName matrix rhs l2xregularizer t fast:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "fast"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if fast then 1 else 0) . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "BatchMatrixSolveLs" [matrix, rhs, l2xregularizer] [matrix.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def debugGradientIdentityGen chosenName input t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "DebugGradientIdentity" [input] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def isNanGen chosenName x t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "IsNan" [x] [BoolType] attrList chosenName
    TFOutput wrappers.head.get

def realDivGen chosenName x y t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "RealDiv" [x, y] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def lgammaGen chosenName x t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Lgamma" [x] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def scatterNdGen chosenName indices updates shape t tindices:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tindices"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "ScatterNd" [indices, updates, shape] [updates.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def allGen chosenName input reductionxindices keepxdims tidx:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "keep_dims"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if keepxdims then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tidx"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tidx.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "All" [input, reductionxindices] [BoolType] attrList chosenName
    TFOutput wrappers.head.get

def selfAdjointEigGen chosenName input t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "SelfAdjointEig" [input] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def conv3DBackpropInputGen chosenName input filter outxbackprop t strides padding dilations:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrIntList = lookupSymbol "TFL" "add_attr_int_list"
    addAttrString = lookupSymbol "TFL" "add_attr_string"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "strides"
    cvalues = strides.map CInt64.fromInt
    cvaluesArray = (Array CInt64) . fromList cvalues
    addAttrIntList.call None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
    cvaluesArray.free
    nameCStr.free
    nameCStr = CString.fromText "padding"
    valCStr = CString.fromText padding
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    nameCStr = CString.fromText "dilations"
    cvalues = dilations.map CInt64.fromInt
    cvaluesArray = (Array CInt64) . fromList cvalues
    addAttrIntList.call None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt dilations.length . toCArg]
    cvaluesArray.free
    nameCStr.free
    wrappers = makeOutputWrappers "Conv3DBackpropInput" [input, filter, outxbackprop] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def stackPushGen chosenName handle elem t swapxmemory:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "swap_memory"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if swapxmemory then 1 else 0) . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "StackPush" [handle, elem] [elem.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def maxPool3DGen chosenName input ksize strides padding dataxformat t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrIntList = lookupSymbol "TFL" "add_attr_int_list"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrString = lookupSymbol "TFL" "add_attr_string"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "ksize"
    cvalues = ksize.map CInt64.fromInt
    cvaluesArray = (Array CInt64) . fromList cvalues
    addAttrIntList.call None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt ksize.length . toCArg]
    cvaluesArray.free
    nameCStr.free
    nameCStr = CString.fromText "strides"
    cvalues = strides.map CInt64.fromInt
    cvaluesArray = (Array CInt64) . fromList cvalues
    addAttrIntList.call None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
    cvaluesArray.free
    nameCStr.free
    nameCStr = CString.fromText "padding"
    valCStr = CString.fromText padding
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    nameCStr = CString.fromText "data_format"
    valCStr = CString.fromText dataxformat
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "MaxPool3D" [input] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def applyGradientDescentGen chosenName var alpha delta t usexlocking:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "use_locking"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if usexlocking then 1 else 0) . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "ApplyGradientDescent" [var, alpha, delta] [var.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def resizeAreaGen chosenName images size t alignxcorners:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "align_corners"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if alignxcorners then 1 else 0) . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "ResizeArea" [images, size] [FloatType] attrList chosenName
    TFOutput wrappers.head.get

def stringToHashBucketGen chosenName stringxtensor numxbuckets:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrInt = lookupSymbol "TFL" "add_attr_int"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "num_buckets"
    addAttrInt.call None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt numxbuckets . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "StringToHashBucket" [stringxtensor] [Int64Type] attrList chosenName
    TFOutput wrappers.head.get

def applyAdagradDAGen chosenName var gradientxaccumulator gradientxsquaredxaccumulator grad lr l1 l2 globalxstep t usexlocking:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "use_locking"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if usexlocking then 1 else 0) . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "ApplyAdagradDA" [var, gradientxaccumulator, gradientxsquaredxaccumulator, grad, lr, l1, l2, globalxstep] [var.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def igammaGradAGen chosenName a x t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "IgammaGradA" [a, x] [a.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def sparseSegmentMeanGradGen chosenName grad indices segmentxids outputxdim0 t tidx:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tidx"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tidx.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "SparseSegmentMeanGrad" [grad, indices, segmentxids, outputxdim0] [grad.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def cudnnRNNParamsSizeGen chosenName numxlayers numxunits inputxsize t s rnnxmode inputxmode direction dropout seed seed2:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrInt = lookupSymbol "TFL" "add_attr_int"
    addAttrFloat = lookupSymbol "TFL" "add_attr_float"
    addAttrString = lookupSymbol "TFL" "add_attr_string"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "S"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt s.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "rnn_mode"
    valCStr = CString.fromText rnnxmode
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    nameCStr = CString.fromText "input_mode"
    valCStr = CString.fromText inputxmode
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    nameCStr = CString.fromText "direction"
    valCStr = CString.fromText direction
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    nameCStr = CString.fromText "dropout"
    addAttrFloat.call None [attrList.toCArg, nameCStr.toCArg, CFloat.fromReal dropout . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "seed"
    addAttrInt.call None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt seed . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "seed2"
    addAttrInt.call None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt seed2 . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "CudnnRNNParamsSize" [numxlayers, numxunits, inputxsize] [s] attrList chosenName
    TFOutput wrappers.head.get

def queueIsClosedGen chosenName handle:
    wrappers = makeOutputWrappers "QueueIsClosed" [handle] [BoolType] attrList chosenName
    TFOutput wrappers.head.get

def compareAndBitpackGen chosenName input threshold t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "CompareAndBitpack" [input, threshold] [UInt8Type] attrList chosenName
    TFOutput wrappers.head.get

def conv3DBackpropInputV2Gen chosenName inputxsizes filter outxbackprop t strides padding dataxformat dilations tshape:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrIntList = lookupSymbol "TFL" "add_attr_int_list"
    addAttrString = lookupSymbol "TFL" "add_attr_string"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "strides"
    cvalues = strides.map CInt64.fromInt
    cvaluesArray = (Array CInt64) . fromList cvalues
    addAttrIntList.call None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
    cvaluesArray.free
    nameCStr.free
    nameCStr = CString.fromText "padding"
    valCStr = CString.fromText padding
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    nameCStr = CString.fromText "data_format"
    valCStr = CString.fromText dataxformat
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    nameCStr = CString.fromText "dilations"
    cvalues = dilations.map CInt64.fromInt
    cvaluesArray = (Array CInt64) . fromList cvalues
    addAttrIntList.call None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt dilations.length . toCArg]
    cvaluesArray.free
    nameCStr.free
    nameCStr = CString.fromText "Tshape"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tshape.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Conv3DBackpropInputV2" [inputxsizes, filter, outxbackprop] [filter.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def depthToSpaceGen chosenName input t blockxsize dataxformat:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrInt = lookupSymbol "TFL" "add_attr_int"
    addAttrString = lookupSymbol "TFL" "add_attr_string"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "block_size"
    addAttrInt.call None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt blockxsize . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "data_format"
    valCStr = CString.fromText dataxformat
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    wrappers = makeOutputWrappers "DepthToSpace" [input] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def adjustHueGen chosenName images delta:
    wrappers = makeOutputWrappers "AdjustHue" [images, delta] [FloatType] attrList chosenName
    TFOutput wrappers.head.get

def tensorArrayWriteGen chosenName handle index value flowxin t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "TensorArrayWrite" [handle, index, value, flowxin] [FloatType] attrList chosenName
    TFOutput wrappers.head.get

def tensorArrayWriteV2Gen chosenName handle index value flowxin t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "TensorArrayWriteV2" [handle, index, value, flowxin] [FloatType] attrList chosenName
    TFOutput wrappers.head.get

def matrixTriangularSolveGen chosenName matrix rhs lower adjoint t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "lower"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if lower then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "adjoint"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if adjoint then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "MatrixTriangularSolve" [matrix, rhs] [matrix.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def barrierCloseGen chosenName handle cancelxpendingxenqueues:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "cancel_pending_enqueues"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if cancelxpendingxenqueues then 1 else 0) . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "BarrierClose" [handle] [] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def truncateDivGen chosenName x y t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "TruncateDiv" [x, y] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def scatterUpdateGen chosenName ref indices updates t tindices usexlocking:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tindices"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "use_locking"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if usexlocking then 1 else 0) . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "ScatterUpdate" [ref, indices, updates] [ref.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def cTCGreedyDecoderGen chosenName inputs sequencexlength mergexrepeated:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "merge_repeated"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if mergexrepeated then 1 else 0) . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "CTCGreedyDecoder" [inputs, sequencexlength] [Int64Type, Int64Type, Int64Type, FloatType] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def padV2Gen chosenName input paddings constantxvalues t tpaddings:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tpaddings"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tpaddings.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "PadV2" [input, paddings, constantxvalues] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def mfccGen chosenName spectrogram samplexrate upperxfrequencyxlimit lowerxfrequencyxlimit filterbankxchannelxcount dctxcoefficientxcount:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrInt = lookupSymbol "TFL" "add_attr_int"
    addAttrFloat = lookupSymbol "TFL" "add_attr_float"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "upper_frequency_limit"
    addAttrFloat.call None [attrList.toCArg, nameCStr.toCArg, CFloat.fromReal upperxfrequencyxlimit . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "lower_frequency_limit"
    addAttrFloat.call None [attrList.toCArg, nameCStr.toCArg, CFloat.fromReal lowerxfrequencyxlimit . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "filterbank_channel_count"
    addAttrInt.call None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt filterbankxchannelxcount . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "dct_coefficient_count"
    addAttrInt.call None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt dctxcoefficientxcount . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Mfcc" [spectrogram, samplexrate] [FloatType] attrList chosenName
    TFOutput wrappers.head.get

def decodeWavGen chosenName contents desiredxchannels desiredxsamples:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrInt = lookupSymbol "TFL" "add_attr_int"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "desired_channels"
    addAttrInt.call None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt desiredxchannels . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "desired_samples"
    addAttrInt.call None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt desiredxsamples . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "DecodeWav" [contents] [FloatType, Int32Type] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def uniqueGen chosenName x t outxidx:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "out_idx"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt outxidx.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Unique" [x] [x.wrapper.typetag, outxidx] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def spaceToBatchGen chosenName input paddings t tpaddings blockxsize:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrInt = lookupSymbol "TFL" "add_attr_int"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tpaddings"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tpaddings.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "block_size"
    addAttrInt.call None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt blockxsize . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "SpaceToBatch" [input, paddings] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def unbatchGen chosenName batchedxtensor batchxindex id timeoutxmicros container sharedxname t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrInt = lookupSymbol "TFL" "add_attr_int"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrString = lookupSymbol "TFL" "add_attr_string"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "timeout_micros"
    addAttrInt.call None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt timeoutxmicros . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "container"
    valCStr = CString.fromText container
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    nameCStr = CString.fromText "shared_name"
    valCStr = CString.fromText sharedxname
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Unbatch" [batchedxtensor, batchxindex, id] [batchedxtensor.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def countUpToGen chosenName ref limit t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrInt = lookupSymbol "TFL" "add_attr_int"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "limit"
    addAttrInt.call None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt limit . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "CountUpTo" [ref] [ref.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def rollGen chosenName input shift axis t tshift taxis:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tshift"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tshift.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Taxis"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt taxis.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Roll" [input, shift, axis] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def adjustContrastGen chosenName images contrastxfactor minxvalue maxxvalue t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "AdjustContrast" [images, contrastxfactor, minxvalue, maxxvalue] [FloatType] attrList chosenName
    TFOutput wrappers.head.get

def audioSpectrogramGen chosenName input windowxsize stride magnitudexsquared:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrInt = lookupSymbol "TFL" "add_attr_int"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "window_size"
    addAttrInt.call None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt windowxsize . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "stride"
    addAttrInt.call None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt stride . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "magnitude_squared"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if magnitudexsquared then 1 else 0) . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "AudioSpectrogram" [input] [FloatType] attrList chosenName
    TFOutput wrappers.head.get

def invGradGen chosenName y dy t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "InvGrad" [y, dy] [y.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def stridedSliceGen chosenName input begin end strides t index beginxmask endxmask ellipsisxmask newxaxisxmask shrinkxaxisxmask:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrInt = lookupSymbol "TFL" "add_attr_int"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Index"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt index.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "begin_mask"
    addAttrInt.call None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt beginxmask . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "end_mask"
    addAttrInt.call None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt endxmask . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "ellipsis_mask"
    addAttrInt.call None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt ellipsisxmask . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "new_axis_mask"
    addAttrInt.call None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt newxaxisxmask . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "shrink_axis_mask"
    addAttrInt.call None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt shrinkxaxisxmask . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "StridedSlice" [input, begin, end, strides] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def logicalNotGen chosenName x:
    wrappers = makeOutputWrappers "LogicalNot" [x] [BoolType] attrList chosenName
    TFOutput wrappers.head.get

def readerReadGen chosenName readerxhandle queuexhandle:
    wrappers = makeOutputWrappers "ReaderRead" [readerxhandle, queuexhandle] [StringType, StringType] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def readerRestoreStateGen chosenName readerxhandle state:
    wrappers = makeOutputWrappers "ReaderRestoreState" [readerxhandle, state] [] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def reduceJoinGen chosenName inputs reductionxindices keepxdims separator:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrString = lookupSymbol "TFL" "add_attr_string"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "keep_dims"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if keepxdims then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "separator"
    valCStr = CString.fromText separator
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    wrappers = makeOutputWrappers "ReduceJoin" [inputs, reductionxindices] [StringType] attrList chosenName
    TFOutput wrappers.head.get

def sparseAddGradGen chosenName backpropxvalxgrad axindices bxindices sumxindices t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "SparseAddGrad" [backpropxvalxgrad, axindices, bxindices, sumxindices] [backpropxvalxgrad.wrapper.typetag, backpropxvalxgrad.wrapper.typetag] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def maxPoolGradGradGen chosenName origxinput origxoutput grad ksize strides padding dataxformat t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrIntList = lookupSymbol "TFL" "add_attr_int_list"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrString = lookupSymbol "TFL" "add_attr_string"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "ksize"
    cvalues = ksize.map CInt64.fromInt
    cvaluesArray = (Array CInt64) . fromList cvalues
    addAttrIntList.call None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt ksize.length . toCArg]
    cvaluesArray.free
    nameCStr.free
    nameCStr = CString.fromText "strides"
    cvalues = strides.map CInt64.fromInt
    cvaluesArray = (Array CInt64) . fromList cvalues
    addAttrIntList.call None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
    cvaluesArray.free
    nameCStr.free
    nameCStr = CString.fromText "padding"
    valCStr = CString.fromText padding
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    nameCStr = CString.fromText "data_format"
    valCStr = CString.fromText dataxformat
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "MaxPoolGradGrad" [origxinput, origxoutput, grad] [origxinput.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def xMklSquaredDifferenceGen chosenName x y mklxx mklxy t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "_MklSquaredDifference" [x, y, mklxx, mklxy] [x.wrapper.typetag, UInt8Type] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def tensorArrayReadGen chosenName handle index flowxin dtype:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "dtype"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt dtype.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "TensorArrayRead" [handle, index, flowxin] [dtype] attrList chosenName
    TFOutput wrappers.head.get

def shapeGen chosenName input t outxtype:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "out_type"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt outxtype.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Shape" [input] [outxtype] attrList chosenName
    TFOutput wrappers.head.get

def powGen chosenName x y t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Pow" [x, y] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def sdcaFprintGen chosenName input:
    wrappers = makeOutputWrappers "SdcaFprint" [input] [Int64Type] attrList chosenName
    TFOutput wrappers.head.get

def readerReadUpToGen chosenName readerxhandle queuexhandle numxrecords:
    wrappers = makeOutputWrappers "ReaderReadUpTo" [readerxhandle, queuexhandle, numxrecords] [StringType, StringType] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def batchMatrixSolveGen chosenName matrix rhs adjoint t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "adjoint"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if adjoint then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "BatchMatrixSolve" [matrix, rhs] [matrix.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def serializeSparseGen chosenName sparsexindices sparsexvalues sparsexshape t outxtype:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "out_type"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt outxtype.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "SerializeSparse" [sparsexindices, sparsexvalues, sparsexshape] [outxtype] attrList chosenName
    TFOutput wrappers.head.get

def drawBoundingBoxesGen chosenName images boxes t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "DrawBoundingBoxes" [images, boxes] [images.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def spaceToDepthGen chosenName input t blockxsize dataxformat:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrInt = lookupSymbol "TFL" "add_attr_int"
    addAttrString = lookupSymbol "TFL" "add_attr_string"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "block_size"
    addAttrInt.call None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt blockxsize . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "data_format"
    valCStr = CString.fromText dataxformat
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    wrappers = makeOutputWrappers "SpaceToDepth" [input] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def generateVocabRemappingGen chosenName newxvocabxfile oldxvocabxfile newxvocabxoffset numxnewxvocab oldxvocabxsize:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrInt = lookupSymbol "TFL" "add_attr_int"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "new_vocab_offset"
    addAttrInt.call None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt newxvocabxoffset . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "num_new_vocab"
    addAttrInt.call None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt numxnewxvocab . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "old_vocab_size"
    addAttrInt.call None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt oldxvocabxsize . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "GenerateVocabRemapping" [newxvocabxfile, oldxvocabxfile] [Int64Type, Int32Type] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def abortGen chosenName errorxmsg exitxwithoutxerror:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrString = lookupSymbol "TFL" "add_attr_string"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "error_msg"
    valCStr = CString.fromText errorxmsg
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    nameCStr = CString.fromText "exit_without_error"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if exitxwithoutxerror then 1 else 0) . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Abort" [] [] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def modGen chosenName x y t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Mod" [x, y] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def assignAddGen chosenName ref value t usexlocking:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "use_locking"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if usexlocking then 1 else 0) . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "AssignAdd" [ref, value] [ref.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def avgPool3DGradGen chosenName origxinputxshape grad ksize strides padding dataxformat t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrIntList = lookupSymbol "TFL" "add_attr_int_list"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrString = lookupSymbol "TFL" "add_attr_string"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "ksize"
    cvalues = ksize.map CInt64.fromInt
    cvaluesArray = (Array CInt64) . fromList cvalues
    addAttrIntList.call None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt ksize.length . toCArg]
    cvaluesArray.free
    nameCStr.free
    nameCStr = CString.fromText "strides"
    cvalues = strides.map CInt64.fromInt
    cvaluesArray = (Array CInt64) . fromList cvalues
    addAttrIntList.call None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
    cvaluesArray.free
    nameCStr.free
    nameCStr = CString.fromText "padding"
    valCStr = CString.fromText padding
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    nameCStr = CString.fromText "data_format"
    valCStr = CString.fromText dataxformat
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "AvgPool3DGrad" [origxinputxshape, grad] [grad.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def unbatchGradGen chosenName originalxinput batchxindex grad id container sharedxname t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrString = lookupSymbol "TFL" "add_attr_string"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "container"
    valCStr = CString.fromText container
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    nameCStr = CString.fromText "shared_name"
    valCStr = CString.fromText sharedxname
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "UnbatchGrad" [originalxinput, batchxindex, grad, id] [originalxinput.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def debugNanCountGen chosenName input t devicexname tensorxname debugxurls gatedxgrpc:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrStringList = lookupSymbol "TFL" "add_attr_string_list"
    addAttrString = lookupSymbol "TFL" "add_attr_string"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "device_name"
    valCStr = CString.fromText devicexname
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    nameCStr = CString.fromText "tensor_name"
    valCStr = CString.fromText tensorxname
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    nameCStr = CString.fromText "debug_urls"
    len = debugxurls.length
    cValues = ManagedPointer (Pointer CInt64) . mallocElems len
    indexed = 0.upto (len - 1) . zip debugxurls
    indexed.each (idx, elem):
            cValues.moveElems idx . write (CString.fromText elem)
    addAttrStringList.call None [attrList.toCArg, nameCStr.toCArg, cValues.toCArg, CUInt32.fromInt len . toCArg]
    0.upto (len - 1) . each (idx: cValues.moveElems idx . read . free)
    nameCStr.free
    nameCStr = CString.fromText "gated_grpc"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if gatedxgrpc then 1 else 0) . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "DebugNanCount" [input] [Int64Type] attrList chosenName
    TFOutput wrappers.head.get

def applyRMSPropGen chosenName var ms mom lr rho momentum epsilon grad t usexlocking:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "use_locking"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if usexlocking then 1 else 0) . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "ApplyRMSProp" [var, ms, mom, lr, rho, momentum, epsilon, grad] [var.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def fakeQuantWithMinMaxVarsGen chosenName inputs min max numxbits narrowxrange:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrInt = lookupSymbol "TFL" "add_attr_int"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "num_bits"
    addAttrInt.call None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt numxbits . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "narrow_range"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if narrowxrange then 1 else 0) . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "FakeQuantWithMinMaxVars" [inputs, min, max] [FloatType] attrList chosenName
    TFOutput wrappers.head.get

def cropAndResizeGradImageGen chosenName grads boxes boxxind imagexsize t method:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrString = lookupSymbol "TFL" "add_attr_string"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "method"
    valCStr = CString.fromText method
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    wrappers = makeOutputWrappers "CropAndResizeGradImage" [grads, boxes, boxxind, imagexsize] [t] attrList chosenName
    TFOutput wrappers.head.get

def queueCloseGen chosenName handle cancelxpendingxenqueues:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "cancel_pending_enqueues"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if cancelxpendingxenqueues then 1 else 0) . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "QueueClose" [handle] [] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def scatterMinGen chosenName ref indices updates t tindices usexlocking:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tindices"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "use_locking"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if usexlocking then 1 else 0) . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "ScatterMin" [ref, indices, updates] [ref.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def readFileGen chosenName filename:
    wrappers = makeOutputWrappers "ReadFile" [filename] [StringType] attrList chosenName
    TFOutput wrappers.head.get

def stringToHashBucketFastGen chosenName input numxbuckets:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrInt = lookupSymbol "TFL" "add_attr_int"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "num_buckets"
    addAttrInt.call None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt numxbuckets . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "StringToHashBucketFast" [input] [Int64Type] attrList chosenName
    TFOutput wrappers.head.get

def accumulatorSetGlobalStepGen chosenName handle newxglobalxstep:
    wrappers = makeOutputWrappers "AccumulatorSetGlobalStep" [handle, newxglobalxstep] [] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def matrixDiagPartGen chosenName input t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "MatrixDiagPart" [input] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def placeholderGen chosenName dtype shape:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrShape = lookupSymbol "TFL" "add_attr_shape"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "dtype"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt dtype.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "shape"
    cdims = shape.map CInt64.fromInt
    cdimsArray = (Array CInt64) . fromList cdims
    addAttrShape.call None [attrList.toCArg, nameCStr.toCArg, cdimsArray.toCArg, CUInt32.fromInt shape.length . toCArg]
    cdimsArray.free
    nameCStr.free
    wrappers = makeOutputWrappers "Placeholder" [] [dtype] attrList chosenName
    TFOutput wrappers.head.get

def absGen chosenName x t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Abs" [x] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def accumulatorApplyGradientGen chosenName handle localxstep gradient dtype:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "dtype"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt dtype.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "AccumulatorApplyGradient" [handle, localxstep, gradient] [] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def sparseAccumulatorApplyGradientGen chosenName handle localxstep gradientxindices gradientxvalues gradientxshape dtype hasxknownxshape:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "dtype"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt dtype.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "has_known_shape"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if hasxknownxshape then 1 else 0) . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "SparseAccumulatorApplyGradient" [handle, localxstep, gradientxindices, gradientxvalues, gradientxshape] [] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def atanhGen chosenName x t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Atanh" [x] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def conv2DGen chosenName input filter t strides usexcudnnxonxgpu padding dataxformat dilations:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrIntList = lookupSymbol "TFL" "add_attr_int_list"
    addAttrString = lookupSymbol "TFL" "add_attr_string"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "strides"
    cvalues = strides.map CInt64.fromInt
    cvaluesArray = (Array CInt64) . fromList cvalues
    addAttrIntList.call None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
    cvaluesArray.free
    nameCStr.free
    nameCStr = CString.fromText "use_cudnn_on_gpu"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if usexcudnnxonxgpu then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "padding"
    valCStr = CString.fromText padding
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    nameCStr = CString.fromText "data_format"
    valCStr = CString.fromText dataxformat
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    nameCStr = CString.fromText "dilations"
    cvalues = dilations.map CInt64.fromInt
    cvaluesArray = (Array CInt64) . fromList cvalues
    addAttrIntList.call None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt dilations.length . toCArg]
    cvaluesArray.free
    nameCStr.free
    wrappers = makeOutputWrappers "Conv2D" [input, filter] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def tensorArrayCloseGen chosenName handle:
    wrappers = makeOutputWrappers "TensorArrayClose" [handle] [] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def scatterSubGen chosenName ref indices updates t tindices usexlocking:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tindices"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "use_locking"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if usexlocking then 1 else 0) . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "ScatterSub" [ref, indices, updates] [ref.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def applyFtrlGen chosenName var accum linear grad lr l1 l2 lrxpower t usexlocking:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "use_locking"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if usexlocking then 1 else 0) . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "ApplyFtrl" [var, accum, linear, grad, lr, l1, l2, lrxpower] [var.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def serializeTensorGen chosenName tensor t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "SerializeTensor" [tensor] [StringType] attrList chosenName
    TFOutput wrappers.head.get

def xHostCastGen chosenName x srcT dstT truncate:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "SrcT"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt srcT.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "DstT"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt dstT.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Truncate"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if truncate then 1 else 0) . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "_HostCast" [x] [dstT] attrList chosenName
    TFOutput wrappers.head.get

def fusedBatchNormGradV2Gen chosenName yxbackprop x scale reservexspacex1 reservexspacex2 t u epsilon dataxformat isxtraining:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrFloat = lookupSymbol "TFL" "add_attr_float"
    addAttrString = lookupSymbol "TFL" "add_attr_string"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "U"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt u.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "epsilon"
    addAttrFloat.call None [attrList.toCArg, nameCStr.toCArg, CFloat.fromReal epsilon . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "data_format"
    valCStr = CString.fromText dataxformat
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    nameCStr = CString.fromText "is_training"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if isxtraining then 1 else 0) . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "FusedBatchNormGradV2" [yxbackprop, x, scale, reservexspacex1, reservexspacex2] [yxbackprop.wrapper.typetag, reservexspacex1.wrapper.typetag, reservexspacex1.wrapper.typetag, reservexspacex1.wrapper.typetag, reservexspacex1.wrapper.typetag] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def batchNormWithGlobalNormalizationGen chosenName t m v beta gamma t variancexepsilon scalexafterxnormalization:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrFloat = lookupSymbol "TFL" "add_attr_float"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "variance_epsilon"
    addAttrFloat.call None [attrList.toCArg, nameCStr.toCArg, CFloat.fromReal variancexepsilon . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "scale_after_normalization"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if scalexafterxnormalization then 1 else 0) . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "BatchNormWithGlobalNormalization" [t, m, v, beta, gamma] [t.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def controlTriggerGen chosenName:
    wrappers = makeOutputWrappers "ControlTrigger" [] [] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def tensorArrayReadV2Gen chosenName handle index flowxin dtype:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "dtype"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt dtype.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "TensorArrayReadV2" [handle, index, flowxin] [dtype] attrList chosenName
    TFOutput wrappers.head.get

def placeholderWithDefaultGen chosenName input dtype shape:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrShape = lookupSymbol "TFL" "add_attr_shape"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "dtype"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt dtype.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "shape"
    cdims = shape.map CInt64.fromInt
    cdimsArray = (Array CInt64) . fromList cdims
    addAttrShape.call None [attrList.toCArg, nameCStr.toCArg, cdimsArray.toCArg, CUInt32.fromInt shape.length . toCArg]
    cdimsArray.free
    nameCStr.free
    wrappers = makeOutputWrappers "PlaceholderWithDefault" [input] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def decodeBase64Gen chosenName input:
    wrappers = makeOutputWrappers "DecodeBase64" [input] [StringType] attrList chosenName
    TFOutput wrappers.head.get

def seluGradGen chosenName gradients outputs t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "SeluGrad" [gradients, outputs] [gradients.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def sqrtGradGen chosenName y dy t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "SqrtGrad" [y, dy] [y.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def refExitGen chosenName data t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "RefExit" [data] [data.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def snapshotGen chosenName input t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Snapshot" [input] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def sparseApplyAdagradDAGen chosenName var gradientxaccumulator gradientxsquaredxaccumulator grad indices lr l1 l2 globalxstep t tindices usexlocking:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tindices"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "use_locking"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if usexlocking then 1 else 0) . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "SparseApplyAdagradDA" [var, gradientxaccumulator, gradientxsquaredxaccumulator, grad, indices, lr, l1, l2, globalxstep] [var.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def divNoNanGen chosenName x y t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "DivNoNan" [x, y] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def tensorArrayScatterGen chosenName handle indices value flowxin t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "TensorArrayScatter" [handle, indices, value, flowxin] [FloatType] attrList chosenName
    TFOutput wrappers.head.get

def sparseReduceMaxGen chosenName inputxindices inputxvalues inputxshape reductionxaxes keepxdims t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "keep_dims"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if keepxdims then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "SparseReduceMax" [inputxindices, inputxvalues, inputxshape, reductionxaxes] [inputxvalues.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def fractionalMaxPoolGen chosenName value poolingxratio pseudoxrandom overlapping deterministic seed seed2 t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrInt = lookupSymbol "TFL" "add_attr_int"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrFloatList = lookupSymbol "TFL" "add_attr_float_list"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "pooling_ratio"
    cvalues = poolingxratio.map CFloat.fromReal
    cvaluesArray = (Array CFloat) . fromList cvalues
    addAttrFloatList.call None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt poolingxratio.length . toCArg]
    cvaluesArray.free
    nameCStr.free
    nameCStr = CString.fromText "pseudo_random"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if pseudoxrandom then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "overlapping"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if overlapping then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "deterministic"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if deterministic then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "seed"
    addAttrInt.call None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt seed . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "seed2"
    addAttrInt.call None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt seed2 . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "FractionalMaxPool" [value] [value.wrapper.typetag, Int64Type, Int64Type] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def scatterNdNonAliasingAddGen chosenName input indices updates t tindices:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tindices"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "ScatterNdNonAliasingAdd" [input, indices, updates] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def tensorArraySizeGen chosenName handle flowxin:
    wrappers = makeOutputWrappers "TensorArraySize" [handle, flowxin] [Int32Type] attrList chosenName
    TFOutput wrappers.head.get

def resizeNearestNeighborGradGen chosenName grads size t alignxcorners:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "align_corners"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if alignxcorners then 1 else 0) . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "ResizeNearestNeighborGrad" [grads, size] [grads.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def tensorArraySizeV2Gen chosenName handle flowxin:
    wrappers = makeOutputWrappers "TensorArraySizeV2" [handle, flowxin] [Int32Type] attrList chosenName
    TFOutput wrappers.head.get

def barrierReadySizeGen chosenName handle:
    wrappers = makeOutputWrappers "BarrierReadySize" [handle] [Int32Type] attrList chosenName
    TFOutput wrappers.head.get

def fakeQuantWithMinMaxArgsGen chosenName inputs min max numxbits narrowxrange:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrInt = lookupSymbol "TFL" "add_attr_int"
    addAttrFloat = lookupSymbol "TFL" "add_attr_float"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "min"
    addAttrFloat.call None [attrList.toCArg, nameCStr.toCArg, CFloat.fromReal min . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "max"
    addAttrFloat.call None [attrList.toCArg, nameCStr.toCArg, CFloat.fromReal max . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "num_bits"
    addAttrInt.call None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt numxbits . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "narrow_range"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if narrowxrange then 1 else 0) . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "FakeQuantWithMinMaxArgs" [inputs] [FloatType] attrList chosenName
    TFOutput wrappers.head.get

def maxPoolV2Gen chosenName input ksize strides t padding dataxformat:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrString = lookupSymbol "TFL" "add_attr_string"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "padding"
    valCStr = CString.fromText padding
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    nameCStr = CString.fromText "data_format"
    valCStr = CString.fromText dataxformat
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    wrappers = makeOutputWrappers "MaxPoolV2" [input, ksize, strides] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def decodeJSONExampleGen chosenName jsonxexamples:
    wrappers = makeOutputWrappers "DecodeJSONExample" [jsonxexamples] [StringType] attrList chosenName
    TFOutput wrappers.head.get

def sparseAddGen chosenName axindices axvalues axshape bxindices bxvalues bxshape thresh t treal:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Treal"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt treal.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "SparseAdd" [axindices, axvalues, axshape, bxindices, bxvalues, bxshape, thresh] [Int64Type, axvalues.wrapper.typetag, Int64Type] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def initializeTableGen chosenName tablexhandle keys values tkey tval:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "Tkey"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tkey.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tval"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tval.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "InitializeTable" [tablexhandle, keys, values] [] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def tensorSummaryGen chosenName tensor t description labels displayxname:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrStringList = lookupSymbol "TFL" "add_attr_string_list"
    addAttrString = lookupSymbol "TFL" "add_attr_string"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "description"
    valCStr = CString.fromText description
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    nameCStr = CString.fromText "labels"
    len = labels.length
    cValues = ManagedPointer (Pointer CInt64) . mallocElems len
    indexed = 0.upto (len - 1) . zip labels
    indexed.each (idx, elem):
            cValues.moveElems idx . write (CString.fromText elem)
    addAttrStringList.call None [attrList.toCArg, nameCStr.toCArg, cValues.toCArg, CUInt32.fromInt len . toCArg]
    0.upto (len - 1) . each (idx: cValues.moveElems idx . read . free)
    nameCStr.free
    nameCStr = CString.fromText "display_name"
    valCStr = CString.fromText displayxname
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    wrappers = makeOutputWrappers "TensorSummary" [tensor] [StringType] attrList chosenName
    TFOutput wrappers.head.get

def imageSummaryGen chosenName tag tensor maxximages t badxcolor:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrInt = lookupSymbol "TFL" "add_attr_int"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrTensor = lookupSymbol "TFL" "add_attr_tensor"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "max_images"
    addAttrInt.call None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt maxximages . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "bad_color"
    addAttrTensor.call None [attrList.toCArg, nameCStr.toCArg, badxcolor.ptr.toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "ImageSummary" [tag, tensor] [StringType] attrList chosenName
    TFOutput wrappers.head.get

def avgPoolGen chosenName value ksize strides padding dataxformat t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrIntList = lookupSymbol "TFL" "add_attr_int_list"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrString = lookupSymbol "TFL" "add_attr_string"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "ksize"
    cvalues = ksize.map CInt64.fromInt
    cvaluesArray = (Array CInt64) . fromList cvalues
    addAttrIntList.call None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt ksize.length . toCArg]
    cvaluesArray.free
    nameCStr.free
    nameCStr = CString.fromText "strides"
    cvalues = strides.map CInt64.fromInt
    cvaluesArray = (Array CInt64) . fromList cvalues
    addAttrIntList.call None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
    cvaluesArray.free
    nameCStr.free
    nameCStr = CString.fromText "padding"
    valCStr = CString.fromText padding
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    nameCStr = CString.fromText "data_format"
    valCStr = CString.fromText dataxformat
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "AvgPool" [value] [value.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def fillGen chosenName dims value t indexxtype:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "index_type"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt indexxtype.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Fill" [dims, value] [value.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def asinhGen chosenName x t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Asinh" [x] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def tanhGradGen chosenName y dy t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "TanhGrad" [y, dy] [y.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def scalarSummaryGen chosenName tags values t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "ScalarSummary" [tags, values] [StringType] attrList chosenName
    TFOutput wrappers.head.get

def uniqueWithCountsGen chosenName x t outxidx:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "out_idx"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt outxidx.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "UniqueWithCounts" [x] [x.wrapper.typetag, outxidx, outxidx] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def decodeRawGen chosenName bytes outxtype littlexendian:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "out_type"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt outxtype.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "little_endian"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if littlexendian then 1 else 0) . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "DecodeRaw" [bytes] [outxtype] attrList chosenName
    TFOutput wrappers.head.get

def eluGradGen chosenName gradients outputs t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "EluGrad" [gradients, outputs] [gradients.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def staticRegexReplaceGen chosenName input pattern rewrite replacexglobal:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrString = lookupSymbol "TFL" "add_attr_string"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "pattern"
    valCStr = CString.fromText pattern
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    nameCStr = CString.fromText "rewrite"
    valCStr = CString.fromText rewrite
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    nameCStr = CString.fromText "replace_global"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if replacexglobal then 1 else 0) . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "StaticRegexReplace" [input] [StringType] attrList chosenName
    TFOutput wrappers.head.get

def matrixBandPartGen chosenName input numxlower numxupper t tindex:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tindex"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindex.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "MatrixBandPart" [input, numxlower, numxupper] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def decodeCompressedGen chosenName bytes compressionxtype:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrString = lookupSymbol "TFL" "add_attr_string"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "compression_type"
    valCStr = CString.fromText compressionxtype
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    wrappers = makeOutputWrappers "DecodeCompressed" [bytes] [StringType] attrList chosenName
    TFOutput wrappers.head.get

def maxPoolWithArgmaxGen chosenName input ksize strides targmax padding t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrIntList = lookupSymbol "TFL" "add_attr_int_list"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrString = lookupSymbol "TFL" "add_attr_string"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "ksize"
    cvalues = ksize.map CInt64.fromInt
    cvaluesArray = (Array CInt64) . fromList cvalues
    addAttrIntList.call None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt ksize.length . toCArg]
    cvaluesArray.free
    nameCStr.free
    nameCStr = CString.fromText "strides"
    cvalues = strides.map CInt64.fromInt
    cvaluesArray = (Array CInt64) . fromList cvalues
    addAttrIntList.call None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
    cvaluesArray.free
    nameCStr.free
    nameCStr = CString.fromText "Targmax"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt targmax.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "padding"
    valCStr = CString.fromText padding
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "MaxPoolWithArgmax" [input] [input.wrapper.typetag, targmax] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def parseTensorGen chosenName serialized outxtype:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "out_type"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt outxtype.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "ParseTensor" [serialized] [outxtype] attrList chosenName
    TFOutput wrappers.head.get

def rankGen chosenName input t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Rank" [input] [Int32Type] attrList chosenName
    TFOutput wrappers.head.get

def barrierInsertManyGen chosenName handle keys values t componentxindex:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrInt = lookupSymbol "TFL" "add_attr_int"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "component_index"
    addAttrInt.call None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt componentxindex . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "BarrierInsertMany" [handle, keys, values] [] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def sparseApplyAdagradGen chosenName var accum lr grad indices t tindices usexlocking updatexslots:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tindices"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "use_locking"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if usexlocking then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "update_slots"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if updatexslots then 1 else 0) . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "SparseApplyAdagrad" [var, accum, lr, grad, indices] [var.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def linSpaceGen chosenName start stop num t tidx:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tidx"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tidx.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "LinSpace" [start, stop, num] [start.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def applyAdamGen chosenName var m v beta1xpower beta2xpower lr beta1 beta2 epsilon grad t usexlocking usexnesterov:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "use_locking"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if usexlocking then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "use_nesterov"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if usexnesterov then 1 else 0) . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "ApplyAdam" [var, m, v, beta1xpower, beta2xpower, lr, beta1, beta2, epsilon, grad] [var.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def padGen chosenName input paddings t tpaddings:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tpaddings"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tpaddings.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Pad" [input, paddings] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def writeFileGen chosenName filename contents:
    wrappers = makeOutputWrappers "WriteFile" [filename, contents] [] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def xMklMaximumGen chosenName x y mklxx mklxy t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "_MklMaximum" [x, y, mklxx, mklxy] [x.wrapper.typetag, UInt8Type] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def applyAdadeltaGen chosenName var accum accumxupdate lr rho epsilon grad t usexlocking:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "use_locking"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if usexlocking then 1 else 0) . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "ApplyAdadelta" [var, accum, accumxupdate, lr, rho, epsilon, grad] [var.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def batchMatrixDiagGen chosenName diagonal t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "BatchMatrixDiag" [diagonal] [diagonal.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def fakeQuantWithMinMaxArgsGradientGen chosenName gradients inputs min max numxbits narrowxrange:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrInt = lookupSymbol "TFL" "add_attr_int"
    addAttrFloat = lookupSymbol "TFL" "add_attr_float"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "min"
    addAttrFloat.call None [attrList.toCArg, nameCStr.toCArg, CFloat.fromReal min . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "max"
    addAttrFloat.call None [attrList.toCArg, nameCStr.toCArg, CFloat.fromReal max . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "num_bits"
    addAttrInt.call None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt numxbits . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "narrow_range"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if narrowxrange then 1 else 0) . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "FakeQuantWithMinMaxArgsGradient" [gradients, inputs] [FloatType] attrList chosenName
    TFOutput wrappers.head.get

def applyPowerSignGen chosenName var m lr logbase signxdecay beta grad t usexlocking:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "use_locking"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if usexlocking then 1 else 0) . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "ApplyPowerSign" [var, m, lr, logbase, signxdecay, beta, grad] [var.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def batchMatMulGen chosenName x y t adjxx adjxy:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "adj_x"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if adjxx then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "adj_y"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if adjxy then 1 else 0) . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "BatchMatMul" [x, y] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def sparseSliceGen chosenName indices values shape start size t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "SparseSlice" [indices, values, shape, start, size] [Int64Type, values.wrapper.typetag, Int64Type] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def l2LossGen chosenName t t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "L2Loss" [t] [t.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def denseToSparseSetOperationGen chosenName set1 set2xindices set2xvalues set2xshape setxoperation validatexindices t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrString = lookupSymbol "TFL" "add_attr_string"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "set_operation"
    valCStr = CString.fromText setxoperation
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    nameCStr = CString.fromText "validate_indices"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if validatexindices then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "DenseToSparseSetOperation" [set1, set2xindices, set2xvalues, set2xshape] [Int64Type, set1.wrapper.typetag, Int64Type] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def sparseToSparseSetOperationGen chosenName set1xindices set1xvalues set1xshape set2xindices set2xvalues set2xshape setxoperation validatexindices t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrString = lookupSymbol "TFL" "add_attr_string"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "set_operation"
    valCStr = CString.fromText setxoperation
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    nameCStr = CString.fromText "validate_indices"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if validatexindices then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "SparseToSparseSetOperation" [set1xindices, set1xvalues, set1xshape, set2xindices, set2xvalues, set2xshape] [Int64Type, set1xvalues.wrapper.typetag, Int64Type] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def deserializeSparseGen chosenName serializedxsparse dtype tserialized:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "dtype"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt dtype.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tserialized"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tserialized.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "DeserializeSparse" [serializedxsparse] [Int64Type, dtype, Int64Type] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def deserializeManySparseGen chosenName serializedxsparse dtype:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "dtype"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt dtype.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "DeserializeManySparse" [serializedxsparse] [Int64Type, dtype, Int64Type] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def immutableConstGen chosenName dtype shape memoryxregionxname:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrShape = lookupSymbol "TFL" "add_attr_shape"
    addAttrString = lookupSymbol "TFL" "add_attr_string"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "dtype"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt dtype.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "shape"
    cdims = shape.map CInt64.fromInt
    cdimsArray = (Array CInt64) . fromList cdims
    addAttrShape.call None [attrList.toCArg, nameCStr.toCArg, cdimsArray.toCArg, CUInt32.fromInt shape.length . toCArg]
    cdimsArray.free
    nameCStr.free
    nameCStr = CString.fromText "memory_region_name"
    valCStr = CString.fromText memoryxregionxname
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    wrappers = makeOutputWrappers "ImmutableConst" [] [dtype] attrList chosenName
    TFOutput wrappers.head.get

def sparseToDenseGen chosenName sparsexindices outputxshape sparsexvalues defaultxvalue validatexindices t tindices:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "validate_indices"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if validatexindices then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tindices"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "SparseToDense" [sparsexindices, outputxshape, sparsexvalues, defaultxvalue] [sparsexvalues.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def batchToSpaceGen chosenName input crops t blockxsize tidx:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrInt = lookupSymbol "TFL" "add_attr_int"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "block_size"
    addAttrInt.call None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt blockxsize . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tidx"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tidx.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "BatchToSpace" [input, crops] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def listDiffGen chosenName x y t outxidx:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "out_idx"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt outxidx.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "ListDiff" [x, y] [x.wrapper.typetag, outxidx] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def sparseReorderGen chosenName inputxindices inputxvalues inputxshape t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "SparseReorder" [inputxindices, inputxvalues, inputxshape] [Int64Type, inputxvalues.wrapper.typetag] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def tensorArraySplitV2Gen chosenName handle value lengths flowxin t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "TensorArraySplitV2" [handle, value, lengths, flowxin] [FloatType] attrList chosenName
    TFOutput wrappers.head.get

def sparseReshapeGen chosenName inputxindices inputxshape newxshape:
    wrappers = makeOutputWrappers "SparseReshape" [inputxindices, inputxshape, newxshape] [Int64Type, Int64Type] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def sparseTensorDenseAddGen chosenName axindices axvalues axshape b t tindices:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tindices"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "SparseTensorDenseAdd" [axindices, axvalues, axshape, b] [axvalues.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def sparseReduceSumGen chosenName inputxindices inputxvalues inputxshape reductionxaxes keepxdims t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "keep_dims"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if keepxdims then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "SparseReduceSum" [inputxindices, inputxvalues, inputxshape, reductionxaxes] [inputxvalues.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def sparseReduceSumSparseGen chosenName inputxindices inputxvalues inputxshape reductionxaxes keepxdims t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "keep_dims"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if keepxdims then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "SparseReduceSumSparse" [inputxindices, inputxvalues, inputxshape, reductionxaxes] [Int64Type, inputxvalues.wrapper.typetag, Int64Type] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def mulGen chosenName x y t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Mul" [x, y] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def sparseDenseCwiseMulGen chosenName spxindices spxvalues spxshape dense t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "SparseDenseCwiseMul" [spxindices, spxvalues, spxshape, dense] [spxvalues.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def sparseSoftmaxGen chosenName spxindices spxvalues spxshape t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "SparseSoftmax" [spxindices, spxvalues, spxshape] [spxvalues.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def sparseSparseMinimumGen chosenName axindices axvalues axshape bxindices bxvalues bxshape t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "SparseSparseMinimum" [axindices, axvalues, axshape, bxindices, bxvalues, bxshape] [Int64Type, axvalues.wrapper.typetag] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def tileGen chosenName input multiples t tmultiples:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tmultiples"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tmultiples.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Tile" [input, multiples] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def dilation2DBackpropFilterGen chosenName input filter outxbackprop t strides rates padding:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrIntList = lookupSymbol "TFL" "add_attr_int_list"
    addAttrString = lookupSymbol "TFL" "add_attr_string"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "strides"
    cvalues = strides.map CInt64.fromInt
    cvaluesArray = (Array CInt64) . fromList cvalues
    addAttrIntList.call None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
    cvaluesArray.free
    nameCStr.free
    nameCStr = CString.fromText "rates"
    cvalues = rates.map CInt64.fromInt
    cvaluesArray = (Array CInt64) . fromList cvalues
    addAttrIntList.call None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt rates.length . toCArg]
    cvaluesArray.free
    nameCStr.free
    nameCStr = CString.fromText "padding"
    valCStr = CString.fromText padding
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    wrappers = makeOutputWrappers "Dilation2DBackpropFilter" [input, filter, outxbackprop] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def lookupTableImportGen chosenName tablexhandle keys values tin tout:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "Tin"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tin.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tout"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tout.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "LookupTableImport" [tablexhandle, keys, values] [] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def constGen chosenName value dtype:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrTensor = lookupSymbol "TFL" "add_attr_tensor"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "value"
    addAttrTensor.call None [attrList.toCArg, nameCStr.toCArg, value.ptr.toCArg]
    nameCStr.free
    nameCStr = CString.fromText "dtype"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt dtype.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Const" [] [dtype] attrList chosenName
    TFOutput wrappers.head.get

def sparseFillEmptyRowsGen chosenName indices values densexshape defaultxvalue t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "SparseFillEmptyRows" [indices, values, densexshape, defaultxvalue] [Int64Type, values.wrapper.typetag, BoolType, Int64Type] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def reverseGen chosenName tensor dims t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Reverse" [tensor, dims] [tensor.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def logSoftmaxGen chosenName logits t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "LogSoftmax" [logits] [logits.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def invertPermutationGen chosenName x t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "InvertPermutation" [x] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def mirrorPadGradGen chosenName input paddings t tpaddings mode:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrString = lookupSymbol "TFL" "add_attr_string"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tpaddings"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tpaddings.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "mode"
    valCStr = CString.fromText mode
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    wrappers = makeOutputWrappers "MirrorPadGrad" [input, paddings] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def onesLikeGen chosenName x t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "OnesLike" [x] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def sparseFillEmptyRowsGradGen chosenName reversexindexxmap gradxvalues t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "SparseFillEmptyRowsGrad" [reversexindexxmap, gradxvalues] [gradxvalues.wrapper.typetag, gradxvalues.wrapper.typetag] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def diagGen chosenName diagonal t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Diag" [diagonal] [diagonal.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def fakeQuantWithMinMaxVarsPerChannelGen chosenName inputs min max numxbits narrowxrange:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrInt = lookupSymbol "TFL" "add_attr_int"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "num_bits"
    addAttrInt.call None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt numxbits . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "narrow_range"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if narrowxrange then 1 else 0) . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "FakeQuantWithMinMaxVarsPerChannel" [inputs, min, max] [FloatType] attrList chosenName
    TFOutput wrappers.head.get

def encodeJpegGen chosenName image format quality progressive optimizexsize chromaxdownsampling densityxunit xxdensity yxdensity xmpxmetadata:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrInt = lookupSymbol "TFL" "add_attr_int"
    addAttrString = lookupSymbol "TFL" "add_attr_string"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "format"
    valCStr = CString.fromText format
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    nameCStr = CString.fromText "quality"
    addAttrInt.call None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt quality . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "progressive"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if progressive then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "optimize_size"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if optimizexsize then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "chroma_downsampling"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if chromaxdownsampling then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "density_unit"
    valCStr = CString.fromText densityxunit
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    nameCStr = CString.fromText "x_density"
    addAttrInt.call None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt xxdensity . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "y_density"
    addAttrInt.call None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt yxdensity . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "xmp_metadata"
    valCStr = CString.fromText xmpxmetadata
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    wrappers = makeOutputWrappers "EncodeJpeg" [image] [StringType] attrList chosenName
    TFOutput wrappers.head.get

def addGen chosenName x y t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Add" [x, y] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def randomGammaGradGen chosenName alpha sample t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "RandomGammaGrad" [alpha, sample] [alpha.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def sparseAccumulatorTakeGradientGen chosenName handle numxrequired dtype:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "dtype"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt dtype.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "SparseAccumulatorTakeGradient" [handle, numxrequired] [Int64Type, dtype, Int64Type] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def floorModGen chosenName x y t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "FloorMod" [x, y] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def statelessRandomUniformGen chosenName shape seed dtype t tseed:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "dtype"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt dtype.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tseed"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tseed.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "StatelessRandomUniform" [shape, seed] [dtype] attrList chosenName
    TFOutput wrappers.head.get

def statelessRandomNormalGen chosenName shape seed dtype t tseed:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "dtype"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt dtype.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tseed"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tseed.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "StatelessRandomNormal" [shape, seed] [dtype] attrList chosenName
    TFOutput wrappers.head.get

def statelessMultinomialGen chosenName logits numxsamples seed t tseed outputxdtype:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tseed"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tseed.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "output_dtype"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt outputxdtype.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "StatelessMultinomial" [logits, numxsamples, seed] [outputxdtype] attrList chosenName
    TFOutput wrappers.head.get

def regexReplaceGen chosenName input pattern rewrite replacexglobal:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "replace_global"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if replacexglobal then 1 else 0) . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "RegexReplace" [input, pattern, rewrite] [StringType] attrList chosenName
    TFOutput wrappers.head.get

def regexFullMatchGen chosenName input pattern:
    wrappers = makeOutputWrappers "RegexFullMatch" [input, pattern] [BoolType] attrList chosenName
    TFOutput wrappers.head.get

def tensorArrayScatterV2Gen chosenName handle indices value flowxin t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "TensorArrayScatterV2" [handle, indices, value, flowxin] [FloatType] attrList chosenName
    TFOutput wrappers.head.get

def asStringGen chosenName input t precision scientific shortest width fill:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrInt = lookupSymbol "TFL" "add_attr_int"
    addAttrString = lookupSymbol "TFL" "add_attr_string"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "precision"
    addAttrInt.call None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt precision . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "scientific"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if scientific then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "shortest"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if shortest then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "width"
    addAttrInt.call None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt width . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "fill"
    valCStr = CString.fromText fill
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    wrappers = makeOutputWrappers "AsString" [input] [StringType] attrList chosenName
    TFOutput wrappers.head.get

def stringSplitGen chosenName input delimiter skipxempty:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "skip_empty"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if skipxempty then 1 else 0) . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "StringSplit" [input, delimiter] [Int64Type, StringType, Int64Type] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def stringSplitV2Gen chosenName input sep maxsplit:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrInt = lookupSymbol "TFL" "add_attr_int"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "maxsplit"
    addAttrInt.call None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt maxsplit . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "StringSplitV2" [input, sep] [Int64Type, StringType, Int64Type] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def stringStripGen chosenName input:
    wrappers = makeOutputWrappers "StringStrip" [input] [StringType] attrList chosenName
    TFOutput wrappers.head.get

def stringToHashBucketStrongGen chosenName input numxbuckets key:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrInt = lookupSymbol "TFL" "add_attr_int"
    addAttrIntList = lookupSymbol "TFL" "add_attr_int_list"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "num_buckets"
    addAttrInt.call None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt numxbuckets . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "key"
    cvalues = key.map CInt64.fromInt
    cvaluesArray = (Array CInt64) . fromList cvalues
    addAttrIntList.call None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt key.length . toCArg]
    cvaluesArray.free
    nameCStr.free
    wrappers = makeOutputWrappers "StringToHashBucketStrong" [input] [Int64Type] attrList chosenName
    TFOutput wrappers.head.get

def stringLengthGen chosenName input:
    wrappers = makeOutputWrappers "StringLength" [input] [Int32Type] attrList chosenName
    TFOutput wrappers.head.get

def tensorArrayCloseV2Gen chosenName handle:
    wrappers = makeOutputWrappers "TensorArrayCloseV2" [handle] [] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def encodeBase64Gen chosenName input pad:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "pad"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if pad then 1 else 0) . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "EncodeBase64" [input] [StringType] attrList chosenName
    TFOutput wrappers.head.get

def applyAdaMaxGen chosenName var m v beta1xpower lr beta1 beta2 epsilon grad t usexlocking:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "use_locking"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if usexlocking then 1 else 0) . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "ApplyAdaMax" [var, m, v, beta1xpower, lr, beta1, beta2, epsilon, grad] [var.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def prodGen chosenName input reductionxindices keepxdims t tidx:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "keep_dims"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if keepxdims then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tidx"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tidx.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Prod" [input, reductionxindices] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def isVariableInitializedGen chosenName ref dtype:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "dtype"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt dtype.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "IsVariableInitialized" [ref] [BoolType] attrList chosenName
    TFOutput wrappers.head.get

def gatherGen chosenName params indices validatexindices tparams tindices:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "validate_indices"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if validatexindices then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tparams"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tparams.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tindices"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Gather" [params, indices] [params.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def destroyTemporaryVariableGen chosenName ref t varxname:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrString = lookupSymbol "TFL" "add_attr_string"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "var_name"
    valCStr = CString.fromText varxname
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    wrappers = makeOutputWrappers "DestroyTemporaryVariable" [ref] [ref.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def castGen chosenName x srcT dstT truncate:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "SrcT"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt srcT.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "DstT"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt dstT.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Truncate"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if truncate then 1 else 0) . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Cast" [x] [dstT] attrList chosenName
    TFOutput wrappers.head.get

def assignSubGen chosenName ref value t usexlocking:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "use_locking"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if usexlocking then 1 else 0) . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "AssignSub" [ref, value] [ref.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def scatterAddGen chosenName ref indices updates t tindices usexlocking:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tindices"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "use_locking"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if usexlocking then 1 else 0) . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "ScatterAdd" [ref, indices, updates] [ref.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def scatterMulGen chosenName ref indices updates t tindices usexlocking:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tindices"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "use_locking"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if usexlocking then 1 else 0) . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "ScatterMul" [ref, indices, updates] [ref.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def scatterMaxGen chosenName ref indices updates t tindices usexlocking:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tindices"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "use_locking"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if usexlocking then 1 else 0) . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "ScatterMax" [ref, indices, updates] [ref.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def mirrorPadGen chosenName input paddings t tpaddings mode:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrString = lookupSymbol "TFL" "add_attr_string"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tpaddings"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tpaddings.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "mode"
    valCStr = CString.fromText mode
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    wrappers = makeOutputWrappers "MirrorPad" [input, paddings] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def batchMatrixDiagPartGen chosenName input t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "BatchMatrixDiagPart" [input] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def scatterNdUpdateGen chosenName ref indices updates t tindices usexlocking:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tindices"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "use_locking"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if usexlocking then 1 else 0) . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "ScatterNdUpdate" [ref, indices, updates] [ref.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def divGen chosenName x y t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Div" [x, y] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def scatterNdSubGen chosenName ref indices updates t tindices usexlocking:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tindices"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "use_locking"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if usexlocking then 1 else 0) . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "ScatterNdSub" [ref, indices, updates] [ref.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def topKGen chosenName input k sorted t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrInt = lookupSymbol "TFL" "add_attr_int"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "k"
    addAttrInt.call None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt k . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "sorted"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if sorted then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "TopK" [input] [input.wrapper.typetag, Int32Type] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def applyProximalGradientDescentGen chosenName var alpha l1 l2 delta t usexlocking:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "use_locking"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if usexlocking then 1 else 0) . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "ApplyProximalGradientDescent" [var, alpha, l1, l2, delta] [var.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def matchingFilesGen chosenName pattern:
    wrappers = makeOutputWrappers "MatchingFiles" [pattern] [StringType] attrList chosenName
    TFOutput wrappers.head.get

def sparseApplyProximalGradientDescentGen chosenName var alpha l1 l2 grad indices t tindices usexlocking:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tindices"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "use_locking"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if usexlocking then 1 else 0) . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "SparseApplyProximalGradientDescent" [var, alpha, l1, l2, grad, indices] [var.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def sparseApplyAdadeltaGen chosenName var accum accumxupdate lr rho epsilon grad indices t tindices usexlocking:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tindices"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "use_locking"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if usexlocking then 1 else 0) . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "SparseApplyAdadelta" [var, accum, accumxupdate, lr, rho, epsilon, grad, indices] [var.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def audioSummaryV2Gen chosenName tag tensor samplexrate maxxoutputs:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrInt = lookupSymbol "TFL" "add_attr_int"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "max_outputs"
    addAttrInt.call None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt maxxoutputs . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "AudioSummaryV2" [tag, tensor, samplexrate] [StringType] attrList chosenName
    TFOutput wrappers.head.get

def applyAdagradGen chosenName var accum lr grad t usexlocking updatexslots:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "use_locking"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if usexlocking then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "update_slots"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if updatexslots then 1 else 0) . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "ApplyAdagrad" [var, accum, lr, grad] [var.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def matrixSolveLsGen chosenName matrix rhs l2xregularizer t fast:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "fast"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if fast then 1 else 0) . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "MatrixSolveLs" [matrix, rhs, l2xregularizer] [matrix.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def bitwiseOrGen chosenName x y t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "BitwiseOr" [x, y] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def applyProximalAdagradGen chosenName var accum lr l1 l2 grad t usexlocking:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "use_locking"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if usexlocking then 1 else 0) . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "ApplyProximalAdagrad" [var, accum, lr, l1, l2, grad] [var.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def sparseApplyFtrlGen chosenName var accum linear grad indices lr l1 l2 lrxpower t tindices usexlocking:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tindices"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "use_locking"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if usexlocking then 1 else 0) . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "SparseApplyFtrl" [var, accum, linear, grad, indices, lr, l1, l2, lrxpower] [var.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def subGen chosenName x y t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Sub" [x, y] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def isInfGen chosenName x t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "IsInf" [x] [BoolType] attrList chosenName
    TFOutput wrappers.head.get

def applyFtrlV2Gen chosenName var accum linear grad lr l1 l2 l2xshrinkage lrxpower t usexlocking:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "use_locking"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if usexlocking then 1 else 0) . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "ApplyFtrlV2" [var, accum, linear, grad, lr, l1, l2, l2xshrinkage, lrxpower] [var.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def bitwiseXorGen chosenName x y t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "BitwiseXor" [x, y] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def stringToNumberGen chosenName stringxtensor outxtype:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "out_type"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt outxtype.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "StringToNumber" [stringxtensor] [outxtype] attrList chosenName
    TFOutput wrappers.head.get

def sparseDenseCwiseDivGen chosenName spxindices spxvalues spxshape dense t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "SparseDenseCwiseDiv" [spxindices, spxvalues, spxshape, dense] [spxvalues.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def applyMomentumGen chosenName var accum lr grad momentum t usexlocking usexnesterov:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "use_locking"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if usexlocking then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "use_nesterov"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if usexnesterov then 1 else 0) . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "ApplyMomentum" [var, accum, lr, grad, momentum] [var.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def sparseApplyMomentumGen chosenName var accum lr grad indices momentum t tindices usexlocking usexnesterov:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tindices"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "use_locking"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if usexlocking then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "use_nesterov"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if usexnesterov then 1 else 0) . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "SparseApplyMomentum" [var, accum, lr, grad, indices, momentum] [var.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def crossReplicaSumGen chosenName input groupxassignment t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "CrossReplicaSum" [input, groupxassignment] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def applyCenteredRMSPropGen chosenName var mg ms mom lr rho momentum epsilon grad t usexlocking:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "use_locking"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if usexlocking then 1 else 0) . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "ApplyCenteredRMSProp" [var, mg, ms, mom, lr, rho, momentum, epsilon, grad] [var.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def sparseApplyRMSPropGen chosenName var ms mom lr rho momentum epsilon grad indices t tindices usexlocking:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tindices"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "use_locking"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if usexlocking then 1 else 0) . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "SparseApplyRMSProp" [var, ms, mom, lr, rho, momentum, epsilon, grad, indices] [var.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def sparseApplyCenteredRMSPropGen chosenName var mg ms mom lr rho momentum epsilon grad indices t tindices usexlocking:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tindices"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "use_locking"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if usexlocking then 1 else 0) . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "SparseApplyCenteredRMSProp" [var, mg, ms, mom, lr, rho, momentum, epsilon, grad, indices] [var.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def sizeGen chosenName input t outxtype:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "out_type"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt outxtype.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Size" [input] [outxtype] attrList chosenName
    TFOutput wrappers.head.get

def biasAddV1Gen chosenName value bias t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "BiasAddV1" [value, bias] [value.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def reverseV2Gen chosenName tensor axis tidx t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "Tidx"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tidx.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "ReverseV2" [tensor, axis] [tensor.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def applyAddSignGen chosenName var m lr alpha signxdecay beta grad t usexlocking:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "use_locking"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if usexlocking then 1 else 0) . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "ApplyAddSign" [var, m, lr, alpha, signxdecay, beta, grad] [var.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def matrixDeterminantGen chosenName input t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "MatrixDeterminant" [input] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def readerNumWorkUnitsCompletedGen chosenName readerxhandle:
    wrappers = makeOutputWrappers "ReaderNumWorkUnitsCompleted" [readerxhandle] [Int64Type] attrList chosenName
    TFOutput wrappers.head.get

def gcsConfigureCredentialsGen chosenName json:
    wrappers = makeOutputWrappers "GcsConfigureCredentials" [json] [] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def softplusGen chosenName features t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Softplus" [features] [features.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def expm1Gen chosenName x t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Expm1" [x] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def nextIterationGen chosenName data t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "NextIteration" [data] [data.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def factGen chosenName:
    wrappers = makeOutputWrappers "Fact" [] [StringType] attrList chosenName
    TFOutput wrappers.head.get

def bitwiseAndGen chosenName x y t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "BitwiseAnd" [x, y] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def leftShiftGen chosenName x y t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "LeftShift" [x, y] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def rightShiftGen chosenName x y t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "RightShift" [x, y] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def inplaceUpdateGen chosenName x i v t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "InplaceUpdate" [x, i, v] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def sigmoidGen chosenName x t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Sigmoid" [x] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def inplaceAddGen chosenName x i v t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "InplaceAdd" [x, i, v] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def inplaceSubGen chosenName x i v t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "InplaceSub" [x, i, v] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def unravelIndexGen chosenName indices dims tidx:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "Tidx"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tidx.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "UnravelIndex" [indices, dims] [indices.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def broadcastToGen chosenName input shape t tidx:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tidx"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tidx.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "BroadcastTo" [input, shape] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def hostConstGen chosenName value dtype:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrTensor = lookupSymbol "TFL" "add_attr_tensor"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "value"
    addAttrTensor.call None [attrList.toCArg, nameCStr.toCArg, value.ptr.toCArg]
    nameCStr.free
    nameCStr = CString.fromText "dtype"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt dtype.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "HostConst" [] [dtype] attrList chosenName
    TFOutput wrappers.head.get

def refNextIterationGen chosenName data t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "RefNextIteration" [data] [data.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def zerosLikeGen chosenName x t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "ZerosLike" [x] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def invertGen chosenName x t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Invert" [x] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def matrixDiagGen chosenName diagonal t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "MatrixDiag" [diagonal] [diagonal.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def floorDivGen chosenName x y t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "FloorDiv" [x, y] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def editDistanceGen chosenName hypothesisxindices hypothesisxvalues hypothesisxshape truthxindices truthxvalues truthxshape normalize t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "normalize"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if normalize then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "EditDistance" [hypothesisxindices, hypothesisxvalues, hypothesisxshape, truthxindices, truthxvalues, truthxshape] [FloatType] attrList chosenName
    TFOutput wrappers.head.get

def gatherV2Gen chosenName params indices axis tparams tindices taxis:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "Tparams"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tparams.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tindices"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Taxis"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt taxis.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "GatherV2" [params, indices, axis] [params.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def erfcGen chosenName x t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Erfc" [x] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def gatherNdGen chosenName params indices tparams tindices:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "Tparams"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tparams.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tindices"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "GatherNd" [params, indices] [params.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def refIdentityGen chosenName input t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "RefIdentity" [input] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def stopGradientGen chosenName input t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "StopGradient" [input] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def asinGen chosenName x t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Asin" [x] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def preventGradientGen chosenName input t message:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrString = lookupSymbol "TFL" "add_attr_string"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "message"
    valCStr = CString.fromText message
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    wrappers = makeOutputWrappers "PreventGradient" [input] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def checkNumericsGen chosenName tensor t message:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrString = lookupSymbol "TFL" "add_attr_string"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "message"
    valCStr = CString.fromText message
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    wrappers = makeOutputWrappers "CheckNumerics" [tensor] [tensor.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def conjugateTransposeGen chosenName x perm t tperm:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tperm"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tperm.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "ConjugateTranspose" [x, perm] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def uniqueV2Gen chosenName x axis t taxis outxidx:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Taxis"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt taxis.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "out_idx"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt outxidx.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "UniqueV2" [x, axis] [x.wrapper.typetag, outxidx] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def uniqueWithCountsV2Gen chosenName x axis t taxis outxidx:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Taxis"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt taxis.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "out_idx"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt outxidx.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "UniqueWithCountsV2" [x, axis] [x.wrapper.typetag, outxidx, outxidx] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def reverseSequenceGen chosenName input seqxlengths seqxdim batchxdim t tlen:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrInt = lookupSymbol "TFL" "add_attr_int"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "seq_dim"
    addAttrInt.call None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt seqxdim . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "batch_dim"
    addAttrInt.call None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt batchxdim . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tlen"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tlen.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "ReverseSequence" [input, seqxlengths] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def rsqrtGradGen chosenName y dy t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "RsqrtGrad" [y, dy] [y.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def sliceGen chosenName input begin size t index:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Index"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt index.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Slice" [input, begin, size] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def copyGen chosenName input t tensorxname debugxopsxspec:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrStringList = lookupSymbol "TFL" "add_attr_string_list"
    addAttrString = lookupSymbol "TFL" "add_attr_string"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "tensor_name"
    valCStr = CString.fromText tensorxname
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    nameCStr = CString.fromText "debug_ops_spec"
    len = debugxopsxspec.length
    cValues = ManagedPointer (Pointer CInt64) . mallocElems len
    indexed = 0.upto (len - 1) . zip debugxopsxspec
    indexed.each (idx, elem):
            cValues.moveElems idx . write (CString.fromText elem)
    addAttrStringList.call None [attrList.toCArg, nameCStr.toCArg, cValues.toCArg, CUInt32.fromInt len . toCArg]
    0.upto (len - 1) . each (idx: cValues.moveElems idx . read . free)
    nameCStr.free
    wrappers = makeOutputWrappers "Copy" [input] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def stridedSliceGradGen chosenName shape begin end strides dy t index beginxmask endxmask ellipsisxmask newxaxisxmask shrinkxaxisxmask:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrInt = lookupSymbol "TFL" "add_attr_int"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Index"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt index.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "begin_mask"
    addAttrInt.call None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt beginxmask . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "end_mask"
    addAttrInt.call None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt endxmask . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "ellipsis_mask"
    addAttrInt.call None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt ellipsisxmask . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "new_axis_mask"
    addAttrInt.call None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt newxaxisxmask . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "shrink_axis_mask"
    addAttrInt.call None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt shrinkxaxisxmask . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "StridedSliceGrad" [shape, begin, end, strides, dy] [dy.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def stridedSliceAssignGen chosenName ref begin end strides value t index beginxmask endxmask ellipsisxmask newxaxisxmask shrinkxaxisxmask:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrInt = lookupSymbol "TFL" "add_attr_int"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Index"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt index.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "begin_mask"
    addAttrInt.call None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt beginxmask . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "end_mask"
    addAttrInt.call None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt endxmask . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "ellipsis_mask"
    addAttrInt.call None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt ellipsisxmask . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "new_axis_mask"
    addAttrInt.call None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt newxaxisxmask . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "shrink_axis_mask"
    addAttrInt.call None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt shrinkxaxisxmask . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "StridedSliceAssign" [ref, begin, end, strides, value] [ref.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def tileGradGen chosenName input multiples t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "TileGrad" [input, multiples] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def dataFormatDimMapGen chosenName x t srcxformat dstxformat:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrString = lookupSymbol "TFL" "add_attr_string"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "src_format"
    valCStr = CString.fromText srcxformat
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    nameCStr = CString.fromText "dst_format"
    valCStr = CString.fromText dstxformat
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    wrappers = makeOutputWrappers "DataFormatDimMap" [x] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def broadcastArgsGen chosenName s0 s1 t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "BroadcastArgs" [s0, s1] [s0.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def broadcastGradientArgsGen chosenName s0 s1 t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "BroadcastGradientArgs" [s0, s1] [s0.wrapper.typetag, s0.wrapper.typetag] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def placeholderV2Gen chosenName dtype shape:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrShape = lookupSymbol "TFL" "add_attr_shape"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "dtype"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt dtype.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "shape"
    cdims = shape.map CInt64.fromInt
    cdimsArray = (Array CInt64) . fromList cdims
    addAttrShape.call None [attrList.toCArg, nameCStr.toCArg, cdimsArray.toCArg, CUInt32.fromInt shape.length . toCArg]
    cdimsArray.free
    nameCStr.free
    wrappers = makeOutputWrappers "PlaceholderV2" [] [dtype] attrList chosenName
    TFOutput wrappers.head.get

def expandDimsGen chosenName input dim t tdim:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tdim"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tdim.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "ExpandDims" [input, dim] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def squeezeGen chosenName input t squeezexdims:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrIntList = lookupSymbol "TFL" "add_attr_int_list"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "squeeze_dims"
    cvalues = squeezexdims.map CInt64.fromInt
    cvaluesArray = (Array CInt64) . fromList cvalues
    addAttrIntList.call None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt squeezexdims.length . toCArg]
    cvaluesArray.free
    nameCStr.free
    wrappers = makeOutputWrappers "Squeeze" [input] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def spaceToBatchNDGen chosenName input blockxshape paddings t tblockxshape tpaddings:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tblock_shape"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tblockxshape.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tpaddings"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tpaddings.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "SpaceToBatchND" [input, blockxshape, paddings] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def quantizeAndDequantizeV2Gen chosenName input inputxmin inputxmax signedxinput numxbits rangexgiven t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrInt = lookupSymbol "TFL" "add_attr_int"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "signed_input"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if signedxinput then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "num_bits"
    addAttrInt.call None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt numxbits . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "range_given"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if rangexgiven then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "QuantizeAndDequantizeV2" [input, inputxmin, inputxmax] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def batchToSpaceNDGen chosenName input blockxshape crops t tblockxshape tcrops:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tblock_shape"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tblockxshape.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tcrops"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tcrops.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "BatchToSpaceND" [input, blockxshape, crops] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def extractImagePatchesGen chosenName images ksizes strides rates t padding:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrIntList = lookupSymbol "TFL" "add_attr_int_list"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrString = lookupSymbol "TFL" "add_attr_string"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "ksizes"
    cvalues = ksizes.map CInt64.fromInt
    cvaluesArray = (Array CInt64) . fromList cvalues
    addAttrIntList.call None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt ksizes.length . toCArg]
    cvaluesArray.free
    nameCStr.free
    nameCStr = CString.fromText "strides"
    cvalues = strides.map CInt64.fromInt
    cvaluesArray = (Array CInt64) . fromList cvalues
    addAttrIntList.call None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
    cvaluesArray.free
    nameCStr.free
    nameCStr = CString.fromText "rates"
    cvalues = rates.map CInt64.fromInt
    cvaluesArray = (Array CInt64) . fromList cvalues
    addAttrIntList.call None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt rates.length . toCArg]
    cvaluesArray.free
    nameCStr.free
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "padding"
    valCStr = CString.fromText padding
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    wrappers = makeOutputWrappers "ExtractImagePatches" [images] [images.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def bitcastGen chosenName input t type:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "type"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt type.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Bitcast" [input] [type] attrList chosenName
    TFOutput wrappers.head.get

def accumulatorNumAccumulatedGen chosenName handle:
    wrappers = makeOutputWrappers "AccumulatorNumAccumulated" [handle] [Int32Type] attrList chosenName
    TFOutput wrappers.head.get

def oneHotGen chosenName indices depth onxvalue offxvalue axis t tI:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrInt = lookupSymbol "TFL" "add_attr_int"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "axis"
    addAttrInt.call None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt axis . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "TI"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tI.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "OneHot" [indices, depth, onxvalue, offxvalue] [onxvalue.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def whereGen chosenName input t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Where" [input] [Int64Type] attrList chosenName
    TFOutput wrappers.head.get

def quantizeAndDequantizeGen chosenName input signedxinput numxbits rangexgiven inputxmin inputxmax t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrInt = lookupSymbol "TFL" "add_attr_int"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrFloat = lookupSymbol "TFL" "add_attr_float"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "signed_input"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if signedxinput then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "num_bits"
    addAttrInt.call None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt numxbits . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "range_given"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if rangexgiven then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "input_min"
    addAttrFloat.call None [attrList.toCArg, nameCStr.toCArg, CFloat.fromReal inputxmin . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "input_max"
    addAttrFloat.call None [attrList.toCArg, nameCStr.toCArg, CFloat.fromReal inputxmax . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "QuantizeAndDequantize" [input] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def quantizeAndDequantizeV3Gen chosenName input inputxmin inputxmax numxbits signedxinput rangexgiven t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "signed_input"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if signedxinput then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "range_given"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if rangexgiven then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "QuantizeAndDequantizeV3" [input, inputxmin, inputxmax, numxbits] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def sparseApplyProximalAdagradGen chosenName var accum lr l1 l2 grad indices t tindices usexlocking:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tindices"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "use_locking"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if usexlocking then 1 else 0) . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "SparseApplyProximalAdagrad" [var, accum, lr, l1, l2, grad, indices] [var.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def quantizedReshapeGen chosenName tensor shape inputxmin inputxmax t tshape:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tshape"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tshape.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "QuantizedReshape" [tensor, shape, inputxmin, inputxmax] [tensor.wrapper.typetag, FloatType, FloatType] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def diagPartGen chosenName input t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "DiagPart" [input] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def fakeQuantWithMinMaxVarsPerChannelGradientGen chosenName gradients inputs min max numxbits narrowxrange:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrInt = lookupSymbol "TFL" "add_attr_int"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "num_bits"
    addAttrInt.call None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt numxbits . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "narrow_range"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if narrowxrange then 1 else 0) . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "FakeQuantWithMinMaxVarsPerChannelGradient" [gradients, inputs, min, max] [FloatType, FloatType, FloatType] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def batchMatrixSetDiagGen chosenName input diagonal t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "BatchMatrixSetDiag" [input, diagonal] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def batchMatrixBandPartGen chosenName input numxlower numxupper t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "BatchMatrixBandPart" [input, numxlower, numxupper] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def batchMatrixDeterminantGen chosenName input t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "BatchMatrixDeterminant" [input] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def enterGen chosenName data t framexname isxconstant parallelxiterations:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrInt = lookupSymbol "TFL" "add_attr_int"
    addAttrString = lookupSymbol "TFL" "add_attr_string"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "frame_name"
    valCStr = CString.fromText framexname
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    nameCStr = CString.fromText "is_constant"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if isxconstant then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "parallel_iterations"
    addAttrInt.call None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt parallelxiterations . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Enter" [data] [data.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def negGen chosenName x t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Neg" [x] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def reciprocalGradGen chosenName y dy t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "ReciprocalGrad" [y, dy] [y.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def squareGen chosenName x t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Square" [x] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def conv3DBackpropFilterGen chosenName input filter outxbackprop t strides padding dilations:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrIntList = lookupSymbol "TFL" "add_attr_int_list"
    addAttrString = lookupSymbol "TFL" "add_attr_string"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "strides"
    cvalues = strides.map CInt64.fromInt
    cvaluesArray = (Array CInt64) . fromList cvalues
    addAttrIntList.call None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
    cvaluesArray.free
    nameCStr.free
    nameCStr = CString.fromText "padding"
    valCStr = CString.fromText padding
    addAttrString.call None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    valCStr.free
    nameCStr.free
    nameCStr = CString.fromText "dilations"
    cvalues = dilations.map CInt64.fromInt
    cvaluesArray = (Array CInt64) . fromList cvalues
    addAttrIntList.call None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt dilations.length . toCArg]
    cvaluesArray.free
    nameCStr.free
    wrappers = makeOutputWrappers "Conv3DBackpropFilter" [input, filter, outxbackprop] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def sqrtGen chosenName x t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Sqrt" [x] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def expGen chosenName x t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Exp" [x] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def logGen chosenName x t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Log" [x] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def sparseSegmentMeanWithNumSegmentsGen chosenName data indices segmentxids numxsegments t tidx tnumsegments:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tidx"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tidx.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tnumsegments"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tnumsegments.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "SparseSegmentMeanWithNumSegments" [data, indices, segmentxids, numxsegments] [data.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def coshGen chosenName x t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Cosh" [x] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def segmentMaxGen chosenName data segmentxids t tindices:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tindices"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "SegmentMax" [data, segmentxids] [data.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def tanhGen chosenName x t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Tanh" [x] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def hSVToRGBGen chosenName images t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "HSVToRGB" [images] [images.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def sigmoidGradGen chosenName y dy t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "SigmoidGrad" [y, dy] [y.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def sinGen chosenName x t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Sin" [x] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def acosGen chosenName x t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Acos" [x] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def scatterDivGen chosenName ref indices updates t tindices usexlocking:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tindices"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "use_locking"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if usexlocking then 1 else 0) . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "ScatterDiv" [ref, indices, updates] [ref.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def encodeWavGen chosenName audio samplexrate:
    wrappers = makeOutputWrappers "EncodeWav" [audio, samplexrate] [StringType] attrList chosenName
    TFOutput wrappers.head.get

def atanGen chosenName x t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Atan" [x] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def besselI0eGen chosenName x t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "BesselI0e" [x] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def minGen chosenName input reductionxindices keepxdims t tidx:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrBool = lookupSymbol "TFL" "add_attr_bool"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "keep_dims"
    addAttrBool.call None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if keepxdims then 1 else 0) . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tidx"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tidx.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Min" [input, reductionxindices] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def transposeGen chosenName x perm t tperm:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tperm"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tperm.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Transpose" [x, perm] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def besselI1eGen chosenName x t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "BesselI1e" [x] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def xUnaryOpsCompositionGen chosenName x t opxnames:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrStringList = lookupSymbol "TFL" "add_attr_string_list"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "op_names"
    len = opxnames.length
    cValues = ManagedPointer (Pointer CInt64) . mallocElems len
    indexed = 0.upto (len - 1) . zip opxnames
    indexed.each (idx, elem):
            cValues.moveElems idx . write (CString.fromText elem)
    addAttrStringList.call None [attrList.toCArg, nameCStr.toCArg, cValues.toCArg, CUInt32.fromInt len . toCArg]
    0.upto (len - 1) . each (idx: cValues.moveElems idx . read . free)
    nameCStr.free
    wrappers = makeOutputWrappers "_UnaryOpsComposition" [x] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def signGen chosenName x t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Sign" [x] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def ceilGen chosenName x t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Ceil" [x] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def rintGen chosenName x t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Rint" [x] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def addV2Gen chosenName x y t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "AddV2" [x, y] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def xMklSubGen chosenName x y mklxx mklxy t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "_MklSub" [x, y, mklxx, mklxy] [x.wrapper.typetag, UInt8Type] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def encodePngGen chosenName image compression t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrInt = lookupSymbol "TFL" "add_attr_int"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "compression"
    addAttrInt.call None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt compression . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "EncodePng" [image] [StringType] attrList chosenName
    TFOutput wrappers.head.get

def xMklMulGen chosenName x y mklxx mklxy t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "_MklMul" [x, y, mklxx, mklxy] [x.wrapper.typetag, UInt8Type] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def tensorArrayPackGen chosenName handle flowxin dtype elementxshape:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    addAttrShape = lookupSymbol "TFL" "add_attr_shape"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "dtype"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt dtype.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "element_shape"
    cdims = elementxshape.map CInt64.fromInt
    cdimsArray = (Array CInt64) . fromList cdims
    addAttrShape.call None [attrList.toCArg, nameCStr.toCArg, cdimsArray.toCArg, CUInt32.fromInt elementxshape.length . toCArg]
    cdimsArray.free
    nameCStr.free
    wrappers = makeOutputWrappers "TensorArrayPack" [handle, flowxin] [dtype] attrList chosenName
    TFOutput wrappers.head.get

def maximumGen chosenName x y t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Maximum" [x, y] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def truncateModGen chosenName x y t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "TruncateMod" [x, y] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def sparseSegmentSqrtNWithNumSegmentsGen chosenName data indices segmentxids numxsegments t tidx tnumsegments:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tidx"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tidx.num . toCArg]
    nameCStr.free
    nameCStr = CString.fromText "Tnumsegments"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tnumsegments.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "SparseSegmentSqrtNWithNumSegments" [data, indices, segmentxids, numxsegments] [data.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def igammacGen chosenName a x t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Igammac" [a, x] [a.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def igammaGen chosenName a x t:
    initAttrList = lookupSymbol "TFL" "attr_list_init"
    addAttrType = lookupSymbol "TFL" "add_attr_type"
    releaseMethod = lookupSymbol "TFL" "release"
    attrListPtr = initAttrList.call (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    nameCStr = CString.fromText "T"
    addAttrType.call None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    nameCStr.free
    wrappers = makeOutputWrappers "Igamma" [a, x] [a.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get
