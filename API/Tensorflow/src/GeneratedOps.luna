import Std.Foreign
import Std.Foreign.C.Value
import Tensorflow.CWrappers.Operations
import Tensorflow.CWrappers.Helpers
import Tensorflow.Types
import Tensorflow.Operations

def fractionalAvgPoolGradGen chosenName origInputTensorShape outBackprop rowPoolingSequence colPoolingSequence overlapping t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "overlapping" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if overlapping then 1 else 0) . toCArg]
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "FractionalAvgPoolGrad" [origInputTensorShape, outBackprop, rowPoolingSequence, colPoolingSequence] [outBackprop.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def fractionalAvgPoolGen chosenName value poolingRatio pseudoRandom overlapping deterministic seed seed2 t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "pooling_ratio" nameCStr:
        cvalues = poolingRatio.map CFloat.fromReal
        Array CFloat . with cvalues cvaluesArray:
            callHandlingError "add_attr_float_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt poolingRatio.length . toCArg]
    CString.with "pseudo_random" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if pseudoRandom then 1 else 0) . toCArg]
    CString.with "overlapping" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if overlapping then 1 else 0) . toCArg]
    CString.with "deterministic" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if deterministic then 1 else 0) . toCArg]
    CString.with "seed" nameCStr:
        callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt seed . toCArg]
    CString.with "seed2" nameCStr:
        callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt seed2 . toCArg]
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "FractionalAvgPool" [value] [value.wrapper.typetag, Int64Type, Int64Type] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def fractionalMaxPoolGradGen chosenName origInput origOutput outBackprop rowPoolingSequence colPoolingSequence overlapping t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "overlapping" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if overlapping then 1 else 0) . toCArg]
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "FractionalMaxPoolGrad" [origInput, origOutput, outBackprop, rowPoolingSequence, colPoolingSequence] [origInput.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def topKV2Gen chosenName input k sorted t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "sorted" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if sorted then 1 else 0) . toCArg]
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "TopKV2" [input, k] [input.wrapper.typetag, Int32Type] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def inTopKV2Gen chosenName predictions targets k t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "InTopKV2" [predictions, targets, k] [BoolType] attrList chosenName
    TFOutput wrappers.head.get

def inTopKGen chosenName predictions targets k t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "k" nameCStr:
        callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt k . toCArg]
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "InTopK" [predictions, targets] [BoolType] attrList chosenName
    TFOutput wrappers.head.get

def sparseSoftmaxCrossEntropyWithLogitsGen chosenName features labels t tlabels:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "Tlabels" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tlabels.num . toCArg]
    wrappers = makeOutputWrappers "SparseSoftmaxCrossEntropyWithLogits" [features, labels] [features.wrapper.typetag, features.wrapper.typetag] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def softmaxCrossEntropyWithLogitsGen chosenName features labels t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "SoftmaxCrossEntropyWithLogits" [features, labels] [features.wrapper.typetag, features.wrapper.typetag] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def softmaxGen chosenName logits t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "Softmax" [logits] [logits.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def softsignGradGen chosenName gradients features t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "SoftsignGrad" [gradients, features] [gradients.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def softsignGen chosenName features t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "Softsign" [features] [features.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def eluGen chosenName features t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "Elu" [features] [features.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def relu6GradGen chosenName gradients features t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "Relu6Grad" [gradients, features] [gradients.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def relu6Gen chosenName features t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "Relu6" [features] [features.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def reluGradGen chosenName gradients features t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "ReluGrad" [gradients, features] [gradients.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def dilation2DBackpropInputGen chosenName input filter outBackprop t strides rates padding:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "strides" nameCStr:
        cvalues = strides.map CInt64.fromInt
        Array CInt64 . with cvalues cvaluesArray:
            callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
    CString.with "rates" nameCStr:
        cvalues = rates.map CInt64.fromInt
        Array CInt64 . with cvalues cvaluesArray:
            callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt rates.length . toCArg]
    CString.with "padding" nameCStr:
        CString.with padding valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    wrappers = makeOutputWrappers "Dilation2DBackpropInput" [input, filter, outBackprop] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def maxPoolGradGradWithArgmaxGen chosenName input grad argmax ksize strides padding targmax t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "ksize" nameCStr:
        cvalues = ksize.map CInt64.fromInt
        Array CInt64 . with cvalues cvaluesArray:
            callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt ksize.length . toCArg]
    CString.with "strides" nameCStr:
        cvalues = strides.map CInt64.fromInt
        Array CInt64 . with cvalues cvaluesArray:
            callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
    CString.with "padding" nameCStr:
        CString.with padding valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    CString.with "Targmax" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt targmax.num . toCArg]
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "MaxPoolGradGradWithArgmax" [input, grad, argmax] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def maxPoolGradWithArgmaxGen chosenName input grad argmax ksize strides padding targmax t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "ksize" nameCStr:
        cvalues = ksize.map CInt64.fromInt
        Array CInt64 . with cvalues cvaluesArray:
            callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt ksize.length . toCArg]
    CString.with "strides" nameCStr:
        cvalues = strides.map CInt64.fromInt
        Array CInt64 . with cvalues cvaluesArray:
            callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
    CString.with "padding" nameCStr:
        CString.with padding valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    CString.with "Targmax" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt targmax.num . toCArg]
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "MaxPoolGradWithArgmax" [input, grad, argmax] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def maxPoolGradGradV2Gen chosenName origInput origOutput grad ksize strides padding dataFormat t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "padding" nameCStr:
        CString.with padding valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    CString.with "data_format" nameCStr:
        CString.with dataFormat valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "MaxPoolGradGradV2" [origInput, origOutput, grad, ksize, strides] [origInput.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def maxPoolGradGen chosenName origInput origOutput grad ksize strides padding dataFormat t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "ksize" nameCStr:
        cvalues = ksize.map CInt64.fromInt
        Array CInt64 . with cvalues cvaluesArray:
            callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt ksize.length . toCArg]
    CString.with "strides" nameCStr:
        cvalues = strides.map CInt64.fromInt
        Array CInt64 . with cvalues cvaluesArray:
            callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
    CString.with "padding" nameCStr:
        CString.with padding valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    CString.with "data_format" nameCStr:
        CString.with dataFormat valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "MaxPoolGrad" [origInput, origOutput, grad] [origInput.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def maxPoolGen chosenName input t ksize strides padding dataFormat:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "ksize" nameCStr:
        cvalues = ksize.map CInt64.fromInt
        Array CInt64 . with cvalues cvaluesArray:
            callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt ksize.length . toCArg]
    CString.with "strides" nameCStr:
        cvalues = strides.map CInt64.fromInt
        Array CInt64 . with cvalues cvaluesArray:
            callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
    CString.with "padding" nameCStr:
        CString.with padding valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    CString.with "data_format" nameCStr:
        CString.with dataFormat valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    wrappers = makeOutputWrappers "MaxPool" [input] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def lRNGen chosenName input depthRadius bias alpha beta t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "depth_radius" nameCStr:
        callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt depthRadius . toCArg]
    CString.with "bias" nameCStr:
        callHandlingError "add_attr_float" None [attrList.toCArg, nameCStr.toCArg, CFloat.fromReal bias . toCArg]
    CString.with "alpha" nameCStr:
        callHandlingError "add_attr_float" None [attrList.toCArg, nameCStr.toCArg, CFloat.fromReal alpha . toCArg]
    CString.with "beta" nameCStr:
        callHandlingError "add_attr_float" None [attrList.toCArg, nameCStr.toCArg, CFloat.fromReal beta . toCArg]
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "LRN" [input] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def maxPool3DGradGen chosenName origInput origOutput grad ksize strides padding dataFormat t tInput:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "ksize" nameCStr:
        cvalues = ksize.map CInt64.fromInt
        Array CInt64 . with cvalues cvaluesArray:
            callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt ksize.length . toCArg]
    CString.with "strides" nameCStr:
        cvalues = strides.map CInt64.fromInt
        Array CInt64 . with cvalues cvaluesArray:
            callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
    CString.with "padding" nameCStr:
        CString.with padding valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    CString.with "data_format" nameCStr:
        CString.with dataFormat valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "TInput" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tInput.num . toCArg]
    wrappers = makeOutputWrappers "MaxPool3DGrad" [origInput, origOutput, grad] [grad.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def maxPool3DGradGradGen chosenName origInput origOutput grad ksize strides padding dataFormat t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "ksize" nameCStr:
        cvalues = ksize.map CInt64.fromInt
        Array CInt64 . with cvalues cvaluesArray:
            callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt ksize.length . toCArg]
    CString.with "strides" nameCStr:
        cvalues = strides.map CInt64.fromInt
        Array CInt64 . with cvalues cvaluesArray:
            callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
    CString.with "padding" nameCStr:
        CString.with padding valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    CString.with "data_format" nameCStr:
        CString.with dataFormat valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "MaxPool3DGradGrad" [origInput, origOutput, grad] [origInput.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def conv3DBackpropFilterV2Gen chosenName input filterSizes outBackprop t strides padding dataFormat dilations:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "strides" nameCStr:
        cvalues = strides.map CInt64.fromInt
        Array CInt64 . with cvalues cvaluesArray:
            callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
    CString.with "padding" nameCStr:
        CString.with padding valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    CString.with "data_format" nameCStr:
        CString.with dataFormat valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    CString.with "dilations" nameCStr:
        cvalues = dilations.map CInt64.fromInt
        Array CInt64 . with cvalues cvaluesArray:
            callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt dilations.length . toCArg]
    wrappers = makeOutputWrappers "Conv3DBackpropFilterV2" [input, filterSizes, outBackprop] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def conv3DGen chosenName input filter t strides padding dataFormat dilations:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "strides" nameCStr:
        cvalues = strides.map CInt64.fromInt
        Array CInt64 . with cvalues cvaluesArray:
            callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
    CString.with "padding" nameCStr:
        CString.with padding valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    CString.with "data_format" nameCStr:
        CString.with dataFormat valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    CString.with "dilations" nameCStr:
        cvalues = dilations.map CInt64.fromInt
        Array CInt64 . with cvalues cvaluesArray:
            callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt dilations.length . toCArg]
    wrappers = makeOutputWrappers "Conv3D" [input, filter] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def depthwiseConv2dNativeBackpropFilterGen chosenName input filterSizes outBackprop t strides padding dataFormat dilations:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "strides" nameCStr:
        cvalues = strides.map CInt64.fromInt
        Array CInt64 . with cvalues cvaluesArray:
            callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
    CString.with "padding" nameCStr:
        CString.with padding valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    CString.with "data_format" nameCStr:
        CString.with dataFormat valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    CString.with "dilations" nameCStr:
        cvalues = dilations.map CInt64.fromInt
        Array CInt64 . with cvalues cvaluesArray:
            callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt dilations.length . toCArg]
    wrappers = makeOutputWrappers "DepthwiseConv2dNativeBackpropFilter" [input, filterSizes, outBackprop] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def depthwiseConv2dNativeBackpropInputGen chosenName inputSizes filter outBackprop t strides padding dataFormat dilations:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "strides" nameCStr:
        cvalues = strides.map CInt64.fromInt
        Array CInt64 . with cvalues cvaluesArray:
            callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
    CString.with "padding" nameCStr:
        CString.with padding valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    CString.with "data_format" nameCStr:
        CString.with dataFormat valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    CString.with "dilations" nameCStr:
        cvalues = dilations.map CInt64.fromInt
        Array CInt64 . with cvalues cvaluesArray:
            callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt dilations.length . toCArg]
    wrappers = makeOutputWrappers "DepthwiseConv2dNativeBackpropInput" [inputSizes, filter, outBackprop] [filter.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def depthwiseConv2dNativeGen chosenName input filter t strides padding dataFormat dilations:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "strides" nameCStr:
        cvalues = strides.map CInt64.fromInt
        Array CInt64 . with cvalues cvaluesArray:
            callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
    CString.with "padding" nameCStr:
        CString.with padding valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    CString.with "data_format" nameCStr:
        CString.with dataFormat valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    CString.with "dilations" nameCStr:
        cvalues = dilations.map CInt64.fromInt
        Array CInt64 . with cvalues cvaluesArray:
            callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt dilations.length . toCArg]
    wrappers = makeOutputWrappers "DepthwiseConv2dNative" [input, filter] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def fusedResizeAndPadConv2DGen chosenName input size paddings filter t resizeAlignCorners mode strides padding:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "resize_align_corners" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if resizeAlignCorners then 1 else 0) . toCArg]
    CString.with "mode" nameCStr:
        CString.with mode valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    CString.with "strides" nameCStr:
        cvalues = strides.map CInt64.fromInt
        Array CInt64 . with cvalues cvaluesArray:
            callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
    CString.with "padding" nameCStr:
        CString.with padding valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    wrappers = makeOutputWrappers "FusedResizeAndPadConv2D" [input, size, paddings, filter] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def dataFormatVecPermuteGen chosenName x t srcFormat dstFormat:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "src_format" nameCStr:
        CString.with srcFormat valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    CString.with "dst_format" nameCStr:
        CString.with dstFormat valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    wrappers = makeOutputWrappers "DataFormatVecPermute" [x] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def conv2DBackpropFilterGen chosenName input filterSizes outBackprop t strides useCudnnOnGpu padding dataFormat dilations:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "strides" nameCStr:
        cvalues = strides.map CInt64.fromInt
        Array CInt64 . with cvalues cvaluesArray:
            callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
    CString.with "use_cudnn_on_gpu" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useCudnnOnGpu then 1 else 0) . toCArg]
    CString.with "padding" nameCStr:
        CString.with padding valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    CString.with "data_format" nameCStr:
        CString.with dataFormat valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    CString.with "dilations" nameCStr:
        cvalues = dilations.map CInt64.fromInt
        Array CInt64 . with cvalues cvaluesArray:
            callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt dilations.length . toCArg]
    wrappers = makeOutputWrappers "Conv2DBackpropFilter" [input, filterSizes, outBackprop] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def biasAddGen chosenName value bias t dataFormat:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "data_format" nameCStr:
        CString.with dataFormat valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    wrappers = makeOutputWrappers "BiasAdd" [value, bias] [value.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def fusedBatchNormGen chosenName x scale offset mean variance t epsilon dataFormat isTraining:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "epsilon" nameCStr:
        callHandlingError "add_attr_float" None [attrList.toCArg, nameCStr.toCArg, CFloat.fromReal epsilon . toCArg]
    CString.with "data_format" nameCStr:
        CString.with dataFormat valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    CString.with "is_training" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if isTraining then 1 else 0) . toCArg]
    wrappers = makeOutputWrappers "FusedBatchNorm" [x, scale, offset, mean, variance] [x.wrapper.typetag, x.wrapper.typetag, x.wrapper.typetag, x.wrapper.typetag, x.wrapper.typetag] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def avgPoolGradGen chosenName origInputShape grad ksize strides padding dataFormat t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "ksize" nameCStr:
        cvalues = ksize.map CInt64.fromInt
        Array CInt64 . with cvalues cvaluesArray:
            callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt ksize.length . toCArg]
    CString.with "strides" nameCStr:
        cvalues = strides.map CInt64.fromInt
        Array CInt64 . with cvalues cvaluesArray:
            callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
    CString.with "padding" nameCStr:
        CString.with padding valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    CString.with "data_format" nameCStr:
        CString.with dataFormat valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "AvgPoolGrad" [origInputShape, grad] [grad.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def clipByValueGen chosenName t clipValueMin clipValueMax t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "ClipByValue" [t, clipValueMin, clipValueMax] [t.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def cumprodGen chosenName x axis exclusive reverse t tidx:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "exclusive" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if exclusive then 1 else 0) . toCArg]
    CString.with "reverse" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if reverse then 1 else 0) . toCArg]
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "Tidx" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tidx.num . toCArg]
    wrappers = makeOutputWrappers "Cumprod" [x, axis] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def cumsumGen chosenName x axis exclusive reverse t tidx:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "exclusive" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if exclusive then 1 else 0) . toCArg]
    CString.with "reverse" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if reverse then 1 else 0) . toCArg]
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "Tidx" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tidx.num . toCArg]
    wrappers = makeOutputWrappers "Cumsum" [x, axis] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def bincountGen chosenName arr size weights t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "Bincount" [arr, size, weights] [weights.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def histogramFixedWidthGen chosenName values valueRange nbins t dtype:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "dtype" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt dtype.num . toCArg]
    wrappers = makeOutputWrappers "HistogramFixedWidth" [values, valueRange, nbins] [dtype] attrList chosenName
    TFOutput wrappers.head.get

def rangeGen chosenName start limit delta tidx:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "Tidx" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tidx.num . toCArg]
    wrappers = makeOutputWrappers "Range" [start, limit, delta] [start.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def lRNGradGen chosenName inputGrads inputImage outputImage depthRadius bias alpha beta t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "depth_radius" nameCStr:
        callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt depthRadius . toCArg]
    CString.with "bias" nameCStr:
        callHandlingError "add_attr_float" None [attrList.toCArg, nameCStr.toCArg, CFloat.fromReal bias . toCArg]
    CString.with "alpha" nameCStr:
        callHandlingError "add_attr_float" None [attrList.toCArg, nameCStr.toCArg, CFloat.fromReal alpha . toCArg]
    CString.with "beta" nameCStr:
        callHandlingError "add_attr_float" None [attrList.toCArg, nameCStr.toCArg, CFloat.fromReal beta . toCArg]
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "LRNGrad" [inputGrads, inputImage, outputImage] [inputGrads.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def anyGen chosenName input reductionIndices keepDims tidx:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "keep_dims" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if keepDims then 1 else 0) . toCArg]
    CString.with "Tidx" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tidx.num . toCArg]
    wrappers = makeOutputWrappers "Any" [input, reductionIndices] [BoolType] attrList chosenName
    TFOutput wrappers.head.get

def sparseSegmentSqrtNGradGen chosenName grad indices segmentIds outputDim0 t tidx:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "Tidx" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tidx.num . toCArg]
    wrappers = makeOutputWrappers "SparseSegmentSqrtNGrad" [grad, indices, segmentIds, outputDim0] [grad.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def sparseSegmentSqrtNGen chosenName data indices segmentIds t tidx:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "Tidx" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tidx.num . toCArg]
    wrappers = makeOutputWrappers "SparseSegmentSqrtN" [data, indices, segmentIds] [data.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def sparseSegmentMeanGen chosenName data indices segmentIds t tidx:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "Tidx" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tidx.num . toCArg]
    wrappers = makeOutputWrappers "SparseSegmentMean" [data, indices, segmentIds] [data.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def sparseSegmentSumWithNumSegmentsGen chosenName data indices segmentIds numSegments t tidx tnumsegments:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "Tidx" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tidx.num . toCArg]
    CString.with "Tnumsegments" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tnumsegments.num . toCArg]
    wrappers = makeOutputWrappers "SparseSegmentSumWithNumSegments" [data, indices, segmentIds, numSegments] [data.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def sparseSegmentSumGen chosenName data indices segmentIds t tidx:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "Tidx" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tidx.num . toCArg]
    wrappers = makeOutputWrappers "SparseSegmentSum" [data, indices, segmentIds] [data.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def unsortedSegmentProdGen chosenName data segmentIds numSegments t tindices tnumsegments:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "Tindices" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
    CString.with "Tnumsegments" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tnumsegments.num . toCArg]
    wrappers = makeOutputWrappers "UnsortedSegmentProd" [data, segmentIds, numSegments] [data.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def unsortedSegmentMinGen chosenName data segmentIds numSegments t tindices tnumsegments:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "Tindices" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
    CString.with "Tnumsegments" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tnumsegments.num . toCArg]
    wrappers = makeOutputWrappers "UnsortedSegmentMin" [data, segmentIds, numSegments] [data.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def nthElementGen chosenName input n reverse t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "reverse" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if reverse then 1 else 0) . toCArg]
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "NthElement" [input, n] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def unsortedSegmentMaxGen chosenName data segmentIds numSegments t tindices tnumsegments:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "Tindices" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
    CString.with "Tnumsegments" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tnumsegments.num . toCArg]
    wrappers = makeOutputWrappers "UnsortedSegmentMax" [data, segmentIds, numSegments] [data.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def unsortedSegmentSumGen chosenName data segmentIds numSegments t tindices tnumsegments:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "Tindices" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
    CString.with "Tnumsegments" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tnumsegments.num . toCArg]
    wrappers = makeOutputWrappers "UnsortedSegmentSum" [data, segmentIds, numSegments] [data.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def segmentMinGen chosenName data segmentIds t tindices:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "Tindices" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
    wrappers = makeOutputWrappers "SegmentMin" [data, segmentIds] [data.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def segmentMeanGen chosenName data segmentIds t tindices:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "Tindices" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
    wrappers = makeOutputWrappers "SegmentMean" [data, segmentIds] [data.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def argMinGen chosenName input dimension t tidx outputType:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "Tidx" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tidx.num . toCArg]
    CString.with "output_type" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt outputType.num . toCArg]
    wrappers = makeOutputWrappers "ArgMin" [input, dimension] [outputType] attrList chosenName
    TFOutput wrappers.head.get

def maxGen chosenName input reductionIndices keepDims t tidx:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "keep_dims" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if keepDims then 1 else 0) . toCArg]
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "Tidx" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tidx.num . toCArg]
    wrappers = makeOutputWrappers "Max" [input, reductionIndices] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def sumGen chosenName input reductionIndices keepDims t tidx:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "keep_dims" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if keepDims then 1 else 0) . toCArg]
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "Tidx" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tidx.num . toCArg]
    wrappers = makeOutputWrappers "Sum" [input, reductionIndices] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def sparseMatMulGen chosenName a b transposeA transposeB aIsSparse bIsSparse ta tb:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "transpose_a" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if transposeA then 1 else 0) . toCArg]
    CString.with "transpose_b" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if transposeB then 1 else 0) . toCArg]
    CString.with "a_is_sparse" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if aIsSparse then 1 else 0) . toCArg]
    CString.with "b_is_sparse" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if bIsSparse then 1 else 0) . toCArg]
    CString.with "Ta" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt ta.num . toCArg]
    CString.with "Tb" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tb.num . toCArg]
    wrappers = makeOutputWrappers "SparseMatMul" [a, b] [FloatType] attrList chosenName
    TFOutput wrappers.head.get

def matMulGen chosenName a b transposeA transposeB t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "transpose_a" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if transposeA then 1 else 0) . toCArg]
    CString.with "transpose_b" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if transposeB then 1 else 0) . toCArg]
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "MatMul" [a, b] [a.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def selectGen chosenName condition t e t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "Select" [condition, t, e] [t.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def logicalOrGen chosenName x y:
    wrappers = makeOutputWrappers "LogicalOr" [x, y] [BoolType] attrList chosenName
    TFOutput wrappers.head.get

def logicalAndGen chosenName x y:
    wrappers = makeOutputWrappers "LogicalAnd" [x, y] [BoolType] attrList chosenName
    TFOutput wrappers.head.get

def approximateEqualGen chosenName x y t tolerance:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "tolerance" nameCStr:
        callHandlingError "add_attr_float" None [attrList.toCArg, nameCStr.toCArg, CFloat.fromReal tolerance . toCArg]
    wrappers = makeOutputWrappers "ApproximateEqual" [x, y] [BoolType] attrList chosenName
    TFOutput wrappers.head.get

def notEqualGen chosenName x y t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "NotEqual" [x, y] [BoolType] attrList chosenName
    TFOutput wrappers.head.get

def greaterEqualGen chosenName x y t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "GreaterEqual" [x, y] [BoolType] attrList chosenName
    TFOutput wrappers.head.get

def greaterGen chosenName x y t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "Greater" [x, y] [BoolType] attrList chosenName
    TFOutput wrappers.head.get

def lessEqualGen chosenName x y t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "LessEqual" [x, y] [BoolType] attrList chosenName
    TFOutput wrappers.head.get

def lessGen chosenName x y t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "Less" [x, y] [BoolType] attrList chosenName
    TFOutput wrappers.head.get

def betaincGen chosenName a b x t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "Betainc" [a, b, x] [a.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def polygammaGen chosenName a x t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "Polygamma" [a, x] [a.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def zetaGen chosenName x q t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "Zeta" [x, q] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def meanGen chosenName input reductionIndices keepDims t tidx:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "keep_dims" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if keepDims then 1 else 0) . toCArg]
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "Tidx" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tidx.num . toCArg]
    wrappers = makeOutputWrappers "Mean" [input, reductionIndices] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def initializeTableFromTextFileGen chosenName tableHandle filename keyIndex valueIndex vocabSize delimiter:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "key_index" nameCStr:
        callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt keyIndex . toCArg]
    CString.with "value_index" nameCStr:
        callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt valueIndex . toCArg]
    CString.with "vocab_size" nameCStr:
        callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt vocabSize . toCArg]
    CString.with "delimiter" nameCStr:
        CString.with delimiter valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    wrappers = makeOutputWrappers "InitializeTableFromTextFile" [tableHandle, filename] [] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def fakeQuantWithMinMaxVarsGradientGen chosenName gradients inputs min max numBits narrowRange:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "num_bits" nameCStr:
        callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt numBits . toCArg]
    CString.with "narrow_range" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if narrowRange then 1 else 0) . toCArg]
    wrappers = makeOutputWrappers "FakeQuantWithMinMaxVarsGradient" [gradients, inputs, min, max] [FloatType, FloatType, FloatType] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def minimumGen chosenName x y t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "Minimum" [x, y] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def batchCholeskyGen chosenName input t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "BatchCholesky" [input] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def resizeBilinearGradGen chosenName grads originalImage t alignCorners:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "align_corners" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if alignCorners then 1 else 0) . toCArg]
    wrappers = makeOutputWrappers "ResizeBilinearGrad" [grads, originalImage] [originalImage.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def lookupTableSizeGen chosenName tableHandle:
    wrappers = makeOutputWrappers "LookupTableSize" [tableHandle] [Int64Type] attrList chosenName
    TFOutput wrappers.head.get

def bucketizeGen chosenName input t boundaries:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "boundaries" nameCStr:
        cvalues = boundaries.map CFloat.fromReal
        Array CFloat . with cvalues cvaluesArray:
            callHandlingError "add_attr_float_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt boundaries.length . toCArg]
    wrappers = makeOutputWrappers "Bucketize" [input] [Int32Type] attrList chosenName
    TFOutput wrappers.head.get

def lookupTableInsertGen chosenName tableHandle keys values tin tout:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "Tin" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tin.num . toCArg]
    CString.with "Tout" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tout.num . toCArg]
    wrappers = makeOutputWrappers "LookupTableInsert" [tableHandle, keys, values] [] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def tPUReplicateMetadataGen chosenName numReplicas topology useTpu deviceAssignment computationShape hostComputeCore:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "num_replicas" nameCStr:
        callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt numReplicas . toCArg]
    CString.with "topology" nameCStr:
        CString.with topology valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    CString.with "use_tpu" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useTpu then 1 else 0) . toCArg]
    CString.with "device_assignment" nameCStr:
        cvalues = deviceAssignment.map CInt64.fromInt
        Array CInt64 . with cvalues cvaluesArray:
            callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt deviceAssignment.length . toCArg]
    CString.with "computation_shape" nameCStr:
        cvalues = computationShape.map CInt64.fromInt
        Array CInt64 . with cvalues cvaluesArray:
            callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt computationShape.length . toCArg]
    CString.with "host_compute_core" nameCStr:
        len = hostComputeCore.length
        cValues = ManagedPointer (Pointer CInt64) . mallocElems len
        indexed = 0.upto (len - 1) . zip hostComputeCore
        indexed.each (idx, elem):
                cValues.moveElems idx . write (CString.fromText elem)
        callHandlingError "add_attr_string_list" None [attrList.toCArg, nameCStr.toCArg, cValues.toCArg, CUInt32.fromInt len . toCArg]
        0.upto (len - 1) . each (idx: cValues.moveElems idx . read . free)
    wrappers = makeOutputWrappers "TPUReplicateMetadata" [] [] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def batchMatrixTriangularSolveGen chosenName matrix rhs lower adjoint t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "lower" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if lower then 1 else 0) . toCArg]
    CString.with "adjoint" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if adjoint then 1 else 0) . toCArg]
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "BatchMatrixTriangularSolve" [matrix, rhs] [matrix.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def batchSelfAdjointEigGen chosenName input t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "BatchSelfAdjointEig" [input] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def choleskyGradGen chosenName l grad t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "CholeskyGrad" [l, grad] [l.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def fusedBatchNormGradGen chosenName yBackprop x scale reserveSpace1 reserveSpace2 t epsilon dataFormat isTraining:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "epsilon" nameCStr:
        callHandlingError "add_attr_float" None [attrList.toCArg, nameCStr.toCArg, CFloat.fromReal epsilon . toCArg]
    CString.with "data_format" nameCStr:
        CString.with dataFormat valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    CString.with "is_training" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if isTraining then 1 else 0) . toCArg]
    wrappers = makeOutputWrappers "FusedBatchNormGrad" [yBackprop, x, scale, reserveSpace1, reserveSpace2] [yBackprop.wrapper.typetag, yBackprop.wrapper.typetag, yBackprop.wrapper.typetag, yBackprop.wrapper.typetag, yBackprop.wrapper.typetag] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def cosGen chosenName x t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "Cos" [x] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def choleskyGen chosenName input t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "Cholesky" [input] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def sparseApplyFtrlV2Gen chosenName var accum linear grad indices lr l1 l2 l2Shrinkage lrPower t tindices useLocking:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "Tindices" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
    CString.with "use_locking" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useLocking then 1 else 0) . toCArg]
    wrappers = makeOutputWrappers "SparseApplyFtrlV2" [var, accum, linear, grad, indices, lr, l1, l2, l2Shrinkage, lrPower] [var.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def maxPoolGradV2Gen chosenName origInput origOutput grad ksize strides padding dataFormat t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "padding" nameCStr:
        CString.with padding valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    CString.with "data_format" nameCStr:
        CString.with dataFormat valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "MaxPoolGradV2" [origInput, origOutput, grad, ksize, strides] [origInput.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def readerNumRecordsProducedGen chosenName readerHandle:
    wrappers = makeOutputWrappers "ReaderNumRecordsProduced" [readerHandle] [Int64Type] attrList chosenName
    TFOutput wrappers.head.get

def matrixInverseGen chosenName input adjoint t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "adjoint" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if adjoint then 1 else 0) . toCArg]
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "MatrixInverse" [input] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def statelessTruncatedNormalGen chosenName shape seed dtype t tseed:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "dtype" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt dtype.num . toCArg]
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "Tseed" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tseed.num . toCArg]
    wrappers = makeOutputWrappers "StatelessTruncatedNormal" [shape, seed] [dtype] attrList chosenName
    TFOutput wrappers.head.get

def noOpGen chosenName:
    wrappers = makeOutputWrappers "NoOp" [] [] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def nonMaxSuppressionV4Gen chosenName boxes scores maxOutputSize iouThreshold scoreThreshold padToMaxOutputSize:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "pad_to_max_output_size" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if padToMaxOutputSize then 1 else 0) . toCArg]
    wrappers = makeOutputWrappers "NonMaxSuppressionV4" [boxes, scores, maxOutputSize, iouThreshold, scoreThreshold] [Int32Type, Int32Type] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def nonMaxSuppressionGen chosenName boxes scores maxOutputSize iouThreshold:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "iou_threshold" nameCStr:
        callHandlingError "add_attr_float" None [attrList.toCArg, nameCStr.toCArg, CFloat.fromReal iouThreshold . toCArg]
    wrappers = makeOutputWrappers "NonMaxSuppression" [boxes, scores, maxOutputSize] [Int32Type] attrList chosenName
    TFOutput wrappers.head.get

def nonMaxSuppressionWithOverlapsGen chosenName overlaps scores maxOutputSize overlapThreshold scoreThreshold:
    wrappers = makeOutputWrappers "NonMaxSuppressionWithOverlaps" [overlaps, scores, maxOutputSize, overlapThreshold, scoreThreshold] [Int32Type] attrList chosenName
    TFOutput wrappers.head.get

def computeAccidentalHitsGen chosenName trueClasses sampledCandidates numTrue seed seed2:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "num_true" nameCStr:
        callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt numTrue . toCArg]
    CString.with "seed" nameCStr:
        callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt seed . toCArg]
    CString.with "seed2" nameCStr:
        callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt seed2 . toCArg]
    wrappers = makeOutputWrappers "ComputeAccidentalHits" [trueClasses, sampledCandidates] [Int32Type, Int64Type, FloatType] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def cropAndResizeGradBoxesGen chosenName grads image boxes boxInd t method:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "method" nameCStr:
        CString.with method valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    wrappers = makeOutputWrappers "CropAndResizeGradBoxes" [grads, image, boxes, boxInd] [FloatType] attrList chosenName
    TFOutput wrappers.head.get

def extractGlimpseGen chosenName input size offsets centered normalized uniformNoise:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "centered" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if centered then 1 else 0) . toCArg]
    CString.with "normalized" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if normalized then 1 else 0) . toCArg]
    CString.with "uniform_noise" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if uniformNoise then 1 else 0) . toCArg]
    wrappers = makeOutputWrappers "ExtractGlimpse" [input, size, offsets] [FloatType] attrList chosenName
    TFOutput wrappers.head.get

def sparseSliceGradGen chosenName backpropValGrad inputIndices inputStart outputIndices t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "SparseSliceGrad" [backpropValGrad, inputIndices, inputStart, outputIndices] [backpropValGrad.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def batchSvdGen chosenName input computeUv fullMatrices t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "compute_uv" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if computeUv then 1 else 0) . toCArg]
    CString.with "full_matrices" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if fullMatrices then 1 else 0) . toCArg]
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "BatchSvd" [input] [input.wrapper.typetag, input.wrapper.typetag, input.wrapper.typetag] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def rGBToHSVGen chosenName images t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "RGBToHSV" [images] [images.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def decodeGifGen chosenName contents:
    wrappers = makeOutputWrappers "DecodeGif" [contents] [UInt8Type] attrList chosenName
    TFOutput wrappers.head.get

def decodePngGen chosenName contents channels dtype:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "channels" nameCStr:
        callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt channels . toCArg]
    CString.with "dtype" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt dtype.num . toCArg]
    wrappers = makeOutputWrappers "DecodePng" [contents] [dtype] attrList chosenName
    TFOutput wrappers.head.get

def adjustSaturationGen chosenName images scale:
    wrappers = makeOutputWrappers "AdjustSaturation" [images, scale] [FloatType] attrList chosenName
    TFOutput wrappers.head.get

def matrixSolveGen chosenName matrix rhs adjoint t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "adjoint" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if adjoint then 1 else 0) . toCArg]
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "MatrixSolve" [matrix, rhs] [matrix.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def softplusGradGen chosenName gradients features t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "SoftplusGrad" [gradients, features] [gradients.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def selfAdjointEigV2Gen chosenName input computeV t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "compute_v" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if computeV then 1 else 0) . toCArg]
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "SelfAdjointEigV2" [input] [input.wrapper.typetag, input.wrapper.typetag] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def decodeJpegGen chosenName contents channels ratio fancyUpscaling tryRecoverTruncated acceptableFraction dctMethod:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "channels" nameCStr:
        callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt channels . toCArg]
    CString.with "ratio" nameCStr:
        callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt ratio . toCArg]
    CString.with "fancy_upscaling" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if fancyUpscaling then 1 else 0) . toCArg]
    CString.with "try_recover_truncated" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if tryRecoverTruncated then 1 else 0) . toCArg]
    CString.with "acceptable_fraction" nameCStr:
        callHandlingError "add_attr_float" None [attrList.toCArg, nameCStr.toCArg, CFloat.fromReal acceptableFraction . toCArg]
    CString.with "dct_method" nameCStr:
        CString.with dctMethod valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    wrappers = makeOutputWrappers "DecodeJpeg" [contents] [UInt8Type] attrList chosenName
    TFOutput wrappers.head.get

def fakeParamGen chosenName dtype shape:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "dtype" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt dtype.num . toCArg]
    CString.with "shape" nameCStr:
        cdims = shape.map CInt64.fromInt
        Array CInt64 . with cdims cdimsArray:
            callHandlingError "add_attr_shape" None [attrList.toCArg, nameCStr.toCArg, cdimsArray.toCArg, CUInt32.fromInt shape.length . toCArg]
    wrappers = makeOutputWrappers "FakeParam" [] [dtype] attrList chosenName
    TFOutput wrappers.head.get

def resizeNearestNeighborGen chosenName images size t alignCorners:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "align_corners" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if alignCorners then 1 else 0) . toCArg]
    wrappers = makeOutputWrappers "ResizeNearestNeighbor" [images, size] [images.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def resizeBicubicGradGen chosenName grads originalImage t alignCorners:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "align_corners" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if alignCorners then 1 else 0) . toCArg]
    wrappers = makeOutputWrappers "ResizeBicubicGrad" [grads, originalImage] [originalImage.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def resizeBicubicGen chosenName images size t alignCorners:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "align_corners" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if alignCorners then 1 else 0) . toCArg]
    wrappers = makeOutputWrappers "ResizeBicubic" [images, size] [FloatType] attrList chosenName
    TFOutput wrappers.head.get

def log1pGen chosenName x t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "Log1p" [x] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def tPUCompilationResultGen chosenName:
    wrappers = makeOutputWrappers "TPUCompilationResult" [] [StringType] attrList chosenName
    TFOutput wrappers.head.get

def nonMaxSuppressionV2Gen chosenName boxes scores maxOutputSize iouThreshold:
    wrappers = makeOutputWrappers "NonMaxSuppressionV2" [boxes, scores, maxOutputSize, iouThreshold] [Int32Type] attrList chosenName
    TFOutput wrappers.head.get

def reshapeGen chosenName tensor shape t tshape:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "Tshape" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tshape.num . toCArg]
    wrappers = makeOutputWrappers "Reshape" [tensor, shape] [tensor.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def avgPool3DGen chosenName input ksize strides padding dataFormat t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "ksize" nameCStr:
        cvalues = ksize.map CInt64.fromInt
        Array CInt64 . with cvalues cvaluesArray:
            callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt ksize.length . toCArg]
    CString.with "strides" nameCStr:
        cvalues = strides.map CInt64.fromInt
        Array CInt64 . with cvalues cvaluesArray:
            callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
    CString.with "padding" nameCStr:
        CString.with padding valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    CString.with "data_format" nameCStr:
        CString.with dataFormat valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "AvgPool3D" [input] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def crossGen chosenName a b t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "Cross" [a, b] [a.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def tensorArrayUnpackGen chosenName handle value flowIn t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "TensorArrayUnpack" [handle, value, flowIn] [FloatType] attrList chosenName
    TFOutput wrappers.head.get

def sinhGen chosenName x t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "Sinh" [x] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def dilation2DGen chosenName input filter t strides rates padding:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "strides" nameCStr:
        cvalues = strides.map CInt64.fromInt
        Array CInt64 . with cvalues cvaluesArray:
            callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
    CString.with "rates" nameCStr:
        cvalues = rates.map CInt64.fromInt
        Array CInt64 . with cvalues cvaluesArray:
            callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt rates.length . toCArg]
    CString.with "padding" nameCStr:
        CString.with padding valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    wrappers = makeOutputWrappers "Dilation2D" [input, filter] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def tensorArrayConcatV2Gen chosenName handle flowIn dtype elementShapeExcept0:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "dtype" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt dtype.num . toCArg]
    CString.with "element_shape_except0" nameCStr:
        cdims = elementShapeExcept0.map CInt64.fromInt
        Array CInt64 . with cdims cdimsArray:
            callHandlingError "add_attr_shape" None [attrList.toCArg, nameCStr.toCArg, cdimsArray.toCArg, CUInt32.fromInt elementShapeExcept0.length . toCArg]
    wrappers = makeOutputWrappers "TensorArrayConcatV2" [handle, flowIn] [dtype, Int64Type] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def atan2Gen chosenName y x t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "Atan2" [y, x] [y.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def identityGen chosenName input t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "Identity" [input] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def adjustContrastv2Gen chosenName images contrastFactor:
    wrappers = makeOutputWrappers "AdjustContrastv2" [images, contrastFactor] [FloatType] attrList chosenName
    TFOutput wrappers.head.get

def nonMaxSuppressionV3Gen chosenName boxes scores maxOutputSize iouThreshold scoreThreshold:
    wrappers = makeOutputWrappers "NonMaxSuppressionV3" [boxes, scores, maxOutputSize, iouThreshold, scoreThreshold] [Int32Type] attrList chosenName
    TFOutput wrappers.head.get

def batchNormWithGlobalNormalizationGradGen chosenName t m v gamma backprop t varianceEpsilon scaleAfterNormalization:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "variance_epsilon" nameCStr:
        callHandlingError "add_attr_float" None [attrList.toCArg, nameCStr.toCArg, CFloat.fromReal varianceEpsilon . toCArg]
    CString.with "scale_after_normalization" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if scaleAfterNormalization then 1 else 0) . toCArg]
    wrappers = makeOutputWrappers "BatchNormWithGlobalNormalizationGrad" [t, m, v, gamma, backprop] [t.wrapper.typetag, t.wrapper.typetag, t.wrapper.typetag, t.wrapper.typetag, t.wrapper.typetag] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def logMatrixDeterminantGen chosenName input t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "LogMatrixDeterminant" [input] [input.wrapper.typetag, input.wrapper.typetag] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def seluGen chosenName features t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "Selu" [features] [features.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def setSizeGen chosenName setIndices setValues setShape validateIndices t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "validate_indices" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if validateIndices then 1 else 0) . toCArg]
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "SetSize" [setIndices, setValues, setShape] [Int32Type] attrList chosenName
    TFOutput wrappers.head.get

def substrGen chosenName input pos len t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "Substr" [input, pos, len] [StringType] attrList chosenName
    TFOutput wrappers.head.get

def debugNumericSummaryGen chosenName input t deviceName tensorName debugUrls lowerBound upperBound muteIfHealthy gatedGrpc:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "device_name" nameCStr:
        CString.with deviceName valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    CString.with "tensor_name" nameCStr:
        CString.with tensorName valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    CString.with "debug_urls" nameCStr:
        len = debugUrls.length
        cValues = ManagedPointer (Pointer CInt64) . mallocElems len
        indexed = 0.upto (len - 1) . zip debugUrls
        indexed.each (idx, elem):
                cValues.moveElems idx . write (CString.fromText elem)
        callHandlingError "add_attr_string_list" None [attrList.toCArg, nameCStr.toCArg, cValues.toCArg, CUInt32.fromInt len . toCArg]
        0.upto (len - 1) . each (idx: cValues.moveElems idx . read . free)
    CString.with "lower_bound" nameCStr:
        callHandlingError "add_attr_float" None [attrList.toCArg, nameCStr.toCArg, CFloat.fromReal lowerBound . toCArg]
    CString.with "upper_bound" nameCStr:
        callHandlingError "add_attr_float" None [attrList.toCArg, nameCStr.toCArg, CFloat.fromReal upperBound . toCArg]
    CString.with "mute_if_healthy" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if muteIfHealthy then 1 else 0) . toCArg]
    CString.with "gated_grpc" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if gatedGrpc then 1 else 0) . toCArg]
    wrappers = makeOutputWrappers "DebugNumericSummary" [input] [DoubleType] attrList chosenName
    TFOutput wrappers.head.get

def fusedBatchNormV2Gen chosenName x scale offset mean variance t u epsilon dataFormat isTraining:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "U" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt u.num . toCArg]
    CString.with "epsilon" nameCStr:
        callHandlingError "add_attr_float" None [attrList.toCArg, nameCStr.toCArg, CFloat.fromReal epsilon . toCArg]
    CString.with "data_format" nameCStr:
        CString.with dataFormat valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    CString.with "is_training" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if isTraining then 1 else 0) . toCArg]
    wrappers = makeOutputWrappers "FusedBatchNormV2" [x, scale, offset, mean, variance] [x.wrapper.typetag, scale.wrapper.typetag, scale.wrapper.typetag, scale.wrapper.typetag, scale.wrapper.typetag] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def debugIdentityGen chosenName input t deviceName tensorName debugUrls gatedGrpc:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "device_name" nameCStr:
        CString.with deviceName valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    CString.with "tensor_name" nameCStr:
        CString.with tensorName valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    CString.with "debug_urls" nameCStr:
        len = debugUrls.length
        cValues = ManagedPointer (Pointer CInt64) . mallocElems len
        indexed = 0.upto (len - 1) . zip debugUrls
        indexed.each (idx, elem):
                cValues.moveElems idx . write (CString.fromText elem)
        callHandlingError "add_attr_string_list" None [attrList.toCArg, nameCStr.toCArg, cValues.toCArg, CUInt32.fromInt len . toCArg]
        0.upto (len - 1) . each (idx: cValues.moveElems idx . read . free)
    CString.with "gated_grpc" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if gatedGrpc then 1 else 0) . toCArg]
    wrappers = makeOutputWrappers "DebugIdentity" [input] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def accumulatorTakeGradientGen chosenName handle numRequired dtype:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "dtype" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt dtype.num . toCArg]
    wrappers = makeOutputWrappers "AccumulatorTakeGradient" [handle, numRequired] [dtype] attrList chosenName
    TFOutput wrappers.head.get

def tensorSummaryV2Gen chosenName tag tensor serializedSummaryMetadata t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "TensorSummaryV2" [tag, tensor, serializedSummaryMetadata] [StringType] attrList chosenName
    TFOutput wrappers.head.get

def tensorArrayConcatGen chosenName handle flowIn dtype elementShapeExcept0:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "dtype" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt dtype.num . toCArg]
    CString.with "element_shape_except0" nameCStr:
        cdims = elementShapeExcept0.map CInt64.fromInt
        Array CInt64 . with cdims cdimsArray:
            callHandlingError "add_attr_shape" None [attrList.toCArg, nameCStr.toCArg, cdimsArray.toCArg, CUInt32.fromInt elementShapeExcept0.length . toCArg]
    wrappers = makeOutputWrappers "TensorArrayConcat" [handle, flowIn] [dtype, Int64Type] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def reciprocalGen chosenName x t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "Reciprocal" [x] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def qrGen chosenName input fullMatrices t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "full_matrices" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if fullMatrices then 1 else 0) . toCArg]
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "Qr" [input] [input.wrapper.typetag, input.wrapper.typetag] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def audioSummaryGen chosenName tag tensor sampleRate maxOutputs:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "sample_rate" nameCStr:
        callHandlingError "add_attr_float" None [attrList.toCArg, nameCStr.toCArg, CFloat.fromReal sampleRate . toCArg]
    CString.with "max_outputs" nameCStr:
        callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt maxOutputs . toCArg]
    wrappers = makeOutputWrappers "AudioSummary" [tag, tensor] [StringType] attrList chosenName
    TFOutput wrappers.head.get

def sparseReduceMaxSparseGen chosenName inputIndices inputValues inputShape reductionAxes keepDims t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "keep_dims" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if keepDims then 1 else 0) . toCArg]
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "SparseReduceMaxSparse" [inputIndices, inputValues, inputShape, reductionAxes] [Int64Type, inputValues.wrapper.typetag, Int64Type] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def barrierIncompleteSizeGen chosenName handle:
    wrappers = makeOutputWrappers "BarrierIncompleteSize" [handle] [Int32Type] attrList chosenName
    TFOutput wrappers.head.get

def segmentSumGen chosenName data segmentIds t tindices:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "Tindices" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
    wrappers = makeOutputWrappers "SegmentSum" [data, segmentIds] [data.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def roundGen chosenName x t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "Round" [x] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def matrixSetDiagGen chosenName input diagonal t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "MatrixSetDiag" [input, diagonal] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def sparseSparseMaximumGen chosenName aIndices aValues aShape bIndices bValues bShape t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "SparseSparseMaximum" [aIndices, aValues, aShape, bIndices, bValues, bShape] [Int64Type, aValues.wrapper.typetag] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def matrixExponentialGen chosenName input t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "MatrixExponential" [input] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def biasAddGradGen chosenName outBackprop t dataFormat:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "data_format" nameCStr:
        CString.with dataFormat valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    wrappers = makeOutputWrappers "BiasAddGrad" [outBackprop] [outBackprop.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def queueSizeGen chosenName handle:
    wrappers = makeOutputWrappers "QueueSize" [handle] [Int32Type] attrList chosenName
    TFOutput wrappers.head.get

def sparseDenseCwiseAddGen chosenName spIndices spValues spShape dense t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "SparseDenseCwiseAdd" [spIndices, spValues, spShape, dense] [spValues.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def lookupTableFindGen chosenName tableHandle keys defaultValue tin tout:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "Tin" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tin.num . toCArg]
    CString.with "Tout" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tout.num . toCArg]
    wrappers = makeOutputWrappers "LookupTableFind" [tableHandle, keys, defaultValue] [defaultValue.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def ensureShapeGen chosenName input shape t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "shape" nameCStr:
        cdims = shape.map CInt64.fromInt
        Array CInt64 . with cdims cdimsArray:
            callHandlingError "add_attr_shape" None [attrList.toCArg, nameCStr.toCArg, cdimsArray.toCArg, CUInt32.fromInt shape.length . toCArg]
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "EnsureShape" [input] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def stackCloseGen chosenName handle:
    wrappers = makeOutputWrappers "StackClose" [handle] [] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def readerSerializeStateGen chosenName readerHandle:
    wrappers = makeOutputWrappers "ReaderSerializeState" [readerHandle] [StringType] attrList chosenName
    TFOutput wrappers.head.get

def tanGen chosenName x t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "Tan" [x] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def decodeBmpGen chosenName contents channels:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "channels" nameCStr:
        callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt channels . toCArg]
    wrappers = makeOutputWrappers "DecodeBmp" [contents] [UInt8Type] attrList chosenName
    TFOutput wrappers.head.get

def rsqrtGen chosenName x t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "Rsqrt" [x] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def cTCLossGen chosenName inputs labelsIndices labelsValues sequenceLength preprocessCollapseRepeated ctcMergeRepeated ignoreLongerOutputsThanInputs:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "preprocess_collapse_repeated" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if preprocessCollapseRepeated then 1 else 0) . toCArg]
    CString.with "ctc_merge_repeated" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if ctcMergeRepeated then 1 else 0) . toCArg]
    CString.with "ignore_longer_outputs_than_inputs" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if ignoreLongerOutputsThanInputs then 1 else 0) . toCArg]
    wrappers = makeOutputWrappers "CTCLoss" [inputs, labelsIndices, labelsValues, sequenceLength] [FloatType, FloatType] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def quantizedResizeBilinearGen chosenName images size min max t alignCorners:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "align_corners" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if alignCorners then 1 else 0) . toCArg]
    wrappers = makeOutputWrappers "QuantizedResizeBilinear" [images, size, min, max] [images.wrapper.typetag, FloatType, FloatType] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def stackPopGen chosenName handle elemType:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "elem_type" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt elemType.num . toCArg]
    wrappers = makeOutputWrappers "StackPop" [handle] [elemType] attrList chosenName
    TFOutput wrappers.head.get

def svdGen chosenName input computeUv fullMatrices t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "compute_uv" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if computeUv then 1 else 0) . toCArg]
    CString.with "full_matrices" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if fullMatrices then 1 else 0) . toCArg]
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "Svd" [input] [input.wrapper.typetag, input.wrapper.typetag, input.wrapper.typetag] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def batchSelfAdjointEigV2Gen chosenName input computeV t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "compute_v" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if computeV then 1 else 0) . toCArg]
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "BatchSelfAdjointEigV2" [input] [input.wrapper.typetag, input.wrapper.typetag] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def invGen chosenName x t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "Inv" [x] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def populationCountGen chosenName x t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "PopulationCount" [x] [UInt8Type] attrList chosenName
    TFOutput wrappers.head.get

def decodeAndCropJpegGen chosenName contents cropWindow channels ratio fancyUpscaling tryRecoverTruncated acceptableFraction dctMethod:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "channels" nameCStr:
        callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt channels . toCArg]
    CString.with "ratio" nameCStr:
        callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt ratio . toCArg]
    CString.with "fancy_upscaling" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if fancyUpscaling then 1 else 0) . toCArg]
    CString.with "try_recover_truncated" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if tryRecoverTruncated then 1 else 0) . toCArg]
    CString.with "acceptable_fraction" nameCStr:
        callHandlingError "add_attr_float" None [attrList.toCArg, nameCStr.toCArg, CFloat.fromReal acceptableFraction . toCArg]
    CString.with "dct_method" nameCStr:
        CString.with dctMethod valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    wrappers = makeOutputWrappers "DecodeAndCropJpeg" [contents, cropWindow] [UInt8Type] attrList chosenName
    TFOutput wrappers.head.get

def reluGen chosenName features t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "Relu" [features] [features.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def loopCondGen chosenName input:
    wrappers = makeOutputWrappers "LoopCond" [input] [BoolType] attrList chosenName
    TFOutput wrappers.head.get

def squaredDifferenceGen chosenName x y t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "SquaredDifference" [x, y] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def exitGen chosenName data t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "Exit" [data] [data.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def cropAndResizeGen chosenName image boxes boxInd cropSize t method extrapolationValue:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "method" nameCStr:
        CString.with method valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    CString.with "extrapolation_value" nameCStr:
        callHandlingError "add_attr_float" None [attrList.toCArg, nameCStr.toCArg, CFloat.fromReal extrapolationValue . toCArg]
    wrappers = makeOutputWrappers "CropAndResize" [image, boxes, boxInd, cropSize] [FloatType] attrList chosenName
    TFOutput wrappers.head.get

def refEnterGen chosenName data t frameName isConstant parallelIterations:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "frame_name" nameCStr:
        CString.with frameName valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    CString.with "is_constant" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if isConstant then 1 else 0) . toCArg]
    CString.with "parallel_iterations" nameCStr:
        callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt parallelIterations . toCArg]
    wrappers = makeOutputWrappers "RefEnter" [data] [data.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def shardedFilespecGen chosenName basename numShards:
    wrappers = makeOutputWrappers "ShardedFilespec" [basename, numShards] [StringType] attrList chosenName
    TFOutput wrappers.head.get

def extractJpegShapeGen chosenName contents outputType:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "output_type" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt outputType.num . toCArg]
    wrappers = makeOutputWrappers "ExtractJpegShape" [contents] [outputType] attrList chosenName
    TFOutput wrappers.head.get

def batchMatrixInverseGen chosenName input adjoint t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "adjoint" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if adjoint then 1 else 0) . toCArg]
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "BatchMatrixInverse" [input] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def tensorArraySplitGen chosenName handle value lengths flowIn t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "TensorArraySplit" [handle, value, lengths, flowIn] [FloatType] attrList chosenName
    TFOutput wrappers.head.get

def switchGen chosenName data pred t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "Switch" [data, pred] [data.wrapper.typetag, data.wrapper.typetag] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def shardedFilenameGen chosenName basename shard numShards:
    wrappers = makeOutputWrappers "ShardedFilename" [basename, shard, numShards] [StringType] attrList chosenName
    TFOutput wrappers.head.get

def denseToDenseSetOperationGen chosenName set1 set2 setOperation validateIndices t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "set_operation" nameCStr:
        CString.with setOperation valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    CString.with "validate_indices" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if validateIndices then 1 else 0) . toCArg]
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "DenseToDenseSetOperation" [set1, set2] [Int64Type, set1.wrapper.typetag, Int64Type] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def fusedPadConv2DGen chosenName input paddings filter t mode strides padding:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "mode" nameCStr:
        CString.with mode valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    CString.with "strides" nameCStr:
        cvalues = strides.map CInt64.fromInt
        Array CInt64 . with cvalues cvaluesArray:
            callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
    CString.with "padding" nameCStr:
        CString.with padding valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    wrappers = makeOutputWrappers "FusedPadConv2D" [input, paddings, filter] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def conv2DBackpropInputGen chosenName inputSizes filter outBackprop t strides useCudnnOnGpu padding dataFormat dilations:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "strides" nameCStr:
        cvalues = strides.map CInt64.fromInt
        Array CInt64 . with cvalues cvaluesArray:
            callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
    CString.with "use_cudnn_on_gpu" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useCudnnOnGpu then 1 else 0) . toCArg]
    CString.with "padding" nameCStr:
        CString.with padding valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    CString.with "data_format" nameCStr:
        CString.with dataFormat valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    CString.with "dilations" nameCStr:
        cvalues = dilations.map CInt64.fromInt
        Array CInt64 . with cvalues cvaluesArray:
            callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt dilations.length . toCArg]
    wrappers = makeOutputWrappers "Conv2DBackpropInput" [inputSizes, filter, outBackprop] [filter.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def equalGen chosenName x y t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "Equal" [x, y] [BoolType] attrList chosenName
    TFOutput wrappers.head.get

def tensorArrayGatherV2Gen chosenName handle indices flowIn dtype elementShape:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "dtype" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt dtype.num . toCArg]
    CString.with "element_shape" nameCStr:
        cdims = elementShape.map CInt64.fromInt
        Array CInt64 . with cdims cdimsArray:
            callHandlingError "add_attr_shape" None [attrList.toCArg, nameCStr.toCArg, cdimsArray.toCArg, CUInt32.fromInt elementShape.length . toCArg]
    wrappers = makeOutputWrappers "TensorArrayGatherV2" [handle, indices, flowIn] [dtype] attrList chosenName
    TFOutput wrappers.head.get

def histogramSummaryGen chosenName tag values t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "HistogramSummary" [tag, values] [StringType] attrList chosenName
    TFOutput wrappers.head.get

def tPUEmbeddingActivationsGen chosenName embeddingVariable slicedActivations tableId lookupId:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "table_id" nameCStr:
        callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt tableId . toCArg]
    CString.with "lookup_id" nameCStr:
        callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt lookupId . toCArg]
    wrappers = makeOutputWrappers "TPUEmbeddingActivations" [embeddingVariable, slicedActivations] [FloatType] attrList chosenName
    TFOutput wrappers.head.get

def refSwitchGen chosenName data pred t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "RefSwitch" [data, pred] [data.wrapper.typetag, data.wrapper.typetag] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def sparseTensorDenseMatMulGen chosenName aIndices aValues aShape b t tindices adjointA adjointB:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "Tindices" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
    CString.with "adjoint_a" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if adjointA then 1 else 0) . toCArg]
    CString.with "adjoint_b" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if adjointB then 1 else 0) . toCArg]
    wrappers = makeOutputWrappers "SparseTensorDenseMatMul" [aIndices, aValues, aShape, b] [aValues.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def segmentProdGen chosenName data segmentIds t tindices:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "Tindices" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
    wrappers = makeOutputWrappers "SegmentProd" [data, segmentIds] [data.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def tensorArrayGatherGen chosenName handle indices flowIn dtype elementShape:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "dtype" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt dtype.num . toCArg]
    CString.with "element_shape" nameCStr:
        cdims = elementShape.map CInt64.fromInt
        Array CInt64 . with cdims cdimsArray:
            callHandlingError "add_attr_shape" None [attrList.toCArg, nameCStr.toCArg, cdimsArray.toCArg, CUInt32.fromInt elementShape.length . toCArg]
    wrappers = makeOutputWrappers "TensorArrayGather" [handle, indices, flowIn] [dtype] attrList chosenName
    TFOutput wrappers.head.get

def batchCholeskyGradGen chosenName l grad t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "BatchCholeskyGrad" [l, grad] [l.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def generateBigQueryReaderPartitionsGen chosenName projectId datasetId tableId columns timestampMillis numPartitions testEndPoint:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "project_id" nameCStr:
        CString.with projectId valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    CString.with "dataset_id" nameCStr:
        CString.with datasetId valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    CString.with "table_id" nameCStr:
        CString.with tableId valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    CString.with "columns" nameCStr:
        len = columns.length
        cValues = ManagedPointer (Pointer CInt64) . mallocElems len
        indexed = 0.upto (len - 1) . zip columns
        indexed.each (idx, elem):
                cValues.moveElems idx . write (CString.fromText elem)
        callHandlingError "add_attr_string_list" None [attrList.toCArg, nameCStr.toCArg, cValues.toCArg, CUInt32.fromInt len . toCArg]
        0.upto (len - 1) . each (idx: cValues.moveElems idx . read . free)
    CString.with "timestamp_millis" nameCStr:
        callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt timestampMillis . toCArg]
    CString.with "num_partitions" nameCStr:
        callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt numPartitions . toCArg]
    CString.with "test_end_point" nameCStr:
        CString.with testEndPoint valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    wrappers = makeOutputWrappers "GenerateBigQueryReaderPartitions" [] [StringType] attrList chosenName
    TFOutput wrappers.head.get

def scatterNdAddGen chosenName ref indices updates t tindices useLocking:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "Tindices" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
    CString.with "use_locking" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useLocking then 1 else 0) . toCArg]
    wrappers = makeOutputWrappers "ScatterNdAdd" [ref, indices, updates] [ref.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def assignGen chosenName ref value t validateShape useLocking:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "validate_shape" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if validateShape then 1 else 0) . toCArg]
    CString.with "use_locking" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useLocking then 1 else 0) . toCArg]
    wrappers = makeOutputWrappers "Assign" [ref, value] [ref.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def argMaxGen chosenName input dimension t tidx outputType:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "Tidx" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tidx.num . toCArg]
    CString.with "output_type" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt outputType.num . toCArg]
    wrappers = makeOutputWrappers "ArgMax" [input, dimension] [outputType] attrList chosenName
    TFOutput wrappers.head.get

def readerResetGen chosenName readerHandle:
    wrappers = makeOutputWrappers "ReaderReset" [readerHandle] [] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def digammaGen chosenName x t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "Digamma" [x] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def lookupTableExportGen chosenName tableHandle tkeys tvalues:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "Tkeys" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tkeys.num . toCArg]
    CString.with "Tvalues" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tvalues.num . toCArg]
    wrappers = makeOutputWrappers "LookupTableExport" [tableHandle] [tkeys, tvalues] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def debugGradientRefIdentityGen chosenName input t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "DebugGradientRefIdentity" [input] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def erfGen chosenName x t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "Erf" [x] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def floorGen chosenName x t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "Floor" [x] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def resizeBilinearGen chosenName images size t alignCorners:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "align_corners" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if alignCorners then 1 else 0) . toCArg]
    wrappers = makeOutputWrappers "ResizeBilinear" [images, size] [FloatType] attrList chosenName
    TFOutput wrappers.head.get

def copyHostGen chosenName input t tensorName debugOpsSpec:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "tensor_name" nameCStr:
        CString.with tensorName valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    CString.with "debug_ops_spec" nameCStr:
        len = debugOpsSpec.length
        cValues = ManagedPointer (Pointer CInt64) . mallocElems len
        indexed = 0.upto (len - 1) . zip debugOpsSpec
        indexed.each (idx, elem):
                cValues.moveElems idx . write (CString.fromText elem)
        callHandlingError "add_attr_string_list" None [attrList.toCArg, nameCStr.toCArg, cValues.toCArg, CUInt32.fromInt len . toCArg]
        0.upto (len - 1) . each (idx: cValues.moveElems idx . read . free)
    wrappers = makeOutputWrappers "CopyHost" [input] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def gcsConfigureBlockCacheGen chosenName maxCacheSize blockSize maxStaleness:
    wrappers = makeOutputWrappers "GcsConfigureBlockCache" [maxCacheSize, blockSize, maxStaleness] [] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def serializeManySparseGen chosenName sparseIndices sparseValues sparseShape t outType:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "out_type" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt outType.num . toCArg]
    wrappers = makeOutputWrappers "SerializeManySparse" [sparseIndices, sparseValues, sparseShape] [outType] attrList chosenName
    TFOutput wrappers.head.get

def acoshGen chosenName x t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "Acosh" [x] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def isFiniteGen chosenName x t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "IsFinite" [x] [BoolType] attrList chosenName
    TFOutput wrappers.head.get

def batchMatrixSolveLsGen chosenName matrix rhs l2Regularizer t fast:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "fast" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if fast then 1 else 0) . toCArg]
    wrappers = makeOutputWrappers "BatchMatrixSolveLs" [matrix, rhs, l2Regularizer] [matrix.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def debugGradientIdentityGen chosenName input t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "DebugGradientIdentity" [input] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def isNanGen chosenName x t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "IsNan" [x] [BoolType] attrList chosenName
    TFOutput wrappers.head.get

def realDivGen chosenName x y t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "RealDiv" [x, y] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def lgammaGen chosenName x t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "Lgamma" [x] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def scatterNdGen chosenName indices updates shape t tindices:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "Tindices" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
    wrappers = makeOutputWrappers "ScatterNd" [indices, updates, shape] [updates.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def allGen chosenName input reductionIndices keepDims tidx:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "keep_dims" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if keepDims then 1 else 0) . toCArg]
    CString.with "Tidx" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tidx.num . toCArg]
    wrappers = makeOutputWrappers "All" [input, reductionIndices] [BoolType] attrList chosenName
    TFOutput wrappers.head.get

def selfAdjointEigGen chosenName input t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "SelfAdjointEig" [input] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def conv3DBackpropInputGen chosenName input filter outBackprop t strides padding dilations:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "strides" nameCStr:
        cvalues = strides.map CInt64.fromInt
        Array CInt64 . with cvalues cvaluesArray:
            callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
    CString.with "padding" nameCStr:
        CString.with padding valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    CString.with "dilations" nameCStr:
        cvalues = dilations.map CInt64.fromInt
        Array CInt64 . with cvalues cvaluesArray:
            callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt dilations.length . toCArg]
    wrappers = makeOutputWrappers "Conv3DBackpropInput" [input, filter, outBackprop] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def stackPushGen chosenName handle elem t swapMemory:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "swap_memory" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if swapMemory then 1 else 0) . toCArg]
    wrappers = makeOutputWrappers "StackPush" [handle, elem] [elem.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def maxPool3DGen chosenName input ksize strides padding dataFormat t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "ksize" nameCStr:
        cvalues = ksize.map CInt64.fromInt
        Array CInt64 . with cvalues cvaluesArray:
            callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt ksize.length . toCArg]
    CString.with "strides" nameCStr:
        cvalues = strides.map CInt64.fromInt
        Array CInt64 . with cvalues cvaluesArray:
            callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
    CString.with "padding" nameCStr:
        CString.with padding valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    CString.with "data_format" nameCStr:
        CString.with dataFormat valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "MaxPool3D" [input] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def applyGradientDescentGen chosenName var alpha delta t useLocking:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "use_locking" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useLocking then 1 else 0) . toCArg]
    wrappers = makeOutputWrappers "ApplyGradientDescent" [var, alpha, delta] [var.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def resizeAreaGen chosenName images size t alignCorners:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "align_corners" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if alignCorners then 1 else 0) . toCArg]
    wrappers = makeOutputWrappers "ResizeArea" [images, size] [FloatType] attrList chosenName
    TFOutput wrappers.head.get

def stringToHashBucketGen chosenName stringTensor numBuckets:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "num_buckets" nameCStr:
        callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt numBuckets . toCArg]
    wrappers = makeOutputWrappers "StringToHashBucket" [stringTensor] [Int64Type] attrList chosenName
    TFOutput wrappers.head.get

def applyAdagradDAGen chosenName var gradientAccumulator gradientSquaredAccumulator grad lr l1 l2 globalStep t useLocking:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "use_locking" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useLocking then 1 else 0) . toCArg]
    wrappers = makeOutputWrappers "ApplyAdagradDA" [var, gradientAccumulator, gradientSquaredAccumulator, grad, lr, l1, l2, globalStep] [var.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def igammaGradAGen chosenName a x t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "IgammaGradA" [a, x] [a.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def sparseSegmentMeanGradGen chosenName grad indices segmentIds outputDim0 t tidx:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "Tidx" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tidx.num . toCArg]
    wrappers = makeOutputWrappers "SparseSegmentMeanGrad" [grad, indices, segmentIds, outputDim0] [grad.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def cudnnRNNParamsSizeGen chosenName numLayers numUnits inputSize t s rnnMode inputMode direction dropout seed seed2:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "S" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt s.num . toCArg]
    CString.with "rnn_mode" nameCStr:
        CString.with rnnMode valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    CString.with "input_mode" nameCStr:
        CString.with inputMode valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    CString.with "direction" nameCStr:
        CString.with direction valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    CString.with "dropout" nameCStr:
        callHandlingError "add_attr_float" None [attrList.toCArg, nameCStr.toCArg, CFloat.fromReal dropout . toCArg]
    CString.with "seed" nameCStr:
        callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt seed . toCArg]
    CString.with "seed2" nameCStr:
        callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt seed2 . toCArg]
    wrappers = makeOutputWrappers "CudnnRNNParamsSize" [numLayers, numUnits, inputSize] [s] attrList chosenName
    TFOutput wrappers.head.get

def queueIsClosedGen chosenName handle:
    wrappers = makeOutputWrappers "QueueIsClosed" [handle] [BoolType] attrList chosenName
    TFOutput wrappers.head.get

def compareAndBitpackGen chosenName input threshold t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "CompareAndBitpack" [input, threshold] [UInt8Type] attrList chosenName
    TFOutput wrappers.head.get

def conv3DBackpropInputV2Gen chosenName inputSizes filter outBackprop t strides padding dataFormat dilations tshape:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "strides" nameCStr:
        cvalues = strides.map CInt64.fromInt
        Array CInt64 . with cvalues cvaluesArray:
            callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
    CString.with "padding" nameCStr:
        CString.with padding valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    CString.with "data_format" nameCStr:
        CString.with dataFormat valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    CString.with "dilations" nameCStr:
        cvalues = dilations.map CInt64.fromInt
        Array CInt64 . with cvalues cvaluesArray:
            callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt dilations.length . toCArg]
    CString.with "Tshape" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tshape.num . toCArg]
    wrappers = makeOutputWrappers "Conv3DBackpropInputV2" [inputSizes, filter, outBackprop] [filter.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def depthToSpaceGen chosenName input t blockSize dataFormat:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "block_size" nameCStr:
        callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt blockSize . toCArg]
    CString.with "data_format" nameCStr:
        CString.with dataFormat valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    wrappers = makeOutputWrappers "DepthToSpace" [input] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def adjustHueGen chosenName images delta:
    wrappers = makeOutputWrappers "AdjustHue" [images, delta] [FloatType] attrList chosenName
    TFOutput wrappers.head.get

def tensorArrayWriteGen chosenName handle index value flowIn t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "TensorArrayWrite" [handle, index, value, flowIn] [FloatType] attrList chosenName
    TFOutput wrappers.head.get

def tensorArrayWriteV2Gen chosenName handle index value flowIn t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "TensorArrayWriteV2" [handle, index, value, flowIn] [FloatType] attrList chosenName
    TFOutput wrappers.head.get

def matrixTriangularSolveGen chosenName matrix rhs lower adjoint t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "lower" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if lower then 1 else 0) . toCArg]
    CString.with "adjoint" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if adjoint then 1 else 0) . toCArg]
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "MatrixTriangularSolve" [matrix, rhs] [matrix.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def barrierCloseGen chosenName handle cancelPendingEnqueues:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "cancel_pending_enqueues" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if cancelPendingEnqueues then 1 else 0) . toCArg]
    wrappers = makeOutputWrappers "BarrierClose" [handle] [] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def truncateDivGen chosenName x y t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "TruncateDiv" [x, y] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def scatterUpdateGen chosenName ref indices updates t tindices useLocking:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "Tindices" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
    CString.with "use_locking" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useLocking then 1 else 0) . toCArg]
    wrappers = makeOutputWrappers "ScatterUpdate" [ref, indices, updates] [ref.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def cTCGreedyDecoderGen chosenName inputs sequenceLength mergeRepeated:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "merge_repeated" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if mergeRepeated then 1 else 0) . toCArg]
    wrappers = makeOutputWrappers "CTCGreedyDecoder" [inputs, sequenceLength] [Int64Type, Int64Type, Int64Type, FloatType] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def padV2Gen chosenName input paddings constantValues t tpaddings:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "Tpaddings" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tpaddings.num . toCArg]
    wrappers = makeOutputWrappers "PadV2" [input, paddings, constantValues] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def mfccGen chosenName spectrogram sampleRate upperFrequencyLimit lowerFrequencyLimit filterbankChannelCount dctCoefficientCount:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "upper_frequency_limit" nameCStr:
        callHandlingError "add_attr_float" None [attrList.toCArg, nameCStr.toCArg, CFloat.fromReal upperFrequencyLimit . toCArg]
    CString.with "lower_frequency_limit" nameCStr:
        callHandlingError "add_attr_float" None [attrList.toCArg, nameCStr.toCArg, CFloat.fromReal lowerFrequencyLimit . toCArg]
    CString.with "filterbank_channel_count" nameCStr:
        callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt filterbankChannelCount . toCArg]
    CString.with "dct_coefficient_count" nameCStr:
        callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt dctCoefficientCount . toCArg]
    wrappers = makeOutputWrappers "Mfcc" [spectrogram, sampleRate] [FloatType] attrList chosenName
    TFOutput wrappers.head.get

def decodeWavGen chosenName contents desiredChannels desiredSamples:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "desired_channels" nameCStr:
        callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt desiredChannels . toCArg]
    CString.with "desired_samples" nameCStr:
        callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt desiredSamples . toCArg]
    wrappers = makeOutputWrappers "DecodeWav" [contents] [FloatType, Int32Type] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def uniqueGen chosenName x t outIdx:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "out_idx" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt outIdx.num . toCArg]
    wrappers = makeOutputWrappers "Unique" [x] [x.wrapper.typetag, outIdx] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def spaceToBatchGen chosenName input paddings t tpaddings blockSize:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "Tpaddings" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tpaddings.num . toCArg]
    CString.with "block_size" nameCStr:
        callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt blockSize . toCArg]
    wrappers = makeOutputWrappers "SpaceToBatch" [input, paddings] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def unbatchGen chosenName batchedTensor batchIndex id timeoutMicros container sharedName t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "timeout_micros" nameCStr:
        callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt timeoutMicros . toCArg]
    CString.with "container" nameCStr:
        CString.with container valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    CString.with "shared_name" nameCStr:
        CString.with sharedName valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "Unbatch" [batchedTensor, batchIndex, id] [batchedTensor.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def countUpToGen chosenName ref limit t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "limit" nameCStr:
        callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt limit . toCArg]
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "CountUpTo" [ref] [ref.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def rollGen chosenName input shift axis t tshift taxis:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "Tshift" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tshift.num . toCArg]
    CString.with "Taxis" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt taxis.num . toCArg]
    wrappers = makeOutputWrappers "Roll" [input, shift, axis] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def adjustContrastGen chosenName images contrastFactor minValue maxValue t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "AdjustContrast" [images, contrastFactor, minValue, maxValue] [FloatType] attrList chosenName
    TFOutput wrappers.head.get

def audioSpectrogramGen chosenName input windowSize stride magnitudeSquared:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "window_size" nameCStr:
        callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt windowSize . toCArg]
    CString.with "stride" nameCStr:
        callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt stride . toCArg]
    CString.with "magnitude_squared" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if magnitudeSquared then 1 else 0) . toCArg]
    wrappers = makeOutputWrappers "AudioSpectrogram" [input] [FloatType] attrList chosenName
    TFOutput wrappers.head.get

def invGradGen chosenName y dy t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "InvGrad" [y, dy] [y.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def stridedSliceGen chosenName input begin end strides t index beginMask endMask ellipsisMask newAxisMask shrinkAxisMask:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "Index" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt index.num . toCArg]
    CString.with "begin_mask" nameCStr:
        callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt beginMask . toCArg]
    CString.with "end_mask" nameCStr:
        callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt endMask . toCArg]
    CString.with "ellipsis_mask" nameCStr:
        callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt ellipsisMask . toCArg]
    CString.with "new_axis_mask" nameCStr:
        callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt newAxisMask . toCArg]
    CString.with "shrink_axis_mask" nameCStr:
        callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt shrinkAxisMask . toCArg]
    wrappers = makeOutputWrappers "StridedSlice" [input, begin, end, strides] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def logicalNotGen chosenName x:
    wrappers = makeOutputWrappers "LogicalNot" [x] [BoolType] attrList chosenName
    TFOutput wrappers.head.get

def readerReadGen chosenName readerHandle queueHandle:
    wrappers = makeOutputWrappers "ReaderRead" [readerHandle, queueHandle] [StringType, StringType] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def readerRestoreStateGen chosenName readerHandle state:
    wrappers = makeOutputWrappers "ReaderRestoreState" [readerHandle, state] [] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def reduceJoinGen chosenName inputs reductionIndices keepDims separator:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "keep_dims" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if keepDims then 1 else 0) . toCArg]
    CString.with "separator" nameCStr:
        CString.with separator valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    wrappers = makeOutputWrappers "ReduceJoin" [inputs, reductionIndices] [StringType] attrList chosenName
    TFOutput wrappers.head.get

def sparseAddGradGen chosenName backpropValGrad aIndices bIndices sumIndices t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "SparseAddGrad" [backpropValGrad, aIndices, bIndices, sumIndices] [backpropValGrad.wrapper.typetag, backpropValGrad.wrapper.typetag] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def maxPoolGradGradGen chosenName origInput origOutput grad ksize strides padding dataFormat t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "ksize" nameCStr:
        cvalues = ksize.map CInt64.fromInt
        Array CInt64 . with cvalues cvaluesArray:
            callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt ksize.length . toCArg]
    CString.with "strides" nameCStr:
        cvalues = strides.map CInt64.fromInt
        Array CInt64 . with cvalues cvaluesArray:
            callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
    CString.with "padding" nameCStr:
        CString.with padding valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    CString.with "data_format" nameCStr:
        CString.with dataFormat valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "MaxPoolGradGrad" [origInput, origOutput, grad] [origInput.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def tensorArrayReadGen chosenName handle index flowIn dtype:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "dtype" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt dtype.num . toCArg]
    wrappers = makeOutputWrappers "TensorArrayRead" [handle, index, flowIn] [dtype] attrList chosenName
    TFOutput wrappers.head.get

def shapeGen chosenName input t outType:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "out_type" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt outType.num . toCArg]
    wrappers = makeOutputWrappers "Shape" [input] [outType] attrList chosenName
    TFOutput wrappers.head.get

def powGen chosenName x y t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "Pow" [x, y] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def sdcaFprintGen chosenName input:
    wrappers = makeOutputWrappers "SdcaFprint" [input] [Int64Type] attrList chosenName
    TFOutput wrappers.head.get

def readerReadUpToGen chosenName readerHandle queueHandle numRecords:
    wrappers = makeOutputWrappers "ReaderReadUpTo" [readerHandle, queueHandle, numRecords] [StringType, StringType] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def batchMatrixSolveGen chosenName matrix rhs adjoint t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "adjoint" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if adjoint then 1 else 0) . toCArg]
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "BatchMatrixSolve" [matrix, rhs] [matrix.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def serializeSparseGen chosenName sparseIndices sparseValues sparseShape t outType:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "out_type" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt outType.num . toCArg]
    wrappers = makeOutputWrappers "SerializeSparse" [sparseIndices, sparseValues, sparseShape] [outType] attrList chosenName
    TFOutput wrappers.head.get

def drawBoundingBoxesGen chosenName images boxes t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "DrawBoundingBoxes" [images, boxes] [images.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def spaceToDepthGen chosenName input t blockSize dataFormat:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "block_size" nameCStr:
        callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt blockSize . toCArg]
    CString.with "data_format" nameCStr:
        CString.with dataFormat valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    wrappers = makeOutputWrappers "SpaceToDepth" [input] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def generateVocabRemappingGen chosenName newVocabFile oldVocabFile newVocabOffset numNewVocab oldVocabSize:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "new_vocab_offset" nameCStr:
        callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt newVocabOffset . toCArg]
    CString.with "num_new_vocab" nameCStr:
        callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt numNewVocab . toCArg]
    CString.with "old_vocab_size" nameCStr:
        callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt oldVocabSize . toCArg]
    wrappers = makeOutputWrappers "GenerateVocabRemapping" [newVocabFile, oldVocabFile] [Int64Type, Int32Type] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def abortGen chosenName errorMsg exitWithoutError:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "error_msg" nameCStr:
        CString.with errorMsg valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    CString.with "exit_without_error" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if exitWithoutError then 1 else 0) . toCArg]
    wrappers = makeOutputWrappers "Abort" [] [] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def modGen chosenName x y t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "Mod" [x, y] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def assignAddGen chosenName ref value t useLocking:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "use_locking" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useLocking then 1 else 0) . toCArg]
    wrappers = makeOutputWrappers "AssignAdd" [ref, value] [ref.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def avgPool3DGradGen chosenName origInputShape grad ksize strides padding dataFormat t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "ksize" nameCStr:
        cvalues = ksize.map CInt64.fromInt
        Array CInt64 . with cvalues cvaluesArray:
            callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt ksize.length . toCArg]
    CString.with "strides" nameCStr:
        cvalues = strides.map CInt64.fromInt
        Array CInt64 . with cvalues cvaluesArray:
            callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
    CString.with "padding" nameCStr:
        CString.with padding valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    CString.with "data_format" nameCStr:
        CString.with dataFormat valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "AvgPool3DGrad" [origInputShape, grad] [grad.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def unbatchGradGen chosenName originalInput batchIndex grad id container sharedName t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "container" nameCStr:
        CString.with container valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    CString.with "shared_name" nameCStr:
        CString.with sharedName valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "UnbatchGrad" [originalInput, batchIndex, grad, id] [originalInput.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def debugNanCountGen chosenName input t deviceName tensorName debugUrls gatedGrpc:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "device_name" nameCStr:
        CString.with deviceName valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    CString.with "tensor_name" nameCStr:
        CString.with tensorName valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    CString.with "debug_urls" nameCStr:
        len = debugUrls.length
        cValues = ManagedPointer (Pointer CInt64) . mallocElems len
        indexed = 0.upto (len - 1) . zip debugUrls
        indexed.each (idx, elem):
                cValues.moveElems idx . write (CString.fromText elem)
        callHandlingError "add_attr_string_list" None [attrList.toCArg, nameCStr.toCArg, cValues.toCArg, CUInt32.fromInt len . toCArg]
        0.upto (len - 1) . each (idx: cValues.moveElems idx . read . free)
    CString.with "gated_grpc" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if gatedGrpc then 1 else 0) . toCArg]
    wrappers = makeOutputWrappers "DebugNanCount" [input] [Int64Type] attrList chosenName
    TFOutput wrappers.head.get

def applyRMSPropGen chosenName var ms mom lr rho momentum epsilon grad t useLocking:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "use_locking" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useLocking then 1 else 0) . toCArg]
    wrappers = makeOutputWrappers "ApplyRMSProp" [var, ms, mom, lr, rho, momentum, epsilon, grad] [var.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def fakeQuantWithMinMaxVarsGen chosenName inputs min max numBits narrowRange:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "num_bits" nameCStr:
        callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt numBits . toCArg]
    CString.with "narrow_range" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if narrowRange then 1 else 0) . toCArg]
    wrappers = makeOutputWrappers "FakeQuantWithMinMaxVars" [inputs, min, max] [FloatType] attrList chosenName
    TFOutput wrappers.head.get

def cropAndResizeGradImageGen chosenName grads boxes boxInd imageSize t method:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "method" nameCStr:
        CString.with method valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    wrappers = makeOutputWrappers "CropAndResizeGradImage" [grads, boxes, boxInd, imageSize] [t] attrList chosenName
    TFOutput wrappers.head.get

def queueCloseGen chosenName handle cancelPendingEnqueues:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "cancel_pending_enqueues" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if cancelPendingEnqueues then 1 else 0) . toCArg]
    wrappers = makeOutputWrappers "QueueClose" [handle] [] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def scatterMinGen chosenName ref indices updates t tindices useLocking:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "Tindices" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
    CString.with "use_locking" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useLocking then 1 else 0) . toCArg]
    wrappers = makeOutputWrappers "ScatterMin" [ref, indices, updates] [ref.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def readFileGen chosenName filename:
    wrappers = makeOutputWrappers "ReadFile" [filename] [StringType] attrList chosenName
    TFOutput wrappers.head.get

def stringToHashBucketFastGen chosenName input numBuckets:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "num_buckets" nameCStr:
        callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt numBuckets . toCArg]
    wrappers = makeOutputWrappers "StringToHashBucketFast" [input] [Int64Type] attrList chosenName
    TFOutput wrappers.head.get

def accumulatorSetGlobalStepGen chosenName handle newGlobalStep:
    wrappers = makeOutputWrappers "AccumulatorSetGlobalStep" [handle, newGlobalStep] [] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def matrixDiagPartGen chosenName input t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "MatrixDiagPart" [input] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def placeholderGen chosenName dtype shape:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "dtype" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt dtype.num . toCArg]
    CString.with "shape" nameCStr:
        cdims = shape.map CInt64.fromInt
        Array CInt64 . with cdims cdimsArray:
            callHandlingError "add_attr_shape" None [attrList.toCArg, nameCStr.toCArg, cdimsArray.toCArg, CUInt32.fromInt shape.length . toCArg]
    wrappers = makeOutputWrappers "Placeholder" [] [dtype] attrList chosenName
    TFOutput wrappers.head.get

def absGen chosenName x t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "Abs" [x] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def accumulatorApplyGradientGen chosenName handle localStep gradient dtype:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "dtype" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt dtype.num . toCArg]
    wrappers = makeOutputWrappers "AccumulatorApplyGradient" [handle, localStep, gradient] [] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def sparseAccumulatorApplyGradientGen chosenName handle localStep gradientIndices gradientValues gradientShape dtype hasKnownShape:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "dtype" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt dtype.num . toCArg]
    CString.with "has_known_shape" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if hasKnownShape then 1 else 0) . toCArg]
    wrappers = makeOutputWrappers "SparseAccumulatorApplyGradient" [handle, localStep, gradientIndices, gradientValues, gradientShape] [] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def atanhGen chosenName x t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "Atanh" [x] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def conv2DGen chosenName input filter t strides useCudnnOnGpu padding dataFormat dilations:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "strides" nameCStr:
        cvalues = strides.map CInt64.fromInt
        Array CInt64 . with cvalues cvaluesArray:
            callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
    CString.with "use_cudnn_on_gpu" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useCudnnOnGpu then 1 else 0) . toCArg]
    CString.with "padding" nameCStr:
        CString.with padding valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    CString.with "data_format" nameCStr:
        CString.with dataFormat valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    CString.with "dilations" nameCStr:
        cvalues = dilations.map CInt64.fromInt
        Array CInt64 . with cvalues cvaluesArray:
            callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt dilations.length . toCArg]
    wrappers = makeOutputWrappers "Conv2D" [input, filter] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def tensorArrayCloseGen chosenName handle:
    wrappers = makeOutputWrappers "TensorArrayClose" [handle] [] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def scatterSubGen chosenName ref indices updates t tindices useLocking:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "Tindices" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
    CString.with "use_locking" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useLocking then 1 else 0) . toCArg]
    wrappers = makeOutputWrappers "ScatterSub" [ref, indices, updates] [ref.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def applyFtrlGen chosenName var accum linear grad lr l1 l2 lrPower t useLocking:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "use_locking" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useLocking then 1 else 0) . toCArg]
    wrappers = makeOutputWrappers "ApplyFtrl" [var, accum, linear, grad, lr, l1, l2, lrPower] [var.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def serializeTensorGen chosenName tensor t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "SerializeTensor" [tensor] [StringType] attrList chosenName
    TFOutput wrappers.head.get

def fusedBatchNormGradV2Gen chosenName yBackprop x scale reserveSpace1 reserveSpace2 t u epsilon dataFormat isTraining:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "U" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt u.num . toCArg]
    CString.with "epsilon" nameCStr:
        callHandlingError "add_attr_float" None [attrList.toCArg, nameCStr.toCArg, CFloat.fromReal epsilon . toCArg]
    CString.with "data_format" nameCStr:
        CString.with dataFormat valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    CString.with "is_training" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if isTraining then 1 else 0) . toCArg]
    wrappers = makeOutputWrappers "FusedBatchNormGradV2" [yBackprop, x, scale, reserveSpace1, reserveSpace2] [yBackprop.wrapper.typetag, reserveSpace1.wrapper.typetag, reserveSpace1.wrapper.typetag, reserveSpace1.wrapper.typetag, reserveSpace1.wrapper.typetag] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def batchNormWithGlobalNormalizationGen chosenName t m v beta gamma t varianceEpsilon scaleAfterNormalization:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "variance_epsilon" nameCStr:
        callHandlingError "add_attr_float" None [attrList.toCArg, nameCStr.toCArg, CFloat.fromReal varianceEpsilon . toCArg]
    CString.with "scale_after_normalization" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if scaleAfterNormalization then 1 else 0) . toCArg]
    wrappers = makeOutputWrappers "BatchNormWithGlobalNormalization" [t, m, v, beta, gamma] [t.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def controlTriggerGen chosenName:
    wrappers = makeOutputWrappers "ControlTrigger" [] [] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def tensorArrayReadV2Gen chosenName handle index flowIn dtype:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "dtype" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt dtype.num . toCArg]
    wrappers = makeOutputWrappers "TensorArrayReadV2" [handle, index, flowIn] [dtype] attrList chosenName
    TFOutput wrappers.head.get

def placeholderWithDefaultGen chosenName input dtype shape:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "dtype" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt dtype.num . toCArg]
    CString.with "shape" nameCStr:
        cdims = shape.map CInt64.fromInt
        Array CInt64 . with cdims cdimsArray:
            callHandlingError "add_attr_shape" None [attrList.toCArg, nameCStr.toCArg, cdimsArray.toCArg, CUInt32.fromInt shape.length . toCArg]
    wrappers = makeOutputWrappers "PlaceholderWithDefault" [input] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def decodeBase64Gen chosenName input:
    wrappers = makeOutputWrappers "DecodeBase64" [input] [StringType] attrList chosenName
    TFOutput wrappers.head.get

def seluGradGen chosenName gradients outputs t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "SeluGrad" [gradients, outputs] [gradients.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def sqrtGradGen chosenName y dy t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "SqrtGrad" [y, dy] [y.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def refExitGen chosenName data t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "RefExit" [data] [data.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def snapshotGen chosenName input t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "Snapshot" [input] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def sparseApplyAdagradDAGen chosenName var gradientAccumulator gradientSquaredAccumulator grad indices lr l1 l2 globalStep t tindices useLocking:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "Tindices" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
    CString.with "use_locking" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useLocking then 1 else 0) . toCArg]
    wrappers = makeOutputWrappers "SparseApplyAdagradDA" [var, gradientAccumulator, gradientSquaredAccumulator, grad, indices, lr, l1, l2, globalStep] [var.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def divNoNanGen chosenName x y t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "DivNoNan" [x, y] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def tensorArrayScatterGen chosenName handle indices value flowIn t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "TensorArrayScatter" [handle, indices, value, flowIn] [FloatType] attrList chosenName
    TFOutput wrappers.head.get

def sparseReduceMaxGen chosenName inputIndices inputValues inputShape reductionAxes keepDims t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "keep_dims" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if keepDims then 1 else 0) . toCArg]
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "SparseReduceMax" [inputIndices, inputValues, inputShape, reductionAxes] [inputValues.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def fractionalMaxPoolGen chosenName value poolingRatio pseudoRandom overlapping deterministic seed seed2 t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "pooling_ratio" nameCStr:
        cvalues = poolingRatio.map CFloat.fromReal
        Array CFloat . with cvalues cvaluesArray:
            callHandlingError "add_attr_float_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt poolingRatio.length . toCArg]
    CString.with "pseudo_random" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if pseudoRandom then 1 else 0) . toCArg]
    CString.with "overlapping" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if overlapping then 1 else 0) . toCArg]
    CString.with "deterministic" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if deterministic then 1 else 0) . toCArg]
    CString.with "seed" nameCStr:
        callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt seed . toCArg]
    CString.with "seed2" nameCStr:
        callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt seed2 . toCArg]
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "FractionalMaxPool" [value] [value.wrapper.typetag, Int64Type, Int64Type] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def scatterNdNonAliasingAddGen chosenName input indices updates t tindices:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "Tindices" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
    wrappers = makeOutputWrappers "ScatterNdNonAliasingAdd" [input, indices, updates] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def tensorArraySizeGen chosenName handle flowIn:
    wrappers = makeOutputWrappers "TensorArraySize" [handle, flowIn] [Int32Type] attrList chosenName
    TFOutput wrappers.head.get

def resizeNearestNeighborGradGen chosenName grads size t alignCorners:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "align_corners" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if alignCorners then 1 else 0) . toCArg]
    wrappers = makeOutputWrappers "ResizeNearestNeighborGrad" [grads, size] [grads.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def tensorArraySizeV2Gen chosenName handle flowIn:
    wrappers = makeOutputWrappers "TensorArraySizeV2" [handle, flowIn] [Int32Type] attrList chosenName
    TFOutput wrappers.head.get

def barrierReadySizeGen chosenName handle:
    wrappers = makeOutputWrappers "BarrierReadySize" [handle] [Int32Type] attrList chosenName
    TFOutput wrappers.head.get

def fakeQuantWithMinMaxArgsGen chosenName inputs min max numBits narrowRange:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "min" nameCStr:
        callHandlingError "add_attr_float" None [attrList.toCArg, nameCStr.toCArg, CFloat.fromReal min . toCArg]
    CString.with "max" nameCStr:
        callHandlingError "add_attr_float" None [attrList.toCArg, nameCStr.toCArg, CFloat.fromReal max . toCArg]
    CString.with "num_bits" nameCStr:
        callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt numBits . toCArg]
    CString.with "narrow_range" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if narrowRange then 1 else 0) . toCArg]
    wrappers = makeOutputWrappers "FakeQuantWithMinMaxArgs" [inputs] [FloatType] attrList chosenName
    TFOutput wrappers.head.get

def maxPoolV2Gen chosenName input ksize strides t padding dataFormat:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "padding" nameCStr:
        CString.with padding valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    CString.with "data_format" nameCStr:
        CString.with dataFormat valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    wrappers = makeOutputWrappers "MaxPoolV2" [input, ksize, strides] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def decodeJSONExampleGen chosenName jsonExamples:
    wrappers = makeOutputWrappers "DecodeJSONExample" [jsonExamples] [StringType] attrList chosenName
    TFOutput wrappers.head.get

def sparseAddGen chosenName aIndices aValues aShape bIndices bValues bShape thresh t treal:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "Treal" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt treal.num . toCArg]
    wrappers = makeOutputWrappers "SparseAdd" [aIndices, aValues, aShape, bIndices, bValues, bShape, thresh] [Int64Type, aValues.wrapper.typetag, Int64Type] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def initializeTableGen chosenName tableHandle keys values tkey tval:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "Tkey" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tkey.num . toCArg]
    CString.with "Tval" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tval.num . toCArg]
    wrappers = makeOutputWrappers "InitializeTable" [tableHandle, keys, values] [] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def tensorSummaryGen chosenName tensor t description labels displayName:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "description" nameCStr:
        CString.with description valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    CString.with "labels" nameCStr:
        len = labels.length
        cValues = ManagedPointer (Pointer CInt64) . mallocElems len
        indexed = 0.upto (len - 1) . zip labels
        indexed.each (idx, elem):
                cValues.moveElems idx . write (CString.fromText elem)
        callHandlingError "add_attr_string_list" None [attrList.toCArg, nameCStr.toCArg, cValues.toCArg, CUInt32.fromInt len . toCArg]
        0.upto (len - 1) . each (idx: cValues.moveElems idx . read . free)
    CString.with "display_name" nameCStr:
        CString.with displayName valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    wrappers = makeOutputWrappers "TensorSummary" [tensor] [StringType] attrList chosenName
    TFOutput wrappers.head.get

def imageSummaryGen chosenName tag tensor maxImages t badColor:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "max_images" nameCStr:
        callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt maxImages . toCArg]
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "bad_color" nameCStr:
        callHandlingError "add_attr_tensor" None [attrList.toCArg, nameCStr.toCArg, badColor.ptr.toCArg]
    wrappers = makeOutputWrappers "ImageSummary" [tag, tensor] [StringType] attrList chosenName
    TFOutput wrappers.head.get

def avgPoolGen chosenName value ksize strides padding dataFormat t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "ksize" nameCStr:
        cvalues = ksize.map CInt64.fromInt
        Array CInt64 . with cvalues cvaluesArray:
            callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt ksize.length . toCArg]
    CString.with "strides" nameCStr:
        cvalues = strides.map CInt64.fromInt
        Array CInt64 . with cvalues cvaluesArray:
            callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
    CString.with "padding" nameCStr:
        CString.with padding valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    CString.with "data_format" nameCStr:
        CString.with dataFormat valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "AvgPool" [value] [value.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def fillGen chosenName dims value t indexType:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "index_type" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt indexType.num . toCArg]
    wrappers = makeOutputWrappers "Fill" [dims, value] [value.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def asinhGen chosenName x t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "Asinh" [x] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def tanhGradGen chosenName y dy t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "TanhGrad" [y, dy] [y.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def scalarSummaryGen chosenName tags values t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "ScalarSummary" [tags, values] [StringType] attrList chosenName
    TFOutput wrappers.head.get

def uniqueWithCountsGen chosenName x t outIdx:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "out_idx" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt outIdx.num . toCArg]
    wrappers = makeOutputWrappers "UniqueWithCounts" [x] [x.wrapper.typetag, outIdx, outIdx] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def decodeRawGen chosenName bytes outType littleEndian:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "out_type" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt outType.num . toCArg]
    CString.with "little_endian" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if littleEndian then 1 else 0) . toCArg]
    wrappers = makeOutputWrappers "DecodeRaw" [bytes] [outType] attrList chosenName
    TFOutput wrappers.head.get

def eluGradGen chosenName gradients outputs t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "EluGrad" [gradients, outputs] [gradients.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def staticRegexReplaceGen chosenName input pattern rewrite replaceGlobal:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "pattern" nameCStr:
        CString.with pattern valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    CString.with "rewrite" nameCStr:
        CString.with rewrite valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    CString.with "replace_global" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if replaceGlobal then 1 else 0) . toCArg]
    wrappers = makeOutputWrappers "StaticRegexReplace" [input] [StringType] attrList chosenName
    TFOutput wrappers.head.get

def matrixBandPartGen chosenName input numLower numUpper t tindex:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "Tindex" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindex.num . toCArg]
    wrappers = makeOutputWrappers "MatrixBandPart" [input, numLower, numUpper] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def decodeCompressedGen chosenName bytes compressionType:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "compression_type" nameCStr:
        CString.with compressionType valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    wrappers = makeOutputWrappers "DecodeCompressed" [bytes] [StringType] attrList chosenName
    TFOutput wrappers.head.get

def maxPoolWithArgmaxGen chosenName input ksize strides targmax padding t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "ksize" nameCStr:
        cvalues = ksize.map CInt64.fromInt
        Array CInt64 . with cvalues cvaluesArray:
            callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt ksize.length . toCArg]
    CString.with "strides" nameCStr:
        cvalues = strides.map CInt64.fromInt
        Array CInt64 . with cvalues cvaluesArray:
            callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
    CString.with "Targmax" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt targmax.num . toCArg]
    CString.with "padding" nameCStr:
        CString.with padding valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "MaxPoolWithArgmax" [input] [input.wrapper.typetag, targmax] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def parseTensorGen chosenName serialized outType:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "out_type" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt outType.num . toCArg]
    wrappers = makeOutputWrappers "ParseTensor" [serialized] [outType] attrList chosenName
    TFOutput wrappers.head.get

def rankGen chosenName input t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "Rank" [input] [Int32Type] attrList chosenName
    TFOutput wrappers.head.get

def barrierInsertManyGen chosenName handle keys values t componentIndex:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "component_index" nameCStr:
        callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt componentIndex . toCArg]
    wrappers = makeOutputWrappers "BarrierInsertMany" [handle, keys, values] [] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def sparseApplyAdagradGen chosenName var accum lr grad indices t tindices useLocking updateSlots:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "Tindices" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
    CString.with "use_locking" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useLocking then 1 else 0) . toCArg]
    CString.with "update_slots" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if updateSlots then 1 else 0) . toCArg]
    wrappers = makeOutputWrappers "SparseApplyAdagrad" [var, accum, lr, grad, indices] [var.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def linSpaceGen chosenName start stop num t tidx:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "Tidx" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tidx.num . toCArg]
    wrappers = makeOutputWrappers "LinSpace" [start, stop, num] [start.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def applyAdamGen chosenName var m v beta1Power beta2Power lr beta1 beta2 epsilon grad t useLocking useNesterov:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "use_locking" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useLocking then 1 else 0) . toCArg]
    CString.with "use_nesterov" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useNesterov then 1 else 0) . toCArg]
    wrappers = makeOutputWrappers "ApplyAdam" [var, m, v, beta1Power, beta2Power, lr, beta1, beta2, epsilon, grad] [var.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def padGen chosenName input paddings t tpaddings:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "Tpaddings" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tpaddings.num . toCArg]
    wrappers = makeOutputWrappers "Pad" [input, paddings] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def writeFileGen chosenName filename contents:
    wrappers = makeOutputWrappers "WriteFile" [filename, contents] [] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def applyAdadeltaGen chosenName var accum accumUpdate lr rho epsilon grad t useLocking:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "use_locking" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useLocking then 1 else 0) . toCArg]
    wrappers = makeOutputWrappers "ApplyAdadelta" [var, accum, accumUpdate, lr, rho, epsilon, grad] [var.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def batchMatrixDiagGen chosenName diagonal t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "BatchMatrixDiag" [diagonal] [diagonal.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def fakeQuantWithMinMaxArgsGradientGen chosenName gradients inputs min max numBits narrowRange:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "min" nameCStr:
        callHandlingError "add_attr_float" None [attrList.toCArg, nameCStr.toCArg, CFloat.fromReal min . toCArg]
    CString.with "max" nameCStr:
        callHandlingError "add_attr_float" None [attrList.toCArg, nameCStr.toCArg, CFloat.fromReal max . toCArg]
    CString.with "num_bits" nameCStr:
        callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt numBits . toCArg]
    CString.with "narrow_range" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if narrowRange then 1 else 0) . toCArg]
    wrappers = makeOutputWrappers "FakeQuantWithMinMaxArgsGradient" [gradients, inputs] [FloatType] attrList chosenName
    TFOutput wrappers.head.get

def applyPowerSignGen chosenName var m lr logbase signDecay beta grad t useLocking:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "use_locking" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useLocking then 1 else 0) . toCArg]
    wrappers = makeOutputWrappers "ApplyPowerSign" [var, m, lr, logbase, signDecay, beta, grad] [var.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def batchMatMulGen chosenName x y t adjX adjY:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "adj_x" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if adjX then 1 else 0) . toCArg]
    CString.with "adj_y" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if adjY then 1 else 0) . toCArg]
    wrappers = makeOutputWrappers "BatchMatMul" [x, y] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def sparseSliceGen chosenName indices values shape start size t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "SparseSlice" [indices, values, shape, start, size] [Int64Type, values.wrapper.typetag, Int64Type] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def l2LossGen chosenName t t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "L2Loss" [t] [t.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def denseToSparseSetOperationGen chosenName set1 set2Indices set2Values set2Shape setOperation validateIndices t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "set_operation" nameCStr:
        CString.with setOperation valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    CString.with "validate_indices" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if validateIndices then 1 else 0) . toCArg]
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "DenseToSparseSetOperation" [set1, set2Indices, set2Values, set2Shape] [Int64Type, set1.wrapper.typetag, Int64Type] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def sparseToSparseSetOperationGen chosenName set1Indices set1Values set1Shape set2Indices set2Values set2Shape setOperation validateIndices t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "set_operation" nameCStr:
        CString.with setOperation valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    CString.with "validate_indices" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if validateIndices then 1 else 0) . toCArg]
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "SparseToSparseSetOperation" [set1Indices, set1Values, set1Shape, set2Indices, set2Values, set2Shape] [Int64Type, set1Values.wrapper.typetag, Int64Type] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def deserializeSparseGen chosenName serializedSparse dtype tserialized:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "dtype" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt dtype.num . toCArg]
    CString.with "Tserialized" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tserialized.num . toCArg]
    wrappers = makeOutputWrappers "DeserializeSparse" [serializedSparse] [Int64Type, dtype, Int64Type] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def deserializeManySparseGen chosenName serializedSparse dtype:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "dtype" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt dtype.num . toCArg]
    wrappers = makeOutputWrappers "DeserializeManySparse" [serializedSparse] [Int64Type, dtype, Int64Type] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def immutableConstGen chosenName dtype shape memoryRegionName:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "dtype" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt dtype.num . toCArg]
    CString.with "shape" nameCStr:
        cdims = shape.map CInt64.fromInt
        Array CInt64 . with cdims cdimsArray:
            callHandlingError "add_attr_shape" None [attrList.toCArg, nameCStr.toCArg, cdimsArray.toCArg, CUInt32.fromInt shape.length . toCArg]
    CString.with "memory_region_name" nameCStr:
        CString.with memoryRegionName valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    wrappers = makeOutputWrappers "ImmutableConst" [] [dtype] attrList chosenName
    TFOutput wrappers.head.get

def sparseToDenseGen chosenName sparseIndices outputShape sparseValues defaultValue validateIndices t tindices:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "validate_indices" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if validateIndices then 1 else 0) . toCArg]
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "Tindices" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
    wrappers = makeOutputWrappers "SparseToDense" [sparseIndices, outputShape, sparseValues, defaultValue] [sparseValues.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def batchToSpaceGen chosenName input crops t blockSize tidx:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "block_size" nameCStr:
        callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt blockSize . toCArg]
    CString.with "Tidx" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tidx.num . toCArg]
    wrappers = makeOutputWrappers "BatchToSpace" [input, crops] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def listDiffGen chosenName x y t outIdx:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "out_idx" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt outIdx.num . toCArg]
    wrappers = makeOutputWrappers "ListDiff" [x, y] [x.wrapper.typetag, outIdx] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def sparseReorderGen chosenName inputIndices inputValues inputShape t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "SparseReorder" [inputIndices, inputValues, inputShape] [Int64Type, inputValues.wrapper.typetag] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def tensorArraySplitV2Gen chosenName handle value lengths flowIn t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "TensorArraySplitV2" [handle, value, lengths, flowIn] [FloatType] attrList chosenName
    TFOutput wrappers.head.get

def sparseReshapeGen chosenName inputIndices inputShape newShape:
    wrappers = makeOutputWrappers "SparseReshape" [inputIndices, inputShape, newShape] [Int64Type, Int64Type] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def sparseTensorDenseAddGen chosenName aIndices aValues aShape b t tindices:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "Tindices" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
    wrappers = makeOutputWrappers "SparseTensorDenseAdd" [aIndices, aValues, aShape, b] [aValues.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def sparseReduceSumGen chosenName inputIndices inputValues inputShape reductionAxes keepDims t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "keep_dims" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if keepDims then 1 else 0) . toCArg]
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "SparseReduceSum" [inputIndices, inputValues, inputShape, reductionAxes] [inputValues.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def sparseReduceSumSparseGen chosenName inputIndices inputValues inputShape reductionAxes keepDims t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "keep_dims" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if keepDims then 1 else 0) . toCArg]
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "SparseReduceSumSparse" [inputIndices, inputValues, inputShape, reductionAxes] [Int64Type, inputValues.wrapper.typetag, Int64Type] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def mulGen chosenName x y t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "Mul" [x, y] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def sparseDenseCwiseMulGen chosenName spIndices spValues spShape dense t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "SparseDenseCwiseMul" [spIndices, spValues, spShape, dense] [spValues.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def sparseSoftmaxGen chosenName spIndices spValues spShape t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "SparseSoftmax" [spIndices, spValues, spShape] [spValues.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def sparseSparseMinimumGen chosenName aIndices aValues aShape bIndices bValues bShape t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "SparseSparseMinimum" [aIndices, aValues, aShape, bIndices, bValues, bShape] [Int64Type, aValues.wrapper.typetag] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def tileGen chosenName input multiples t tmultiples:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "Tmultiples" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tmultiples.num . toCArg]
    wrappers = makeOutputWrappers "Tile" [input, multiples] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def dilation2DBackpropFilterGen chosenName input filter outBackprop t strides rates padding:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "strides" nameCStr:
        cvalues = strides.map CInt64.fromInt
        Array CInt64 . with cvalues cvaluesArray:
            callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
    CString.with "rates" nameCStr:
        cvalues = rates.map CInt64.fromInt
        Array CInt64 . with cvalues cvaluesArray:
            callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt rates.length . toCArg]
    CString.with "padding" nameCStr:
        CString.with padding valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    wrappers = makeOutputWrappers "Dilation2DBackpropFilter" [input, filter, outBackprop] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def lookupTableImportGen chosenName tableHandle keys values tin tout:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "Tin" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tin.num . toCArg]
    CString.with "Tout" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tout.num . toCArg]
    wrappers = makeOutputWrappers "LookupTableImport" [tableHandle, keys, values] [] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def constGen chosenName value dtype:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "value" nameCStr:
        callHandlingError "add_attr_tensor" None [attrList.toCArg, nameCStr.toCArg, value.ptr.toCArg]
    CString.with "dtype" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt dtype.num . toCArg]
    wrappers = makeOutputWrappers "Const" [] [dtype] attrList chosenName
    TFOutput wrappers.head.get

def sparseFillEmptyRowsGen chosenName indices values denseShape defaultValue t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "SparseFillEmptyRows" [indices, values, denseShape, defaultValue] [Int64Type, values.wrapper.typetag, BoolType, Int64Type] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def reverseGen chosenName tensor dims t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "Reverse" [tensor, dims] [tensor.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def logSoftmaxGen chosenName logits t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "LogSoftmax" [logits] [logits.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def invertPermutationGen chosenName x t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "InvertPermutation" [x] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def mirrorPadGradGen chosenName input paddings t tpaddings mode:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "Tpaddings" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tpaddings.num . toCArg]
    CString.with "mode" nameCStr:
        CString.with mode valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    wrappers = makeOutputWrappers "MirrorPadGrad" [input, paddings] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def onesLikeGen chosenName x t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "OnesLike" [x] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def sparseFillEmptyRowsGradGen chosenName reverseIndexMap gradValues t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "SparseFillEmptyRowsGrad" [reverseIndexMap, gradValues] [gradValues.wrapper.typetag, gradValues.wrapper.typetag] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def diagGen chosenName diagonal t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "Diag" [diagonal] [diagonal.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def fakeQuantWithMinMaxVarsPerChannelGen chosenName inputs min max numBits narrowRange:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "num_bits" nameCStr:
        callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt numBits . toCArg]
    CString.with "narrow_range" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if narrowRange then 1 else 0) . toCArg]
    wrappers = makeOutputWrappers "FakeQuantWithMinMaxVarsPerChannel" [inputs, min, max] [FloatType] attrList chosenName
    TFOutput wrappers.head.get

def encodeJpegGen chosenName image format quality progressive optimizeSize chromaDownsampling densityUnit xDensity yDensity xmpMetadata:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "format" nameCStr:
        CString.with format valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    CString.with "quality" nameCStr:
        callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt quality . toCArg]
    CString.with "progressive" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if progressive then 1 else 0) . toCArg]
    CString.with "optimize_size" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if optimizeSize then 1 else 0) . toCArg]
    CString.with "chroma_downsampling" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if chromaDownsampling then 1 else 0) . toCArg]
    CString.with "density_unit" nameCStr:
        CString.with densityUnit valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    CString.with "x_density" nameCStr:
        callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt xDensity . toCArg]
    CString.with "y_density" nameCStr:
        callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt yDensity . toCArg]
    CString.with "xmp_metadata" nameCStr:
        CString.with xmpMetadata valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    wrappers = makeOutputWrappers "EncodeJpeg" [image] [StringType] attrList chosenName
    TFOutput wrappers.head.get

def addGen chosenName x y t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "Add" [x, y] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def randomGammaGradGen chosenName alpha sample t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "RandomGammaGrad" [alpha, sample] [alpha.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def sparseAccumulatorTakeGradientGen chosenName handle numRequired dtype:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "dtype" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt dtype.num . toCArg]
    wrappers = makeOutputWrappers "SparseAccumulatorTakeGradient" [handle, numRequired] [Int64Type, dtype, Int64Type] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def floorModGen chosenName x y t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "FloorMod" [x, y] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def statelessRandomUniformGen chosenName shape seed dtype t tseed:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "dtype" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt dtype.num . toCArg]
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "Tseed" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tseed.num . toCArg]
    wrappers = makeOutputWrappers "StatelessRandomUniform" [shape, seed] [dtype] attrList chosenName
    TFOutput wrappers.head.get

def statelessRandomNormalGen chosenName shape seed dtype t tseed:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "dtype" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt dtype.num . toCArg]
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "Tseed" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tseed.num . toCArg]
    wrappers = makeOutputWrappers "StatelessRandomNormal" [shape, seed] [dtype] attrList chosenName
    TFOutput wrappers.head.get

def statelessMultinomialGen chosenName logits numSamples seed t tseed outputDtype:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "Tseed" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tseed.num . toCArg]
    CString.with "output_dtype" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt outputDtype.num . toCArg]
    wrappers = makeOutputWrappers "StatelessMultinomial" [logits, numSamples, seed] [outputDtype] attrList chosenName
    TFOutput wrappers.head.get

def regexReplaceGen chosenName input pattern rewrite replaceGlobal:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "replace_global" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if replaceGlobal then 1 else 0) . toCArg]
    wrappers = makeOutputWrappers "RegexReplace" [input, pattern, rewrite] [StringType] attrList chosenName
    TFOutput wrappers.head.get

def regexFullMatchGen chosenName input pattern:
    wrappers = makeOutputWrappers "RegexFullMatch" [input, pattern] [BoolType] attrList chosenName
    TFOutput wrappers.head.get

def tensorArrayScatterV2Gen chosenName handle indices value flowIn t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "TensorArrayScatterV2" [handle, indices, value, flowIn] [FloatType] attrList chosenName
    TFOutput wrappers.head.get

def asStringGen chosenName input t precision scientific shortest width fill:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "precision" nameCStr:
        callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt precision . toCArg]
    CString.with "scientific" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if scientific then 1 else 0) . toCArg]
    CString.with "shortest" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if shortest then 1 else 0) . toCArg]
    CString.with "width" nameCStr:
        callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt width . toCArg]
    CString.with "fill" nameCStr:
        CString.with fill valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    wrappers = makeOutputWrappers "AsString" [input] [StringType] attrList chosenName
    TFOutput wrappers.head.get

def stringSplitGen chosenName input delimiter skipEmpty:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "skip_empty" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if skipEmpty then 1 else 0) . toCArg]
    wrappers = makeOutputWrappers "StringSplit" [input, delimiter] [Int64Type, StringType, Int64Type] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def stringSplitV2Gen chosenName input sep maxsplit:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "maxsplit" nameCStr:
        callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt maxsplit . toCArg]
    wrappers = makeOutputWrappers "StringSplitV2" [input, sep] [Int64Type, StringType, Int64Type] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def stringStripGen chosenName input:
    wrappers = makeOutputWrappers "StringStrip" [input] [StringType] attrList chosenName
    TFOutput wrappers.head.get

def stringToHashBucketStrongGen chosenName input numBuckets key:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "num_buckets" nameCStr:
        callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt numBuckets . toCArg]
    CString.with "key" nameCStr:
        cvalues = key.map CInt64.fromInt
        Array CInt64 . with cvalues cvaluesArray:
            callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt key.length . toCArg]
    wrappers = makeOutputWrappers "StringToHashBucketStrong" [input] [Int64Type] attrList chosenName
    TFOutput wrappers.head.get

def stringLengthGen chosenName input:
    wrappers = makeOutputWrappers "StringLength" [input] [Int32Type] attrList chosenName
    TFOutput wrappers.head.get

def tensorArrayCloseV2Gen chosenName handle:
    wrappers = makeOutputWrappers "TensorArrayCloseV2" [handle] [] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def encodeBase64Gen chosenName input pad:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "pad" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if pad then 1 else 0) . toCArg]
    wrappers = makeOutputWrappers "EncodeBase64" [input] [StringType] attrList chosenName
    TFOutput wrappers.head.get

def applyAdaMaxGen chosenName var m v beta1Power lr beta1 beta2 epsilon grad t useLocking:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "use_locking" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useLocking then 1 else 0) . toCArg]
    wrappers = makeOutputWrappers "ApplyAdaMax" [var, m, v, beta1Power, lr, beta1, beta2, epsilon, grad] [var.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def prodGen chosenName input reductionIndices keepDims t tidx:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "keep_dims" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if keepDims then 1 else 0) . toCArg]
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "Tidx" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tidx.num . toCArg]
    wrappers = makeOutputWrappers "Prod" [input, reductionIndices] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def isVariableInitializedGen chosenName ref dtype:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "dtype" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt dtype.num . toCArg]
    wrappers = makeOutputWrappers "IsVariableInitialized" [ref] [BoolType] attrList chosenName
    TFOutput wrappers.head.get

def gatherGen chosenName params indices validateIndices tparams tindices:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "validate_indices" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if validateIndices then 1 else 0) . toCArg]
    CString.with "Tparams" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tparams.num . toCArg]
    CString.with "Tindices" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
    wrappers = makeOutputWrappers "Gather" [params, indices] [params.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def destroyTemporaryVariableGen chosenName ref t varName:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "var_name" nameCStr:
        CString.with varName valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    wrappers = makeOutputWrappers "DestroyTemporaryVariable" [ref] [ref.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def castGen chosenName x srcT dstT truncate:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "SrcT" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt srcT.num . toCArg]
    CString.with "DstT" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt dstT.num . toCArg]
    CString.with "Truncate" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if truncate then 1 else 0) . toCArg]
    wrappers = makeOutputWrappers "Cast" [x] [dstT] attrList chosenName
    TFOutput wrappers.head.get

def assignSubGen chosenName ref value t useLocking:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "use_locking" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useLocking then 1 else 0) . toCArg]
    wrappers = makeOutputWrappers "AssignSub" [ref, value] [ref.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def scatterAddGen chosenName ref indices updates t tindices useLocking:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "Tindices" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
    CString.with "use_locking" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useLocking then 1 else 0) . toCArg]
    wrappers = makeOutputWrappers "ScatterAdd" [ref, indices, updates] [ref.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def scatterMulGen chosenName ref indices updates t tindices useLocking:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "Tindices" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
    CString.with "use_locking" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useLocking then 1 else 0) . toCArg]
    wrappers = makeOutputWrappers "ScatterMul" [ref, indices, updates] [ref.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def scatterMaxGen chosenName ref indices updates t tindices useLocking:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "Tindices" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
    CString.with "use_locking" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useLocking then 1 else 0) . toCArg]
    wrappers = makeOutputWrappers "ScatterMax" [ref, indices, updates] [ref.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def mirrorPadGen chosenName input paddings t tpaddings mode:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "Tpaddings" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tpaddings.num . toCArg]
    CString.with "mode" nameCStr:
        CString.with mode valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    wrappers = makeOutputWrappers "MirrorPad" [input, paddings] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def batchMatrixDiagPartGen chosenName input t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "BatchMatrixDiagPart" [input] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def scatterNdUpdateGen chosenName ref indices updates t tindices useLocking:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "Tindices" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
    CString.with "use_locking" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useLocking then 1 else 0) . toCArg]
    wrappers = makeOutputWrappers "ScatterNdUpdate" [ref, indices, updates] [ref.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def divGen chosenName x y t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "Div" [x, y] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def scatterNdSubGen chosenName ref indices updates t tindices useLocking:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "Tindices" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
    CString.with "use_locking" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useLocking then 1 else 0) . toCArg]
    wrappers = makeOutputWrappers "ScatterNdSub" [ref, indices, updates] [ref.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def topKGen chosenName input k sorted t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "k" nameCStr:
        callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt k . toCArg]
    CString.with "sorted" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if sorted then 1 else 0) . toCArg]
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "TopK" [input] [input.wrapper.typetag, Int32Type] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def applyProximalGradientDescentGen chosenName var alpha l1 l2 delta t useLocking:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "use_locking" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useLocking then 1 else 0) . toCArg]
    wrappers = makeOutputWrappers "ApplyProximalGradientDescent" [var, alpha, l1, l2, delta] [var.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def matchingFilesGen chosenName pattern:
    wrappers = makeOutputWrappers "MatchingFiles" [pattern] [StringType] attrList chosenName
    TFOutput wrappers.head.get

def sparseApplyProximalGradientDescentGen chosenName var alpha l1 l2 grad indices t tindices useLocking:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "Tindices" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
    CString.with "use_locking" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useLocking then 1 else 0) . toCArg]
    wrappers = makeOutputWrappers "SparseApplyProximalGradientDescent" [var, alpha, l1, l2, grad, indices] [var.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def sparseApplyAdadeltaGen chosenName var accum accumUpdate lr rho epsilon grad indices t tindices useLocking:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "Tindices" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
    CString.with "use_locking" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useLocking then 1 else 0) . toCArg]
    wrappers = makeOutputWrappers "SparseApplyAdadelta" [var, accum, accumUpdate, lr, rho, epsilon, grad, indices] [var.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def audioSummaryV2Gen chosenName tag tensor sampleRate maxOutputs:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "max_outputs" nameCStr:
        callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt maxOutputs . toCArg]
    wrappers = makeOutputWrappers "AudioSummaryV2" [tag, tensor, sampleRate] [StringType] attrList chosenName
    TFOutput wrappers.head.get

def applyAdagradGen chosenName var accum lr grad t useLocking updateSlots:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "use_locking" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useLocking then 1 else 0) . toCArg]
    CString.with "update_slots" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if updateSlots then 1 else 0) . toCArg]
    wrappers = makeOutputWrappers "ApplyAdagrad" [var, accum, lr, grad] [var.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def matrixSolveLsGen chosenName matrix rhs l2Regularizer t fast:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "fast" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if fast then 1 else 0) . toCArg]
    wrappers = makeOutputWrappers "MatrixSolveLs" [matrix, rhs, l2Regularizer] [matrix.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def bitwiseOrGen chosenName x y t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "BitwiseOr" [x, y] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def applyProximalAdagradGen chosenName var accum lr l1 l2 grad t useLocking:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "use_locking" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useLocking then 1 else 0) . toCArg]
    wrappers = makeOutputWrappers "ApplyProximalAdagrad" [var, accum, lr, l1, l2, grad] [var.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def sparseApplyFtrlGen chosenName var accum linear grad indices lr l1 l2 lrPower t tindices useLocking:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "Tindices" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
    CString.with "use_locking" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useLocking then 1 else 0) . toCArg]
    wrappers = makeOutputWrappers "SparseApplyFtrl" [var, accum, linear, grad, indices, lr, l1, l2, lrPower] [var.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def subGen chosenName x y t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "Sub" [x, y] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def isInfGen chosenName x t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "IsInf" [x] [BoolType] attrList chosenName
    TFOutput wrappers.head.get

def applyFtrlV2Gen chosenName var accum linear grad lr l1 l2 l2Shrinkage lrPower t useLocking:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "use_locking" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useLocking then 1 else 0) . toCArg]
    wrappers = makeOutputWrappers "ApplyFtrlV2" [var, accum, linear, grad, lr, l1, l2, l2Shrinkage, lrPower] [var.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def bitwiseXorGen chosenName x y t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "BitwiseXor" [x, y] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def stringToNumberGen chosenName stringTensor outType:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "out_type" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt outType.num . toCArg]
    wrappers = makeOutputWrappers "StringToNumber" [stringTensor] [outType] attrList chosenName
    TFOutput wrappers.head.get

def sparseDenseCwiseDivGen chosenName spIndices spValues spShape dense t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "SparseDenseCwiseDiv" [spIndices, spValues, spShape, dense] [spValues.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def applyMomentumGen chosenName var accum lr grad momentum t useLocking useNesterov:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "use_locking" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useLocking then 1 else 0) . toCArg]
    CString.with "use_nesterov" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useNesterov then 1 else 0) . toCArg]
    wrappers = makeOutputWrappers "ApplyMomentum" [var, accum, lr, grad, momentum] [var.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def sparseApplyMomentumGen chosenName var accum lr grad indices momentum t tindices useLocking useNesterov:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "Tindices" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
    CString.with "use_locking" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useLocking then 1 else 0) . toCArg]
    CString.with "use_nesterov" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useNesterov then 1 else 0) . toCArg]
    wrappers = makeOutputWrappers "SparseApplyMomentum" [var, accum, lr, grad, indices, momentum] [var.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def crossReplicaSumGen chosenName input groupAssignment t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "CrossReplicaSum" [input, groupAssignment] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def applyCenteredRMSPropGen chosenName var mg ms mom lr rho momentum epsilon grad t useLocking:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "use_locking" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useLocking then 1 else 0) . toCArg]
    wrappers = makeOutputWrappers "ApplyCenteredRMSProp" [var, mg, ms, mom, lr, rho, momentum, epsilon, grad] [var.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def sparseApplyRMSPropGen chosenName var ms mom lr rho momentum epsilon grad indices t tindices useLocking:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "Tindices" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
    CString.with "use_locking" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useLocking then 1 else 0) . toCArg]
    wrappers = makeOutputWrappers "SparseApplyRMSProp" [var, ms, mom, lr, rho, momentum, epsilon, grad, indices] [var.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def sparseApplyCenteredRMSPropGen chosenName var mg ms mom lr rho momentum epsilon grad indices t tindices useLocking:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "Tindices" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
    CString.with "use_locking" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useLocking then 1 else 0) . toCArg]
    wrappers = makeOutputWrappers "SparseApplyCenteredRMSProp" [var, mg, ms, mom, lr, rho, momentum, epsilon, grad, indices] [var.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def sizeGen chosenName input t outType:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "out_type" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt outType.num . toCArg]
    wrappers = makeOutputWrappers "Size" [input] [outType] attrList chosenName
    TFOutput wrappers.head.get

def biasAddV1Gen chosenName value bias t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "BiasAddV1" [value, bias] [value.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def reverseV2Gen chosenName tensor axis tidx t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "Tidx" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tidx.num . toCArg]
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "ReverseV2" [tensor, axis] [tensor.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def applyAddSignGen chosenName var m lr alpha signDecay beta grad t useLocking:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "use_locking" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useLocking then 1 else 0) . toCArg]
    wrappers = makeOutputWrappers "ApplyAddSign" [var, m, lr, alpha, signDecay, beta, grad] [var.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def matrixDeterminantGen chosenName input t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "MatrixDeterminant" [input] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def readerNumWorkUnitsCompletedGen chosenName readerHandle:
    wrappers = makeOutputWrappers "ReaderNumWorkUnitsCompleted" [readerHandle] [Int64Type] attrList chosenName
    TFOutput wrappers.head.get

def gcsConfigureCredentialsGen chosenName json:
    wrappers = makeOutputWrappers "GcsConfigureCredentials" [json] [] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def softplusGen chosenName features t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "Softplus" [features] [features.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def expm1Gen chosenName x t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "Expm1" [x] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def nextIterationGen chosenName data t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "NextIteration" [data] [data.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def factGen chosenName:
    wrappers = makeOutputWrappers "Fact" [] [StringType] attrList chosenName
    TFOutput wrappers.head.get

def bitwiseAndGen chosenName x y t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "BitwiseAnd" [x, y] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def leftShiftGen chosenName x y t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "LeftShift" [x, y] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def rightShiftGen chosenName x y t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "RightShift" [x, y] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def inplaceUpdateGen chosenName x i v t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "InplaceUpdate" [x, i, v] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def sigmoidGen chosenName x t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "Sigmoid" [x] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def inplaceAddGen chosenName x i v t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "InplaceAdd" [x, i, v] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def inplaceSubGen chosenName x i v t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "InplaceSub" [x, i, v] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def unravelIndexGen chosenName indices dims tidx:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "Tidx" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tidx.num . toCArg]
    wrappers = makeOutputWrappers "UnravelIndex" [indices, dims] [indices.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def broadcastToGen chosenName input shape t tidx:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "Tidx" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tidx.num . toCArg]
    wrappers = makeOutputWrappers "BroadcastTo" [input, shape] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def hostConstGen chosenName value dtype:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "value" nameCStr:
        callHandlingError "add_attr_tensor" None [attrList.toCArg, nameCStr.toCArg, value.ptr.toCArg]
    CString.with "dtype" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt dtype.num . toCArg]
    wrappers = makeOutputWrappers "HostConst" [] [dtype] attrList chosenName
    TFOutput wrappers.head.get

def refNextIterationGen chosenName data t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "RefNextIteration" [data] [data.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def zerosLikeGen chosenName x t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "ZerosLike" [x] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def invertGen chosenName x t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "Invert" [x] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def matrixDiagGen chosenName diagonal t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "MatrixDiag" [diagonal] [diagonal.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def floorDivGen chosenName x y t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "FloorDiv" [x, y] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def editDistanceGen chosenName hypothesisIndices hypothesisValues hypothesisShape truthIndices truthValues truthShape normalize t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "normalize" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if normalize then 1 else 0) . toCArg]
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "EditDistance" [hypothesisIndices, hypothesisValues, hypothesisShape, truthIndices, truthValues, truthShape] [FloatType] attrList chosenName
    TFOutput wrappers.head.get

def gatherV2Gen chosenName params indices axis tparams tindices taxis:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "Tparams" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tparams.num . toCArg]
    CString.with "Tindices" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
    CString.with "Taxis" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt taxis.num . toCArg]
    wrappers = makeOutputWrappers "GatherV2" [params, indices, axis] [params.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def erfcGen chosenName x t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "Erfc" [x] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def gatherNdGen chosenName params indices tparams tindices:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "Tparams" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tparams.num . toCArg]
    CString.with "Tindices" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
    wrappers = makeOutputWrappers "GatherNd" [params, indices] [params.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def refIdentityGen chosenName input t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "RefIdentity" [input] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def stopGradientGen chosenName input t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "StopGradient" [input] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def asinGen chosenName x t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "Asin" [x] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def preventGradientGen chosenName input t message:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "message" nameCStr:
        CString.with message valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    wrappers = makeOutputWrappers "PreventGradient" [input] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def checkNumericsGen chosenName tensor t message:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "message" nameCStr:
        CString.with message valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    wrappers = makeOutputWrappers "CheckNumerics" [tensor] [tensor.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def conjugateTransposeGen chosenName x perm t tperm:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "Tperm" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tperm.num . toCArg]
    wrappers = makeOutputWrappers "ConjugateTranspose" [x, perm] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def uniqueV2Gen chosenName x axis t taxis outIdx:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "Taxis" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt taxis.num . toCArg]
    CString.with "out_idx" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt outIdx.num . toCArg]
    wrappers = makeOutputWrappers "UniqueV2" [x, axis] [x.wrapper.typetag, outIdx] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def uniqueWithCountsV2Gen chosenName x axis t taxis outIdx:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "Taxis" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt taxis.num . toCArg]
    CString.with "out_idx" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt outIdx.num . toCArg]
    wrappers = makeOutputWrappers "UniqueWithCountsV2" [x, axis] [x.wrapper.typetag, outIdx, outIdx] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def reverseSequenceGen chosenName input seqLengths seqDim batchDim t tlen:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "seq_dim" nameCStr:
        callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt seqDim . toCArg]
    CString.with "batch_dim" nameCStr:
        callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt batchDim . toCArg]
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "Tlen" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tlen.num . toCArg]
    wrappers = makeOutputWrappers "ReverseSequence" [input, seqLengths] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def rsqrtGradGen chosenName y dy t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "RsqrtGrad" [y, dy] [y.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def sliceGen chosenName input begin size t index:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "Index" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt index.num . toCArg]
    wrappers = makeOutputWrappers "Slice" [input, begin, size] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def copyGen chosenName input t tensorName debugOpsSpec:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "tensor_name" nameCStr:
        CString.with tensorName valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    CString.with "debug_ops_spec" nameCStr:
        len = debugOpsSpec.length
        cValues = ManagedPointer (Pointer CInt64) . mallocElems len
        indexed = 0.upto (len - 1) . zip debugOpsSpec
        indexed.each (idx, elem):
                cValues.moveElems idx . write (CString.fromText elem)
        callHandlingError "add_attr_string_list" None [attrList.toCArg, nameCStr.toCArg, cValues.toCArg, CUInt32.fromInt len . toCArg]
        0.upto (len - 1) . each (idx: cValues.moveElems idx . read . free)
    wrappers = makeOutputWrappers "Copy" [input] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def stridedSliceGradGen chosenName shape begin end strides dy t index beginMask endMask ellipsisMask newAxisMask shrinkAxisMask:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "Index" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt index.num . toCArg]
    CString.with "begin_mask" nameCStr:
        callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt beginMask . toCArg]
    CString.with "end_mask" nameCStr:
        callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt endMask . toCArg]
    CString.with "ellipsis_mask" nameCStr:
        callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt ellipsisMask . toCArg]
    CString.with "new_axis_mask" nameCStr:
        callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt newAxisMask . toCArg]
    CString.with "shrink_axis_mask" nameCStr:
        callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt shrinkAxisMask . toCArg]
    wrappers = makeOutputWrappers "StridedSliceGrad" [shape, begin, end, strides, dy] [dy.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def stridedSliceAssignGen chosenName ref begin end strides value t index beginMask endMask ellipsisMask newAxisMask shrinkAxisMask:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "Index" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt index.num . toCArg]
    CString.with "begin_mask" nameCStr:
        callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt beginMask . toCArg]
    CString.with "end_mask" nameCStr:
        callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt endMask . toCArg]
    CString.with "ellipsis_mask" nameCStr:
        callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt ellipsisMask . toCArg]
    CString.with "new_axis_mask" nameCStr:
        callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt newAxisMask . toCArg]
    CString.with "shrink_axis_mask" nameCStr:
        callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt shrinkAxisMask . toCArg]
    wrappers = makeOutputWrappers "StridedSliceAssign" [ref, begin, end, strides, value] [ref.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def tileGradGen chosenName input multiples t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "TileGrad" [input, multiples] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def dataFormatDimMapGen chosenName x t srcFormat dstFormat:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "src_format" nameCStr:
        CString.with srcFormat valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    CString.with "dst_format" nameCStr:
        CString.with dstFormat valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    wrappers = makeOutputWrappers "DataFormatDimMap" [x] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def broadcastArgsGen chosenName s0 s1 t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "BroadcastArgs" [s0, s1] [s0.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def broadcastGradientArgsGen chosenName s0 s1 t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "BroadcastGradientArgs" [s0, s1] [s0.wrapper.typetag, s0.wrapper.typetag] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def placeholderV2Gen chosenName dtype shape:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "dtype" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt dtype.num . toCArg]
    CString.with "shape" nameCStr:
        cdims = shape.map CInt64.fromInt
        Array CInt64 . with cdims cdimsArray:
            callHandlingError "add_attr_shape" None [attrList.toCArg, nameCStr.toCArg, cdimsArray.toCArg, CUInt32.fromInt shape.length . toCArg]
    wrappers = makeOutputWrappers "PlaceholderV2" [] [dtype] attrList chosenName
    TFOutput wrappers.head.get

def expandDimsGen chosenName input dim t tdim:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "Tdim" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tdim.num . toCArg]
    wrappers = makeOutputWrappers "ExpandDims" [input, dim] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def squeezeGen chosenName input t squeezeDims:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "squeeze_dims" nameCStr:
        cvalues = squeezeDims.map CInt64.fromInt
        Array CInt64 . with cvalues cvaluesArray:
            callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt squeezeDims.length . toCArg]
    wrappers = makeOutputWrappers "Squeeze" [input] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def spaceToBatchNDGen chosenName input blockShape paddings t tblockShape tpaddings:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "Tblock_shape" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tblockShape.num . toCArg]
    CString.with "Tpaddings" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tpaddings.num . toCArg]
    wrappers = makeOutputWrappers "SpaceToBatchND" [input, blockShape, paddings] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def quantizeAndDequantizeV2Gen chosenName input inputMin inputMax signedInput numBits rangeGiven t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "signed_input" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if signedInput then 1 else 0) . toCArg]
    CString.with "num_bits" nameCStr:
        callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt numBits . toCArg]
    CString.with "range_given" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if rangeGiven then 1 else 0) . toCArg]
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "QuantizeAndDequantizeV2" [input, inputMin, inputMax] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def batchToSpaceNDGen chosenName input blockShape crops t tblockShape tcrops:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "Tblock_shape" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tblockShape.num . toCArg]
    CString.with "Tcrops" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tcrops.num . toCArg]
    wrappers = makeOutputWrappers "BatchToSpaceND" [input, blockShape, crops] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def extractImagePatchesGen chosenName images ksizes strides rates t padding:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "ksizes" nameCStr:
        cvalues = ksizes.map CInt64.fromInt
        Array CInt64 . with cvalues cvaluesArray:
            callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt ksizes.length . toCArg]
    CString.with "strides" nameCStr:
        cvalues = strides.map CInt64.fromInt
        Array CInt64 . with cvalues cvaluesArray:
            callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
    CString.with "rates" nameCStr:
        cvalues = rates.map CInt64.fromInt
        Array CInt64 . with cvalues cvaluesArray:
            callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt rates.length . toCArg]
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "padding" nameCStr:
        CString.with padding valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    wrappers = makeOutputWrappers "ExtractImagePatches" [images] [images.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def bitcastGen chosenName input t type:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "type" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt type.num . toCArg]
    wrappers = makeOutputWrappers "Bitcast" [input] [type] attrList chosenName
    TFOutput wrappers.head.get

def accumulatorNumAccumulatedGen chosenName handle:
    wrappers = makeOutputWrappers "AccumulatorNumAccumulated" [handle] [Int32Type] attrList chosenName
    TFOutput wrappers.head.get

def oneHotGen chosenName indices depth onValue offValue axis t tI:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "axis" nameCStr:
        callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt axis . toCArg]
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "TI" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tI.num . toCArg]
    wrappers = makeOutputWrappers "OneHot" [indices, depth, onValue, offValue] [onValue.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def whereGen chosenName input t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "Where" [input] [Int64Type] attrList chosenName
    TFOutput wrappers.head.get

def quantizeAndDequantizeGen chosenName input signedInput numBits rangeGiven inputMin inputMax t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "signed_input" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if signedInput then 1 else 0) . toCArg]
    CString.with "num_bits" nameCStr:
        callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt numBits . toCArg]
    CString.with "range_given" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if rangeGiven then 1 else 0) . toCArg]
    CString.with "input_min" nameCStr:
        callHandlingError "add_attr_float" None [attrList.toCArg, nameCStr.toCArg, CFloat.fromReal inputMin . toCArg]
    CString.with "input_max" nameCStr:
        callHandlingError "add_attr_float" None [attrList.toCArg, nameCStr.toCArg, CFloat.fromReal inputMax . toCArg]
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "QuantizeAndDequantize" [input] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def quantizeAndDequantizeV3Gen chosenName input inputMin inputMax numBits signedInput rangeGiven t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "signed_input" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if signedInput then 1 else 0) . toCArg]
    CString.with "range_given" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if rangeGiven then 1 else 0) . toCArg]
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "QuantizeAndDequantizeV3" [input, inputMin, inputMax, numBits] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def sparseApplyProximalAdagradGen chosenName var accum lr l1 l2 grad indices t tindices useLocking:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "Tindices" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
    CString.with "use_locking" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useLocking then 1 else 0) . toCArg]
    wrappers = makeOutputWrappers "SparseApplyProximalAdagrad" [var, accum, lr, l1, l2, grad, indices] [var.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def quantizedReshapeGen chosenName tensor shape inputMin inputMax t tshape:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "Tshape" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tshape.num . toCArg]
    wrappers = makeOutputWrappers "QuantizedReshape" [tensor, shape, inputMin, inputMax] [tensor.wrapper.typetag, FloatType, FloatType] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def diagPartGen chosenName input t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "DiagPart" [input] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def fakeQuantWithMinMaxVarsPerChannelGradientGen chosenName gradients inputs min max numBits narrowRange:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "num_bits" nameCStr:
        callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt numBits . toCArg]
    CString.with "narrow_range" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if narrowRange then 1 else 0) . toCArg]
    wrappers = makeOutputWrappers "FakeQuantWithMinMaxVarsPerChannelGradient" [gradients, inputs, min, max] [FloatType, FloatType, FloatType] attrList chosenName
    wrappers.each (wrapper: TFOutput wrapper)

def batchMatrixSetDiagGen chosenName input diagonal t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "BatchMatrixSetDiag" [input, diagonal] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def batchMatrixBandPartGen chosenName input numLower numUpper t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "BatchMatrixBandPart" [input, numLower, numUpper] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def batchMatrixDeterminantGen chosenName input t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "BatchMatrixDeterminant" [input] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def enterGen chosenName data t frameName isConstant parallelIterations:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "frame_name" nameCStr:
        CString.with frameName valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    CString.with "is_constant" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if isConstant then 1 else 0) . toCArg]
    CString.with "parallel_iterations" nameCStr:
        callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt parallelIterations . toCArg]
    wrappers = makeOutputWrappers "Enter" [data] [data.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def negGen chosenName x t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "Neg" [x] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def reciprocalGradGen chosenName y dy t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "ReciprocalGrad" [y, dy] [y.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def squareGen chosenName x t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "Square" [x] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def conv3DBackpropFilterGen chosenName input filter outBackprop t strides padding dilations:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "strides" nameCStr:
        cvalues = strides.map CInt64.fromInt
        Array CInt64 . with cvalues cvaluesArray:
            callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
    CString.with "padding" nameCStr:
        CString.with padding valCStr:
            callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
    CString.with "dilations" nameCStr:
        cvalues = dilations.map CInt64.fromInt
        Array CInt64 . with cvalues cvaluesArray:
            callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt dilations.length . toCArg]
    wrappers = makeOutputWrappers "Conv3DBackpropFilter" [input, filter, outBackprop] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def sqrtGen chosenName x t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "Sqrt" [x] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def expGen chosenName x t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "Exp" [x] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def logGen chosenName x t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "Log" [x] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def sparseSegmentMeanWithNumSegmentsGen chosenName data indices segmentIds numSegments t tidx tnumsegments:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "Tidx" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tidx.num . toCArg]
    CString.with "Tnumsegments" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tnumsegments.num . toCArg]
    wrappers = makeOutputWrappers "SparseSegmentMeanWithNumSegments" [data, indices, segmentIds, numSegments] [data.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def coshGen chosenName x t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "Cosh" [x] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def segmentMaxGen chosenName data segmentIds t tindices:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "Tindices" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
    wrappers = makeOutputWrappers "SegmentMax" [data, segmentIds] [data.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def tanhGen chosenName x t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "Tanh" [x] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def hSVToRGBGen chosenName images t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "HSVToRGB" [images] [images.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def sigmoidGradGen chosenName y dy t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "SigmoidGrad" [y, dy] [y.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def sinGen chosenName x t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "Sin" [x] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def acosGen chosenName x t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "Acos" [x] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def scatterDivGen chosenName ref indices updates t tindices useLocking:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "Tindices" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
    CString.with "use_locking" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useLocking then 1 else 0) . toCArg]
    wrappers = makeOutputWrappers "ScatterDiv" [ref, indices, updates] [ref.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def encodeWavGen chosenName audio sampleRate:
    wrappers = makeOutputWrappers "EncodeWav" [audio, sampleRate] [StringType] attrList chosenName
    TFOutput wrappers.head.get

def atanGen chosenName x t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "Atan" [x] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def besselI0eGen chosenName x t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "BesselI0e" [x] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def minGen chosenName input reductionIndices keepDims t tidx:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "keep_dims" nameCStr:
        callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if keepDims then 1 else 0) . toCArg]
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "Tidx" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tidx.num . toCArg]
    wrappers = makeOutputWrappers "Min" [input, reductionIndices] [input.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def transposeGen chosenName x perm t tperm:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "Tperm" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tperm.num . toCArg]
    wrappers = makeOutputWrappers "Transpose" [x, perm] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def besselI1eGen chosenName x t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "BesselI1e" [x] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def signGen chosenName x t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "Sign" [x] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def ceilGen chosenName x t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "Ceil" [x] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def rintGen chosenName x t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "Rint" [x] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def addV2Gen chosenName x y t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "AddV2" [x, y] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def encodePngGen chosenName image compression t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "compression" nameCStr:
        callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt compression . toCArg]
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "EncodePng" [image] [StringType] attrList chosenName
    TFOutput wrappers.head.get

def tensorArrayPackGen chosenName handle flowIn dtype elementShape:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "dtype" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt dtype.num . toCArg]
    CString.with "element_shape" nameCStr:
        cdims = elementShape.map CInt64.fromInt
        Array CInt64 . with cdims cdimsArray:
            callHandlingError "add_attr_shape" None [attrList.toCArg, nameCStr.toCArg, cdimsArray.toCArg, CUInt32.fromInt elementShape.length . toCArg]
    wrappers = makeOutputWrappers "TensorArrayPack" [handle, flowIn] [dtype] attrList chosenName
    TFOutput wrappers.head.get

def maximumGen chosenName x y t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "Maximum" [x, y] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def truncateModGen chosenName x y t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "TruncateMod" [x, y] [x.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def sparseSegmentSqrtNWithNumSegmentsGen chosenName data indices segmentIds numSegments t tidx tnumsegments:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    CString.with "Tidx" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tidx.num . toCArg]
    CString.with "Tnumsegments" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tnumsegments.num . toCArg]
    wrappers = makeOutputWrappers "SparseSegmentSqrtNWithNumSegments" [data, indices, segmentIds, numSegments] [data.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def igammacGen chosenName a x t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "Igammac" [a, x] [a.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get

def igammaGen chosenName a x t:
    attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
    attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
    CString.with "T" nameCStr:
        callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
    wrappers = makeOutputWrappers "Igamma" [a, x] [a.wrapper.typetag] attrList chosenName
    TFOutput wrappers.head.get
