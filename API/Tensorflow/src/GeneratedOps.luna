import Std.Foreign
import Std.Foreign.C.Value
import Tensorflow.CWrappers.Operations
import Tensorflow.CWrappers.Helpers
import Tensorflow.Types
import Tensorflow.Operations


class GeneratedOps:
    GeneratedOps

    def fractionalAvgPoolGrad chosenName origInputTensorShape outBackprop rowPoolingSequence colPoolingSequence overlapping t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "overlapping" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if overlapping then 1 else 0) . toCArg]
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "FractionalAvgPoolGrad" [origInputTensorShape.wrapper, outBackprop.wrapper, rowPoolingSequence.wrapper, colPoolingSequence.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get outBackprop.typetag

    def fractionalAvgPool chosenName value poolingRatio pseudoRandom overlapping deterministic seed seed2 t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "pooling_ratio" nameCStr:
            cvalues = poolingRatio.map CFloat.fromReal
            Array CFloat . with cvalues cvaluesArray:
                callHandlingError "add_attr_float_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt poolingRatio.length . toCArg]
        CString.with "pseudo_random" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if pseudoRandom then 1 else 0) . toCArg]
        CString.with "overlapping" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if overlapping then 1 else 0) . toCArg]
        CString.with "deterministic" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if deterministic then 1 else 0) . toCArg]
        CString.with "seed" nameCStr:
                callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt seed . toCArg]
        CString.with "seed2" nameCStr:
                callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt seed2 . toCArg]
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "FractionalAvgPool" [value.wrapper] 3 attrList chosenName
            (TFOutput (wrappers.getAt 0) value.typetag, TFOutput (wrappers.getAt 1) Int64Type, TFOutput (wrappers.getAt 2) Int64Type)

    def fractionalMaxPoolGrad chosenName origInput origOutput outBackprop rowPoolingSequence colPoolingSequence overlapping t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "overlapping" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if overlapping then 1 else 0) . toCArg]
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "FractionalMaxPoolGrad" [origInput.wrapper, origOutput.wrapper, outBackprop.wrapper, rowPoolingSequence.wrapper, colPoolingSequence.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get origInput.typetag

    def topKV2 chosenName input k sorted t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "sorted" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if sorted then 1 else 0) . toCArg]
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "TopKV2" [input.wrapper, k.wrapper] 2 attrList chosenName
            (TFOutput (wrappers.getAt 0) input.typetag, TFOutput (wrappers.getAt 1) Int32Type)

    def inTopKV2 chosenName predictions targets k t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "InTopKV2" [predictions.wrapper, targets.wrapper, k.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get BoolType

    def inTopK chosenName predictions targets k t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "k" nameCStr:
                callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt k . toCArg]
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "InTopK" [predictions.wrapper, targets.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get BoolType

    def sparseSoftmaxCrossEntropyWithLogits chosenName features labels t tlabels:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "Tlabels" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tlabels.num . toCArg]
        wrappers = makeOutputWrappers "SparseSoftmaxCrossEntropyWithLogits" [features.wrapper, labels.wrapper] 2 attrList chosenName
            (TFOutput (wrappers.getAt 0) features.typetag, TFOutput (wrappers.getAt 1) features.typetag)

    def softmaxCrossEntropyWithLogits chosenName features labels t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "SoftmaxCrossEntropyWithLogits" [features.wrapper, labels.wrapper] 2 attrList chosenName
            (TFOutput (wrappers.getAt 0) features.typetag, TFOutput (wrappers.getAt 1) features.typetag)

    def softmax chosenName logits t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "Softmax" [logits.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get logits.typetag

    def softsignGrad chosenName gradients features t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "SoftsignGrad" [gradients.wrapper, features.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get gradients.typetag

    def softsign chosenName features t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "Softsign" [features.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get features.typetag

    def elu chosenName features t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "Elu" [features.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get features.typetag

    def relu6Grad chosenName gradients features t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "Relu6Grad" [gradients.wrapper, features.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get gradients.typetag

    def relu6 chosenName features t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "Relu6" [features.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get features.typetag

    def reluGrad chosenName gradients features t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "ReluGrad" [gradients.wrapper, features.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get gradients.typetag

    def dilation2DBackpropInput chosenName input filter outBackprop t strides rates padding:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "strides" nameCStr:
            cvalues = strides.map CInt64.fromInt
            Array CInt64 . with cvalues cvaluesArray:
                callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
        CString.with "rates" nameCStr:
            cvalues = rates.map CInt64.fromInt
            Array CInt64 . with cvalues cvaluesArray:
                callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt rates.length . toCArg]
        CString.with "padding" nameCStr:
            CString.with padding valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        wrappers = makeOutputWrappers "Dilation2DBackpropInput" [input.wrapper, filter.wrapper, outBackprop.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get input.typetag

    def maxPoolGradGradWithArgmax chosenName input grad argmax ksize strides padding targmax t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "ksize" nameCStr:
            cvalues = ksize.map CInt64.fromInt
            Array CInt64 . with cvalues cvaluesArray:
                callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt ksize.length . toCArg]
        CString.with "strides" nameCStr:
            cvalues = strides.map CInt64.fromInt
            Array CInt64 . with cvalues cvaluesArray:
                callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
        CString.with "padding" nameCStr:
            CString.with padding valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        CString.with "Targmax" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt targmax.num . toCArg]
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "MaxPoolGradGradWithArgmax" [input.wrapper, grad.wrapper, argmax.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get input.typetag

    def maxPoolGradWithArgmax chosenName input grad argmax ksize strides padding targmax t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "ksize" nameCStr:
            cvalues = ksize.map CInt64.fromInt
            Array CInt64 . with cvalues cvaluesArray:
                callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt ksize.length . toCArg]
        CString.with "strides" nameCStr:
            cvalues = strides.map CInt64.fromInt
            Array CInt64 . with cvalues cvaluesArray:
                callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
        CString.with "padding" nameCStr:
            CString.with padding valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        CString.with "Targmax" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt targmax.num . toCArg]
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "MaxPoolGradWithArgmax" [input.wrapper, grad.wrapper, argmax.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get input.typetag

    def maxPoolGradGradV2 chosenName origInput origOutput grad ksize strides padding dataFormat t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "padding" nameCStr:
            CString.with padding valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        CString.with "data_format" nameCStr:
            CString.with dataFormat valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "MaxPoolGradGradV2" [origInput.wrapper, origOutput.wrapper, grad.wrapper, ksize.wrapper, strides.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get origInput.typetag

    def maxPoolGrad chosenName origInput origOutput grad ksize strides padding dataFormat t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "ksize" nameCStr:
            cvalues = ksize.map CInt64.fromInt
            Array CInt64 . with cvalues cvaluesArray:
                callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt ksize.length . toCArg]
        CString.with "strides" nameCStr:
            cvalues = strides.map CInt64.fromInt
            Array CInt64 . with cvalues cvaluesArray:
                callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
        CString.with "padding" nameCStr:
            CString.with padding valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        CString.with "data_format" nameCStr:
            CString.with dataFormat valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "MaxPoolGrad" [origInput.wrapper, origOutput.wrapper, grad.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get origInput.typetag

    def maxPool chosenName input t ksize strides padding dataFormat:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "ksize" nameCStr:
            cvalues = ksize.map CInt64.fromInt
            Array CInt64 . with cvalues cvaluesArray:
                callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt ksize.length . toCArg]
        CString.with "strides" nameCStr:
            cvalues = strides.map CInt64.fromInt
            Array CInt64 . with cvalues cvaluesArray:
                callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
        CString.with "padding" nameCStr:
            CString.with padding valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        CString.with "data_format" nameCStr:
            CString.with dataFormat valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        wrappers = makeOutputWrappers "MaxPool" [input.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get input.typetag

    def lRN chosenName input depthRadius bias alpha beta t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "depth_radius" nameCStr:
                callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt depthRadius . toCArg]
        CString.with "bias" nameCStr:
            callHandlingError "add_attr_float" None [attrList.toCArg, nameCStr.toCArg, CFloat.fromReal bias . toCArg]
        CString.with "alpha" nameCStr:
            callHandlingError "add_attr_float" None [attrList.toCArg, nameCStr.toCArg, CFloat.fromReal alpha . toCArg]
        CString.with "beta" nameCStr:
            callHandlingError "add_attr_float" None [attrList.toCArg, nameCStr.toCArg, CFloat.fromReal beta . toCArg]
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "LRN" [input.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get input.typetag

    def maxPool3DGrad chosenName origInput origOutput grad ksize strides padding dataFormat t tInput:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "ksize" nameCStr:
            cvalues = ksize.map CInt64.fromInt
            Array CInt64 . with cvalues cvaluesArray:
                callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt ksize.length . toCArg]
        CString.with "strides" nameCStr:
            cvalues = strides.map CInt64.fromInt
            Array CInt64 . with cvalues cvaluesArray:
                callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
        CString.with "padding" nameCStr:
            CString.with padding valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        CString.with "data_format" nameCStr:
            CString.with dataFormat valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "TInput" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tInput.num . toCArg]
        wrappers = makeOutputWrappers "MaxPool3DGrad" [origInput.wrapper, origOutput.wrapper, grad.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get grad.typetag

    def maxPool3DGradGrad chosenName origInput origOutput grad ksize strides padding dataFormat t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "ksize" nameCStr:
            cvalues = ksize.map CInt64.fromInt
            Array CInt64 . with cvalues cvaluesArray:
                callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt ksize.length . toCArg]
        CString.with "strides" nameCStr:
            cvalues = strides.map CInt64.fromInt
            Array CInt64 . with cvalues cvaluesArray:
                callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
        CString.with "padding" nameCStr:
            CString.with padding valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        CString.with "data_format" nameCStr:
            CString.with dataFormat valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "MaxPool3DGradGrad" [origInput.wrapper, origOutput.wrapper, grad.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get origInput.typetag

    def conv3DBackpropFilterV2 chosenName input filterSizes outBackprop t strides padding dataFormat dilations:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "strides" nameCStr:
            cvalues = strides.map CInt64.fromInt
            Array CInt64 . with cvalues cvaluesArray:
                callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
        CString.with "padding" nameCStr:
            CString.with padding valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        CString.with "data_format" nameCStr:
            CString.with dataFormat valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        CString.with "dilations" nameCStr:
            cvalues = dilations.map CInt64.fromInt
            Array CInt64 . with cvalues cvaluesArray:
                callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt dilations.length . toCArg]
        wrappers = makeOutputWrappers "Conv3DBackpropFilterV2" [input.wrapper, filterSizes.wrapper, outBackprop.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get input.typetag

    def conv3D chosenName input filter t strides padding dataFormat dilations:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "strides" nameCStr:
            cvalues = strides.map CInt64.fromInt
            Array CInt64 . with cvalues cvaluesArray:
                callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
        CString.with "padding" nameCStr:
            CString.with padding valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        CString.with "data_format" nameCStr:
            CString.with dataFormat valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        CString.with "dilations" nameCStr:
            cvalues = dilations.map CInt64.fromInt
            Array CInt64 . with cvalues cvaluesArray:
                callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt dilations.length . toCArg]
        wrappers = makeOutputWrappers "Conv3D" [input.wrapper, filter.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get input.typetag

    def depthwiseConv2dNativeBackpropFilter chosenName input filterSizes outBackprop t strides padding dataFormat dilations:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "strides" nameCStr:
            cvalues = strides.map CInt64.fromInt
            Array CInt64 . with cvalues cvaluesArray:
                callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
        CString.with "padding" nameCStr:
            CString.with padding valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        CString.with "data_format" nameCStr:
            CString.with dataFormat valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        CString.with "dilations" nameCStr:
            cvalues = dilations.map CInt64.fromInt
            Array CInt64 . with cvalues cvaluesArray:
                callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt dilations.length . toCArg]
        wrappers = makeOutputWrappers "DepthwiseConv2dNativeBackpropFilter" [input.wrapper, filterSizes.wrapper, outBackprop.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get input.typetag

    def depthwiseConv2dNativeBackpropInput chosenName inputSizes filter outBackprop t strides padding dataFormat dilations:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "strides" nameCStr:
            cvalues = strides.map CInt64.fromInt
            Array CInt64 . with cvalues cvaluesArray:
                callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
        CString.with "padding" nameCStr:
            CString.with padding valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        CString.with "data_format" nameCStr:
            CString.with dataFormat valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        CString.with "dilations" nameCStr:
            cvalues = dilations.map CInt64.fromInt
            Array CInt64 . with cvalues cvaluesArray:
                callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt dilations.length . toCArg]
        wrappers = makeOutputWrappers "DepthwiseConv2dNativeBackpropInput" [inputSizes.wrapper, filter.wrapper, outBackprop.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get filter.typetag

    def depthwiseConv2dNative chosenName input filter t strides padding dataFormat dilations:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "strides" nameCStr:
            cvalues = strides.map CInt64.fromInt
            Array CInt64 . with cvalues cvaluesArray:
                callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
        CString.with "padding" nameCStr:
            CString.with padding valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        CString.with "data_format" nameCStr:
            CString.with dataFormat valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        CString.with "dilations" nameCStr:
            cvalues = dilations.map CInt64.fromInt
            Array CInt64 . with cvalues cvaluesArray:
                callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt dilations.length . toCArg]
        wrappers = makeOutputWrappers "DepthwiseConv2dNative" [input.wrapper, filter.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get input.typetag

    def fusedResizeAndPadConv2D chosenName input size paddings filter t resizeAlignCorners mode strides padding:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "resize_align_corners" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if resizeAlignCorners then 1 else 0) . toCArg]
        CString.with "mode" nameCStr:
            CString.with mode valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        CString.with "strides" nameCStr:
            cvalues = strides.map CInt64.fromInt
            Array CInt64 . with cvalues cvaluesArray:
                callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
        CString.with "padding" nameCStr:
            CString.with padding valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        wrappers = makeOutputWrappers "FusedResizeAndPadConv2D" [input.wrapper, size.wrapper, paddings.wrapper, filter.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get input.typetag

    def dataFormatVecPermute chosenName x t srcFormat dstFormat:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "src_format" nameCStr:
            CString.with srcFormat valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        CString.with "dst_format" nameCStr:
            CString.with dstFormat valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        wrappers = makeOutputWrappers "DataFormatVecPermute" [x.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get x.typetag

    def conv2DBackpropFilter chosenName input filterSizes outBackprop t strides useCudnnOnGpu padding dataFormat dilations:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "strides" nameCStr:
            cvalues = strides.map CInt64.fromInt
            Array CInt64 . with cvalues cvaluesArray:
                callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
        CString.with "use_cudnn_on_gpu" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useCudnnOnGpu then 1 else 0) . toCArg]
        CString.with "padding" nameCStr:
            CString.with padding valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        CString.with "data_format" nameCStr:
            CString.with dataFormat valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        CString.with "dilations" nameCStr:
            cvalues = dilations.map CInt64.fromInt
            Array CInt64 . with cvalues cvaluesArray:
                callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt dilations.length . toCArg]
        wrappers = makeOutputWrappers "Conv2DBackpropFilter" [input.wrapper, filterSizes.wrapper, outBackprop.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get input.typetag

    def biasAdd chosenName value bias t dataFormat:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "data_format" nameCStr:
            CString.with dataFormat valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        wrappers = makeOutputWrappers "BiasAdd" [value.wrapper, bias.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get value.typetag

    def fusedBatchNorm chosenName x scale offset mean variance t epsilon dataFormat isTraining:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "epsilon" nameCStr:
            callHandlingError "add_attr_float" None [attrList.toCArg, nameCStr.toCArg, CFloat.fromReal epsilon . toCArg]
        CString.with "data_format" nameCStr:
            CString.with dataFormat valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        CString.with "is_training" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if isTraining then 1 else 0) . toCArg]
        wrappers = makeOutputWrappers "FusedBatchNorm" [x.wrapper, scale.wrapper, offset.wrapper, mean.wrapper, variance.wrapper] 5 attrList chosenName
            (TFOutput (wrappers.getAt 0) x.typetag, TFOutput (wrappers.getAt 1) x.typetag, TFOutput (wrappers.getAt 2) x.typetag, TFOutput (wrappers.getAt 3) x.typetag, TFOutput (wrappers.getAt 4) x.typetag)

    def avgPoolGrad chosenName origInputShape grad ksize strides padding dataFormat t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "ksize" nameCStr:
            cvalues = ksize.map CInt64.fromInt
            Array CInt64 . with cvalues cvaluesArray:
                callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt ksize.length . toCArg]
        CString.with "strides" nameCStr:
            cvalues = strides.map CInt64.fromInt
            Array CInt64 . with cvalues cvaluesArray:
                callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
        CString.with "padding" nameCStr:
            CString.with padding valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        CString.with "data_format" nameCStr:
            CString.with dataFormat valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "AvgPoolGrad" [origInputShape.wrapper, grad.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get grad.typetag

    def clipByValue chosenName t clipValueMin clipValueMax t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "ClipByValue" [t.wrapper, clipValueMin.wrapper, clipValueMax.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get t.typetag

    def cumprod chosenName x axis exclusive reverse t tidx:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "exclusive" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if exclusive then 1 else 0) . toCArg]
        CString.with "reverse" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if reverse then 1 else 0) . toCArg]
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "Tidx" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tidx.num . toCArg]
        wrappers = makeOutputWrappers "Cumprod" [x.wrapper, axis.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get x.typetag

    def cumsum chosenName x axis exclusive reverse t tidx:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "exclusive" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if exclusive then 1 else 0) . toCArg]
        CString.with "reverse" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if reverse then 1 else 0) . toCArg]
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "Tidx" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tidx.num . toCArg]
        wrappers = makeOutputWrappers "Cumsum" [x.wrapper, axis.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get x.typetag

    def bincount chosenName arr size weights t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "Bincount" [arr.wrapper, size.wrapper, weights.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get weights.typetag

    def histogramFixedWidth chosenName values valueRange nbins t dtype:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "dtype" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt dtype.num . toCArg]
        wrappers = makeOutputWrappers "HistogramFixedWidth" [values.wrapper, valueRange.wrapper, nbins.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get dtype

    def range chosenName start limit delta tidx:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "Tidx" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tidx.num . toCArg]
        wrappers = makeOutputWrappers "Range" [start.wrapper, limit.wrapper, delta.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get start.typetag

    def lRNGrad chosenName inputGrads inputImage outputImage depthRadius bias alpha beta t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "depth_radius" nameCStr:
                callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt depthRadius . toCArg]
        CString.with "bias" nameCStr:
            callHandlingError "add_attr_float" None [attrList.toCArg, nameCStr.toCArg, CFloat.fromReal bias . toCArg]
        CString.with "alpha" nameCStr:
            callHandlingError "add_attr_float" None [attrList.toCArg, nameCStr.toCArg, CFloat.fromReal alpha . toCArg]
        CString.with "beta" nameCStr:
            callHandlingError "add_attr_float" None [attrList.toCArg, nameCStr.toCArg, CFloat.fromReal beta . toCArg]
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "LRNGrad" [inputGrads.wrapper, inputImage.wrapper, outputImage.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get inputGrads.typetag

    def any chosenName input reductionIndices keepDims tidx:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "keep_dims" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if keepDims then 1 else 0) . toCArg]
        CString.with "Tidx" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tidx.num . toCArg]
        wrappers = makeOutputWrappers "Any" [input.wrapper, reductionIndices.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get BoolType

    def sparseSegmentSqrtNGrad chosenName grad indices segmentIds outputDim0 t tidx:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "Tidx" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tidx.num . toCArg]
        wrappers = makeOutputWrappers "SparseSegmentSqrtNGrad" [grad.wrapper, indices.wrapper, segmentIds.wrapper, outputDim0.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get grad.typetag

    def sparseSegmentSqrtN chosenName data indices segmentIds t tidx:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "Tidx" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tidx.num . toCArg]
        wrappers = makeOutputWrappers "SparseSegmentSqrtN" [data.wrapper, indices.wrapper, segmentIds.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get data.typetag

    def sparseSegmentMean chosenName data indices segmentIds t tidx:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "Tidx" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tidx.num . toCArg]
        wrappers = makeOutputWrappers "SparseSegmentMean" [data.wrapper, indices.wrapper, segmentIds.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get data.typetag

    def sparseSegmentSumWithNumSegments chosenName data indices segmentIds numSegments t tidx tnumsegments:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "Tidx" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tidx.num . toCArg]
        CString.with "Tnumsegments" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tnumsegments.num . toCArg]
        wrappers = makeOutputWrappers "SparseSegmentSumWithNumSegments" [data.wrapper, indices.wrapper, segmentIds.wrapper, numSegments.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get data.typetag

    def sparseSegmentSum chosenName data indices segmentIds t tidx:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "Tidx" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tidx.num . toCArg]
        wrappers = makeOutputWrappers "SparseSegmentSum" [data.wrapper, indices.wrapper, segmentIds.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get data.typetag

    def unsortedSegmentProd chosenName data segmentIds numSegments t tindices tnumsegments:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "Tindices" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
        CString.with "Tnumsegments" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tnumsegments.num . toCArg]
        wrappers = makeOutputWrappers "UnsortedSegmentProd" [data.wrapper, segmentIds.wrapper, numSegments.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get data.typetag

    def unsortedSegmentMin chosenName data segmentIds numSegments t tindices tnumsegments:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "Tindices" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
        CString.with "Tnumsegments" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tnumsegments.num . toCArg]
        wrappers = makeOutputWrappers "UnsortedSegmentMin" [data.wrapper, segmentIds.wrapper, numSegments.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get data.typetag

    def nthElement chosenName input n reverse t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "reverse" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if reverse then 1 else 0) . toCArg]
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "NthElement" [input.wrapper, n.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get input.typetag

    def unsortedSegmentMax chosenName data segmentIds numSegments t tindices tnumsegments:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "Tindices" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
        CString.with "Tnumsegments" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tnumsegments.num . toCArg]
        wrappers = makeOutputWrappers "UnsortedSegmentMax" [data.wrapper, segmentIds.wrapper, numSegments.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get data.typetag

    def unsortedSegmentSum chosenName data segmentIds numSegments t tindices tnumsegments:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "Tindices" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
        CString.with "Tnumsegments" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tnumsegments.num . toCArg]
        wrappers = makeOutputWrappers "UnsortedSegmentSum" [data.wrapper, segmentIds.wrapper, numSegments.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get data.typetag

    def segmentMin chosenName data segmentIds t tindices:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "Tindices" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
        wrappers = makeOutputWrappers "SegmentMin" [data.wrapper, segmentIds.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get data.typetag

    def segmentMean chosenName data segmentIds t tindices:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "Tindices" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
        wrappers = makeOutputWrappers "SegmentMean" [data.wrapper, segmentIds.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get data.typetag

    def argMin chosenName input dimension t tidx outputType:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "Tidx" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tidx.num . toCArg]
        CString.with "output_type" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt outputType.num . toCArg]
        wrappers = makeOutputWrappers "ArgMin" [input.wrapper, dimension.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get outputType

    def max chosenName input reductionIndices keepDims t tidx:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "keep_dims" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if keepDims then 1 else 0) . toCArg]
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "Tidx" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tidx.num . toCArg]
        wrappers = makeOutputWrappers "Max" [input.wrapper, reductionIndices.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get input.typetag

    def sum chosenName input reductionIndices keepDims t tidx:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "keep_dims" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if keepDims then 1 else 0) . toCArg]
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "Tidx" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tidx.num . toCArg]
        wrappers = makeOutputWrappers "Sum" [input.wrapper, reductionIndices.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get input.typetag

    def sparseMatMul chosenName a b transposeA transposeB aIsSparse bIsSparse ta tb:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "transpose_a" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if transposeA then 1 else 0) . toCArg]
        CString.with "transpose_b" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if transposeB then 1 else 0) . toCArg]
        CString.with "a_is_sparse" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if aIsSparse then 1 else 0) . toCArg]
        CString.with "b_is_sparse" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if bIsSparse then 1 else 0) . toCArg]
        CString.with "Ta" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt ta.num . toCArg]
        CString.with "Tb" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tb.num . toCArg]
        wrappers = makeOutputWrappers "SparseMatMul" [a.wrapper, b.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get FloatType

    def matMul chosenName a b transposeA transposeB t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "transpose_a" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if transposeA then 1 else 0) . toCArg]
        CString.with "transpose_b" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if transposeB then 1 else 0) . toCArg]
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "MatMul" [a.wrapper, b.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get a.typetag

    def select chosenName condition t e t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "Select" [condition.wrapper, t.wrapper, e.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get t.typetag

    def logicalOr chosenName x y:
        wrappers = makeOutputWrappers "LogicalOr" [x.wrapper, y.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get BoolType

    def logicalAnd chosenName x y:
        wrappers = makeOutputWrappers "LogicalAnd" [x.wrapper, y.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get BoolType

    def approximateEqual chosenName x y t tolerance:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "tolerance" nameCStr:
            callHandlingError "add_attr_float" None [attrList.toCArg, nameCStr.toCArg, CFloat.fromReal tolerance . toCArg]
        wrappers = makeOutputWrappers "ApproximateEqual" [x.wrapper, y.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get BoolType

    def notEqual chosenName x y t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "NotEqual" [x.wrapper, y.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get BoolType

    def greaterEqual chosenName x y t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "GreaterEqual" [x.wrapper, y.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get BoolType

    def greater chosenName x y t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "Greater" [x.wrapper, y.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get BoolType

    def lessEqual chosenName x y t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "LessEqual" [x.wrapper, y.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get BoolType

    def less chosenName x y t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "Less" [x.wrapper, y.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get BoolType

    def betainc chosenName a b x t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "Betainc" [a.wrapper, b.wrapper, x.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get a.typetag

    def polygamma chosenName a x t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "Polygamma" [a.wrapper, x.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get a.typetag

    def zeta chosenName x q t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "Zeta" [x.wrapper, q.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get x.typetag

    def mean chosenName input reductionIndices keepDims t tidx:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "keep_dims" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if keepDims then 1 else 0) . toCArg]
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "Tidx" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tidx.num . toCArg]
        wrappers = makeOutputWrappers "Mean" [input.wrapper, reductionIndices.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get input.typetag

    def initializeTableFromTextFile chosenName tableHandle filename keyIndex valueIndex vocabSize delimiter:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "key_index" nameCStr:
                callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt keyIndex . toCArg]
        CString.with "value_index" nameCStr:
                callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt valueIndex . toCArg]
        CString.with "vocab_size" nameCStr:
                callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt vocabSize . toCArg]
        CString.with "delimiter" nameCStr:
            CString.with delimiter valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        wrappers = makeOutputWrappers "InitializeTableFromTextFile" [tableHandle.wrapper, filename.wrapper] 0 attrList chosenName
        None

    def fakeQuantWithMinMaxVarsGradient chosenName gradients inputs min max numBits narrowRange:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "num_bits" nameCStr:
                callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt numBits . toCArg]
        CString.with "narrow_range" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if narrowRange then 1 else 0) . toCArg]
        wrappers = makeOutputWrappers "FakeQuantWithMinMaxVarsGradient" [gradients.wrapper, inputs.wrapper, min.wrapper, max.wrapper] 3 attrList chosenName
            (TFOutput (wrappers.getAt 0) FloatType, TFOutput (wrappers.getAt 1) FloatType, TFOutput (wrappers.getAt 2) FloatType)

    def minimum chosenName x y t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "Minimum" [x.wrapper, y.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get x.typetag

    def batchCholesky chosenName input t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "BatchCholesky" [input.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get input.typetag

    def resizeBilinearGrad chosenName grads originalImage t alignCorners:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "align_corners" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if alignCorners then 1 else 0) . toCArg]
        wrappers = makeOutputWrappers "ResizeBilinearGrad" [grads.wrapper, originalImage.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get originalImage.typetag

    def lookupTableSize chosenName tableHandle:
        wrappers = makeOutputWrappers "LookupTableSize" [tableHandle.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get Int64Type

    def bucketize chosenName input t boundaries:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "boundaries" nameCStr:
            cvalues = boundaries.map CFloat.fromReal
            Array CFloat . with cvalues cvaluesArray:
                callHandlingError "add_attr_float_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt boundaries.length . toCArg]
        wrappers = makeOutputWrappers "Bucketize" [input.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get Int32Type

    def lookupTableInsert chosenName tableHandle keys values tin tout:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "Tin" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tin.num . toCArg]
        CString.with "Tout" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tout.num . toCArg]
        wrappers = makeOutputWrappers "LookupTableInsert" [tableHandle.wrapper, keys.wrapper, values.wrapper] 0 attrList chosenName
        None

    def tPUReplicateMetadata chosenName numReplicas topology useTpu deviceAssignment computationShape hostComputeCore:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "num_replicas" nameCStr:
                callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt numReplicas . toCArg]
        CString.with "topology" nameCStr:
            CString.with topology valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        CString.with "use_tpu" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useTpu then 1 else 0) . toCArg]
        CString.with "device_assignment" nameCStr:
            cvalues = deviceAssignment.map CInt64.fromInt
            Array CInt64 . with cvalues cvaluesArray:
                callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt deviceAssignment.length . toCArg]
        CString.with "computation_shape" nameCStr:
            cvalues = computationShape.map CInt64.fromInt
            Array CInt64 . with cvalues cvaluesArray:
                callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt computationShape.length . toCArg]
        CString.with "host_compute_core" nameCStr:
            len = hostComputeCore.length
            cValues = ManagedPointer (Pointer CInt64) . mallocElems len
            indexed = 0.upto (len - 1) . zip hostComputeCore
            indexed.each (idx, elem):
                cValues.moveElems idx . write (CString.fromText elem)
            callHandlingError "add_attr_string_list" None [attrList.toCArg, nameCStr.toCArg, cValues.toCArg, CUInt32.fromInt len . toCArg]
            0.upto (len - 1) . each (idx: cValues.moveElems idx . read . free)
        wrappers = makeOutputWrappers "TPUReplicateMetadata" [] 0 attrList chosenName
        None

    def batchMatrixTriangularSolve chosenName matrix rhs lower adjoint t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "lower" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if lower then 1 else 0) . toCArg]
        CString.with "adjoint" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if adjoint then 1 else 0) . toCArg]
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "BatchMatrixTriangularSolve" [matrix.wrapper, rhs.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get matrix.typetag

    def batchSelfAdjointEig chosenName input t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "BatchSelfAdjointEig" [input.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get input.typetag

    def choleskyGrad chosenName l grad t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "CholeskyGrad" [l.wrapper, grad.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get l.typetag

    def fusedBatchNormGrad chosenName yBackprop x scale reserveSpace1 reserveSpace2 t epsilon dataFormat isTraining:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "epsilon" nameCStr:
            callHandlingError "add_attr_float" None [attrList.toCArg, nameCStr.toCArg, CFloat.fromReal epsilon . toCArg]
        CString.with "data_format" nameCStr:
            CString.with dataFormat valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        CString.with "is_training" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if isTraining then 1 else 0) . toCArg]
        wrappers = makeOutputWrappers "FusedBatchNormGrad" [yBackprop.wrapper, x.wrapper, scale.wrapper, reserveSpace1.wrapper, reserveSpace2.wrapper] 5 attrList chosenName
            (TFOutput (wrappers.getAt 0) yBackprop.typetag, TFOutput (wrappers.getAt 1) yBackprop.typetag, TFOutput (wrappers.getAt 2) yBackprop.typetag, TFOutput (wrappers.getAt 3) yBackprop.typetag, TFOutput (wrappers.getAt 4) yBackprop.typetag)

    def cos chosenName x t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "Cos" [x.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get x.typetag

    def cholesky chosenName input t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "Cholesky" [input.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get input.typetag

    def sparseApplyFtrlV2 chosenName var accum linear grad indices lr l1 l2 l2Shrinkage lrPower t tindices useLocking:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "Tindices" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
        CString.with "use_locking" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useLocking then 1 else 0) . toCArg]
        wrappers = makeOutputWrappers "SparseApplyFtrlV2" [var.wrapper, accum.wrapper, linear.wrapper, grad.wrapper, indices.wrapper, lr.wrapper, l1.wrapper, l2.wrapper, l2Shrinkage.wrapper, lrPower.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get var.typetag

    def maxPoolGradV2 chosenName origInput origOutput grad ksize strides padding dataFormat t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "padding" nameCStr:
            CString.with padding valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        CString.with "data_format" nameCStr:
            CString.with dataFormat valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "MaxPoolGradV2" [origInput.wrapper, origOutput.wrapper, grad.wrapper, ksize.wrapper, strides.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get origInput.typetag

    def readerNumRecordsProduced chosenName readerHandle:
        wrappers = makeOutputWrappers "ReaderNumRecordsProduced" [readerHandle.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get Int64Type

    def matrixInverse chosenName input adjoint t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "adjoint" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if adjoint then 1 else 0) . toCArg]
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "MatrixInverse" [input.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get input.typetag

    def statelessTruncatedNormal chosenName shape seed dtype t tseed:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "dtype" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt dtype.num . toCArg]
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "Tseed" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tseed.num . toCArg]
        wrappers = makeOutputWrappers "StatelessTruncatedNormal" [shape.wrapper, seed.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get dtype

    def noOp chosenName:
        wrappers = makeOutputWrappers "NoOp" [] 0 attrList chosenName
        None

    def nonMaxSuppressionV4 chosenName boxes scores maxOutputSize iouThreshold scoreThreshold padToMaxOutputSize:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "pad_to_max_output_size" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if padToMaxOutputSize then 1 else 0) . toCArg]
        wrappers = makeOutputWrappers "NonMaxSuppressionV4" [boxes.wrapper, scores.wrapper, maxOutputSize.wrapper, iouThreshold.wrapper, scoreThreshold.wrapper] 2 attrList chosenName
            (TFOutput (wrappers.getAt 0) Int32Type, TFOutput (wrappers.getAt 1) Int32Type)

    def nonMaxSuppression chosenName boxes scores maxOutputSize iouThreshold:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "iou_threshold" nameCStr:
            callHandlingError "add_attr_float" None [attrList.toCArg, nameCStr.toCArg, CFloat.fromReal iouThreshold . toCArg]
        wrappers = makeOutputWrappers "NonMaxSuppression" [boxes.wrapper, scores.wrapper, maxOutputSize.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get Int32Type

    def nonMaxSuppressionWithOverlaps chosenName overlaps scores maxOutputSize overlapThreshold scoreThreshold:
        wrappers = makeOutputWrappers "NonMaxSuppressionWithOverlaps" [overlaps.wrapper, scores.wrapper, maxOutputSize.wrapper, overlapThreshold.wrapper, scoreThreshold.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get Int32Type

    def computeAccidentalHits chosenName trueClasses sampledCandidates numTrue seed seed2:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "num_true" nameCStr:
                callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt numTrue . toCArg]
        CString.with "seed" nameCStr:
                callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt seed . toCArg]
        CString.with "seed2" nameCStr:
                callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt seed2 . toCArg]
        wrappers = makeOutputWrappers "ComputeAccidentalHits" [trueClasses.wrapper, sampledCandidates.wrapper] 3 attrList chosenName
            (TFOutput (wrappers.getAt 0) Int32Type, TFOutput (wrappers.getAt 1) Int64Type, TFOutput (wrappers.getAt 2) FloatType)

    def cropAndResizeGradBoxes chosenName grads image boxes boxInd t method:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "method" nameCStr:
            CString.with method valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        wrappers = makeOutputWrappers "CropAndResizeGradBoxes" [grads.wrapper, image.wrapper, boxes.wrapper, boxInd.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get FloatType

    def extractGlimpse chosenName input size offsets centered normalized uniformNoise:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "centered" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if centered then 1 else 0) . toCArg]
        CString.with "normalized" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if normalized then 1 else 0) . toCArg]
        CString.with "uniform_noise" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if uniformNoise then 1 else 0) . toCArg]
        wrappers = makeOutputWrappers "ExtractGlimpse" [input.wrapper, size.wrapper, offsets.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get FloatType

    def sparseSliceGrad chosenName backpropValGrad inputIndices inputStart outputIndices t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "SparseSliceGrad" [backpropValGrad.wrapper, inputIndices.wrapper, inputStart.wrapper, outputIndices.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get backpropValGrad.typetag

    def batchSvd chosenName input computeUv fullMatrices t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "compute_uv" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if computeUv then 1 else 0) . toCArg]
        CString.with "full_matrices" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if fullMatrices then 1 else 0) . toCArg]
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "BatchSvd" [input.wrapper] 3 attrList chosenName
            (TFOutput (wrappers.getAt 0) input.typetag, TFOutput (wrappers.getAt 1) input.typetag, TFOutput (wrappers.getAt 2) input.typetag)

    def rGBToHSV chosenName images t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "RGBToHSV" [images.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get images.typetag

    def decodeGif chosenName contents:
        wrappers = makeOutputWrappers "DecodeGif" [contents.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get UInt8Type

    def decodePng chosenName contents channels dtype:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "channels" nameCStr:
                callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt channels . toCArg]
        CString.with "dtype" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt dtype.num . toCArg]
        wrappers = makeOutputWrappers "DecodePng" [contents.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get dtype

    def adjustSaturation chosenName images scale:
        wrappers = makeOutputWrappers "AdjustSaturation" [images.wrapper, scale.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get FloatType

    def matrixSolve chosenName matrix rhs adjoint t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "adjoint" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if adjoint then 1 else 0) . toCArg]
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "MatrixSolve" [matrix.wrapper, rhs.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get matrix.typetag

    def softplusGrad chosenName gradients features t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "SoftplusGrad" [gradients.wrapper, features.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get gradients.typetag

    def selfAdjointEigV2 chosenName input computeV t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "compute_v" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if computeV then 1 else 0) . toCArg]
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "SelfAdjointEigV2" [input.wrapper] 2 attrList chosenName
            (TFOutput (wrappers.getAt 0) input.typetag, TFOutput (wrappers.getAt 1) input.typetag)

    def decodeJpeg chosenName contents channels ratio fancyUpscaling tryRecoverTruncated acceptableFraction dctMethod:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "channels" nameCStr:
                callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt channels . toCArg]
        CString.with "ratio" nameCStr:
                callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt ratio . toCArg]
        CString.with "fancy_upscaling" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if fancyUpscaling then 1 else 0) . toCArg]
        CString.with "try_recover_truncated" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if tryRecoverTruncated then 1 else 0) . toCArg]
        CString.with "acceptable_fraction" nameCStr:
            callHandlingError "add_attr_float" None [attrList.toCArg, nameCStr.toCArg, CFloat.fromReal acceptableFraction . toCArg]
        CString.with "dct_method" nameCStr:
            CString.with dctMethod valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        wrappers = makeOutputWrappers "DecodeJpeg" [contents.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get UInt8Type

    def fakeParam chosenName dtype shape:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "dtype" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt dtype.num . toCArg]
        CString.with "shape" nameCStr:
            cdims = shape.map CInt64.fromInt
            Array CInt64 . with cdims cdimsArray:
                callHandlingError "add_attr_shape" None [attrList.toCArg, nameCStr.toCArg, cdimsArray.toCArg, CUInt32.fromInt shape.length . toCArg]
        wrappers = makeOutputWrappers "FakeParam" [] 1 attrList chosenName
        TFOutput wrappers.head.get dtype

    def resizeNearestNeighbor chosenName images size t alignCorners:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "align_corners" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if alignCorners then 1 else 0) . toCArg]
        wrappers = makeOutputWrappers "ResizeNearestNeighbor" [images.wrapper, size.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get images.typetag

    def resizeBicubicGrad chosenName grads originalImage t alignCorners:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "align_corners" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if alignCorners then 1 else 0) . toCArg]
        wrappers = makeOutputWrappers "ResizeBicubicGrad" [grads.wrapper, originalImage.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get originalImage.typetag

    def resizeBicubic chosenName images size t alignCorners:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "align_corners" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if alignCorners then 1 else 0) . toCArg]
        wrappers = makeOutputWrappers "ResizeBicubic" [images.wrapper, size.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get FloatType

    def log1p chosenName x t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "Log1p" [x.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get x.typetag

    def tPUCompilationResult chosenName:
        wrappers = makeOutputWrappers "TPUCompilationResult" [] 1 attrList chosenName
        TFOutput wrappers.head.get StringType

    def nonMaxSuppressionV2 chosenName boxes scores maxOutputSize iouThreshold:
        wrappers = makeOutputWrappers "NonMaxSuppressionV2" [boxes.wrapper, scores.wrapper, maxOutputSize.wrapper, iouThreshold.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get Int32Type

    def reshape chosenName tensor shape t tshape:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "Tshape" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tshape.num . toCArg]
        wrappers = makeOutputWrappers "Reshape" [tensor.wrapper, shape.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get tensor.typetag

    def avgPool3D chosenName input ksize strides padding dataFormat t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "ksize" nameCStr:
            cvalues = ksize.map CInt64.fromInt
            Array CInt64 . with cvalues cvaluesArray:
                callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt ksize.length . toCArg]
        CString.with "strides" nameCStr:
            cvalues = strides.map CInt64.fromInt
            Array CInt64 . with cvalues cvaluesArray:
                callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
        CString.with "padding" nameCStr:
            CString.with padding valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        CString.with "data_format" nameCStr:
            CString.with dataFormat valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "AvgPool3D" [input.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get input.typetag

    def cross chosenName a b t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "Cross" [a.wrapper, b.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get a.typetag

    def tensorArrayUnpack chosenName handle value flowIn t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "TensorArrayUnpack" [handle.wrapper, value.wrapper, flowIn.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get FloatType

    def sinh chosenName x t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "Sinh" [x.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get x.typetag

    def dilation2D chosenName input filter t strides rates padding:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "strides" nameCStr:
            cvalues = strides.map CInt64.fromInt
            Array CInt64 . with cvalues cvaluesArray:
                callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
        CString.with "rates" nameCStr:
            cvalues = rates.map CInt64.fromInt
            Array CInt64 . with cvalues cvaluesArray:
                callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt rates.length . toCArg]
        CString.with "padding" nameCStr:
            CString.with padding valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        wrappers = makeOutputWrappers "Dilation2D" [input.wrapper, filter.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get input.typetag

    def tensorArrayConcatV2 chosenName handle flowIn dtype elementShapeExcept0:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "dtype" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt dtype.num . toCArg]
        CString.with "element_shape_except0" nameCStr:
            cdims = elementShapeExcept0.map CInt64.fromInt
            Array CInt64 . with cdims cdimsArray:
                callHandlingError "add_attr_shape" None [attrList.toCArg, nameCStr.toCArg, cdimsArray.toCArg, CUInt32.fromInt elementShapeExcept0.length . toCArg]
        wrappers = makeOutputWrappers "TensorArrayConcatV2" [handle.wrapper, flowIn.wrapper] 2 attrList chosenName
            (TFOutput (wrappers.getAt 0) dtype, TFOutput (wrappers.getAt 1) Int64Type)

    def atan2 chosenName y x t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "Atan2" [y.wrapper, x.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get y.typetag

    def identity chosenName input t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "Identity" [input.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get input.typetag

    def adjustContrastv2 chosenName images contrastFactor:
        wrappers = makeOutputWrappers "AdjustContrastv2" [images.wrapper, contrastFactor.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get FloatType

    def nonMaxSuppressionV3 chosenName boxes scores maxOutputSize iouThreshold scoreThreshold:
        wrappers = makeOutputWrappers "NonMaxSuppressionV3" [boxes.wrapper, scores.wrapper, maxOutputSize.wrapper, iouThreshold.wrapper, scoreThreshold.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get Int32Type

    def batchNormWithGlobalNormalizationGrad chosenName t m v gamma backprop t varianceEpsilon scaleAfterNormalization:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "variance_epsilon" nameCStr:
            callHandlingError "add_attr_float" None [attrList.toCArg, nameCStr.toCArg, CFloat.fromReal varianceEpsilon . toCArg]
        CString.with "scale_after_normalization" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if scaleAfterNormalization then 1 else 0) . toCArg]
        wrappers = makeOutputWrappers "BatchNormWithGlobalNormalizationGrad" [t.wrapper, m.wrapper, v.wrapper, gamma.wrapper, backprop.wrapper] 5 attrList chosenName
            (TFOutput (wrappers.getAt 0) t.typetag, TFOutput (wrappers.getAt 1) t.typetag, TFOutput (wrappers.getAt 2) t.typetag, TFOutput (wrappers.getAt 3) t.typetag, TFOutput (wrappers.getAt 4) t.typetag)

    def logMatrixDeterminant chosenName input t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "LogMatrixDeterminant" [input.wrapper] 2 attrList chosenName
            (TFOutput (wrappers.getAt 0) input.typetag, TFOutput (wrappers.getAt 1) input.typetag)

    def selu chosenName features t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "Selu" [features.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get features.typetag

    def setSize chosenName setIndices setValues setShape validateIndices t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "validate_indices" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if validateIndices then 1 else 0) . toCArg]
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "SetSize" [setIndices.wrapper, setValues.wrapper, setShape.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get Int32Type

    def substr chosenName input pos len t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "Substr" [input.wrapper, pos.wrapper, len.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get StringType

    def debugNumericSummary chosenName input t deviceName tensorName debugUrls lowerBound upperBound muteIfHealthy gatedGrpc:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "device_name" nameCStr:
            CString.with deviceName valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        CString.with "tensor_name" nameCStr:
            CString.with tensorName valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        CString.with "debug_urls" nameCStr:
            len = debugUrls.length
            cValues = ManagedPointer (Pointer CInt64) . mallocElems len
            indexed = 0.upto (len - 1) . zip debugUrls
            indexed.each (idx, elem):
                cValues.moveElems idx . write (CString.fromText elem)
            callHandlingError "add_attr_string_list" None [attrList.toCArg, nameCStr.toCArg, cValues.toCArg, CUInt32.fromInt len . toCArg]
            0.upto (len - 1) . each (idx: cValues.moveElems idx . read . free)
        CString.with "lower_bound" nameCStr:
            callHandlingError "add_attr_float" None [attrList.toCArg, nameCStr.toCArg, CFloat.fromReal lowerBound . toCArg]
        CString.with "upper_bound" nameCStr:
            callHandlingError "add_attr_float" None [attrList.toCArg, nameCStr.toCArg, CFloat.fromReal upperBound . toCArg]
        CString.with "mute_if_healthy" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if muteIfHealthy then 1 else 0) . toCArg]
        CString.with "gated_grpc" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if gatedGrpc then 1 else 0) . toCArg]
        wrappers = makeOutputWrappers "DebugNumericSummary" [input.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get DoubleType

    def fusedBatchNormV2 chosenName x scale offset mean variance t u epsilon dataFormat isTraining:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "U" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt u.num . toCArg]
        CString.with "epsilon" nameCStr:
            callHandlingError "add_attr_float" None [attrList.toCArg, nameCStr.toCArg, CFloat.fromReal epsilon . toCArg]
        CString.with "data_format" nameCStr:
            CString.with dataFormat valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        CString.with "is_training" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if isTraining then 1 else 0) . toCArg]
        wrappers = makeOutputWrappers "FusedBatchNormV2" [x.wrapper, scale.wrapper, offset.wrapper, mean.wrapper, variance.wrapper] 5 attrList chosenName
            (TFOutput (wrappers.getAt 0) x.typetag, TFOutput (wrappers.getAt 1) scale.typetag, TFOutput (wrappers.getAt 2) scale.typetag, TFOutput (wrappers.getAt 3) scale.typetag, TFOutput (wrappers.getAt 4) scale.typetag)

    def debugIdentity chosenName input t deviceName tensorName debugUrls gatedGrpc:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "device_name" nameCStr:
            CString.with deviceName valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        CString.with "tensor_name" nameCStr:
            CString.with tensorName valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        CString.with "debug_urls" nameCStr:
            len = debugUrls.length
            cValues = ManagedPointer (Pointer CInt64) . mallocElems len
            indexed = 0.upto (len - 1) . zip debugUrls
            indexed.each (idx, elem):
                cValues.moveElems idx . write (CString.fromText elem)
            callHandlingError "add_attr_string_list" None [attrList.toCArg, nameCStr.toCArg, cValues.toCArg, CUInt32.fromInt len . toCArg]
            0.upto (len - 1) . each (idx: cValues.moveElems idx . read . free)
        CString.with "gated_grpc" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if gatedGrpc then 1 else 0) . toCArg]
        wrappers = makeOutputWrappers "DebugIdentity" [input.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get input.typetag

    def accumulatorTakeGradient chosenName handle numRequired dtype:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "dtype" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt dtype.num . toCArg]
        wrappers = makeOutputWrappers "AccumulatorTakeGradient" [handle.wrapper, numRequired.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get dtype

    def tensorSummaryV2 chosenName tag tensor serializedSummaryMetadata t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "TensorSummaryV2" [tag.wrapper, tensor.wrapper, serializedSummaryMetadata.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get StringType

    def tensorArrayConcat chosenName handle flowIn dtype elementShapeExcept0:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "dtype" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt dtype.num . toCArg]
        CString.with "element_shape_except0" nameCStr:
            cdims = elementShapeExcept0.map CInt64.fromInt
            Array CInt64 . with cdims cdimsArray:
                callHandlingError "add_attr_shape" None [attrList.toCArg, nameCStr.toCArg, cdimsArray.toCArg, CUInt32.fromInt elementShapeExcept0.length . toCArg]
        wrappers = makeOutputWrappers "TensorArrayConcat" [handle.wrapper, flowIn.wrapper] 2 attrList chosenName
            (TFOutput (wrappers.getAt 0) dtype, TFOutput (wrappers.getAt 1) Int64Type)

    def reciprocal chosenName x t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "Reciprocal" [x.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get x.typetag

    def qr chosenName input fullMatrices t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "full_matrices" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if fullMatrices then 1 else 0) . toCArg]
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "Qr" [input.wrapper] 2 attrList chosenName
            (TFOutput (wrappers.getAt 0) input.typetag, TFOutput (wrappers.getAt 1) input.typetag)

    def audioSummary chosenName tag tensor sampleRate maxOutputs:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "sample_rate" nameCStr:
            callHandlingError "add_attr_float" None [attrList.toCArg, nameCStr.toCArg, CFloat.fromReal sampleRate . toCArg]
        CString.with "max_outputs" nameCStr:
                callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt maxOutputs . toCArg]
        wrappers = makeOutputWrappers "AudioSummary" [tag.wrapper, tensor.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get StringType

    def sparseReduceMaxSparse chosenName inputIndices inputValues inputShape reductionAxes keepDims t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "keep_dims" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if keepDims then 1 else 0) . toCArg]
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "SparseReduceMaxSparse" [inputIndices.wrapper, inputValues.wrapper, inputShape.wrapper, reductionAxes.wrapper] 3 attrList chosenName
            (TFOutput (wrappers.getAt 0) Int64Type, TFOutput (wrappers.getAt 1) inputValues.typetag, TFOutput (wrappers.getAt 2) Int64Type)

    def barrierIncompleteSize chosenName handle:
        wrappers = makeOutputWrappers "BarrierIncompleteSize" [handle.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get Int32Type

    def segmentSum chosenName data segmentIds t tindices:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "Tindices" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
        wrappers = makeOutputWrappers "SegmentSum" [data.wrapper, segmentIds.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get data.typetag

    def round chosenName x t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "Round" [x.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get x.typetag

    def matrixSetDiag chosenName input diagonal t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "MatrixSetDiag" [input.wrapper, diagonal.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get input.typetag

    def sparseSparseMaximum chosenName aIndices aValues aShape bIndices bValues bShape t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "SparseSparseMaximum" [aIndices.wrapper, aValues.wrapper, aShape.wrapper, bIndices.wrapper, bValues.wrapper, bShape.wrapper] 2 attrList chosenName
            (TFOutput (wrappers.getAt 0) Int64Type, TFOutput (wrappers.getAt 1) aValues.typetag)

    def matrixExponential chosenName input t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "MatrixExponential" [input.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get input.typetag

    def biasAddGrad chosenName outBackprop t dataFormat:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "data_format" nameCStr:
            CString.with dataFormat valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        wrappers = makeOutputWrappers "BiasAddGrad" [outBackprop.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get outBackprop.typetag

    def queueSize chosenName handle:
        wrappers = makeOutputWrappers "QueueSize" [handle.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get Int32Type

    def sparseDenseCwiseAdd chosenName spIndices spValues spShape dense t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "SparseDenseCwiseAdd" [spIndices.wrapper, spValues.wrapper, spShape.wrapper, dense.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get spValues.typetag

    def lookupTableFind chosenName tableHandle keys defaultValue tin tout:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "Tin" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tin.num . toCArg]
        CString.with "Tout" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tout.num . toCArg]
        wrappers = makeOutputWrappers "LookupTableFind" [tableHandle.wrapper, keys.wrapper, defaultValue.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get defaultValue.typetag

    def ensureShape chosenName input shape t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "shape" nameCStr:
            cdims = shape.map CInt64.fromInt
            Array CInt64 . with cdims cdimsArray:
                callHandlingError "add_attr_shape" None [attrList.toCArg, nameCStr.toCArg, cdimsArray.toCArg, CUInt32.fromInt shape.length . toCArg]
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "EnsureShape" [input.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get input.typetag

    def stackClose chosenName handle:
        wrappers = makeOutputWrappers "StackClose" [handle.wrapper] 0 attrList chosenName
        None

    def readerSerializeState chosenName readerHandle:
        wrappers = makeOutputWrappers "ReaderSerializeState" [readerHandle.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get StringType

    def tan chosenName x t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "Tan" [x.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get x.typetag

    def decodeBmp chosenName contents channels:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "channels" nameCStr:
                callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt channels . toCArg]
        wrappers = makeOutputWrappers "DecodeBmp" [contents.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get UInt8Type

    def rsqrt chosenName x t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "Rsqrt" [x.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get x.typetag

    def cTCLoss chosenName inputs labelsIndices labelsValues sequenceLength preprocessCollapseRepeated ctcMergeRepeated ignoreLongerOutputsThanInputs:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "preprocess_collapse_repeated" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if preprocessCollapseRepeated then 1 else 0) . toCArg]
        CString.with "ctc_merge_repeated" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if ctcMergeRepeated then 1 else 0) . toCArg]
        CString.with "ignore_longer_outputs_than_inputs" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if ignoreLongerOutputsThanInputs then 1 else 0) . toCArg]
        wrappers = makeOutputWrappers "CTCLoss" [inputs.wrapper, labelsIndices.wrapper, labelsValues.wrapper, sequenceLength.wrapper] 2 attrList chosenName
            (TFOutput (wrappers.getAt 0) FloatType, TFOutput (wrappers.getAt 1) FloatType)

    def quantizedResizeBilinear chosenName images size min max t alignCorners:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "align_corners" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if alignCorners then 1 else 0) . toCArg]
        wrappers = makeOutputWrappers "QuantizedResizeBilinear" [images.wrapper, size.wrapper, min.wrapper, max.wrapper] 3 attrList chosenName
            (TFOutput (wrappers.getAt 0) images.typetag, TFOutput (wrappers.getAt 1) FloatType, TFOutput (wrappers.getAt 2) FloatType)

    def stackPop chosenName handle elemType:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "elem_type" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt elemType.num . toCArg]
        wrappers = makeOutputWrappers "StackPop" [handle.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get elemType

    def svd chosenName input computeUv fullMatrices t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "compute_uv" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if computeUv then 1 else 0) . toCArg]
        CString.with "full_matrices" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if fullMatrices then 1 else 0) . toCArg]
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "Svd" [input.wrapper] 3 attrList chosenName
            (TFOutput (wrappers.getAt 0) input.typetag, TFOutput (wrappers.getAt 1) input.typetag, TFOutput (wrappers.getAt 2) input.typetag)

    def batchSelfAdjointEigV2 chosenName input computeV t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "compute_v" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if computeV then 1 else 0) . toCArg]
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "BatchSelfAdjointEigV2" [input.wrapper] 2 attrList chosenName
            (TFOutput (wrappers.getAt 0) input.typetag, TFOutput (wrappers.getAt 1) input.typetag)

    def inv chosenName x t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "Inv" [x.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get x.typetag

    def populationCount chosenName x t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "PopulationCount" [x.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get UInt8Type

    def decodeAndCropJpeg chosenName contents cropWindow channels ratio fancyUpscaling tryRecoverTruncated acceptableFraction dctMethod:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "channels" nameCStr:
                callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt channels . toCArg]
        CString.with "ratio" nameCStr:
                callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt ratio . toCArg]
        CString.with "fancy_upscaling" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if fancyUpscaling then 1 else 0) . toCArg]
        CString.with "try_recover_truncated" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if tryRecoverTruncated then 1 else 0) . toCArg]
        CString.with "acceptable_fraction" nameCStr:
            callHandlingError "add_attr_float" None [attrList.toCArg, nameCStr.toCArg, CFloat.fromReal acceptableFraction . toCArg]
        CString.with "dct_method" nameCStr:
            CString.with dctMethod valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        wrappers = makeOutputWrappers "DecodeAndCropJpeg" [contents.wrapper, cropWindow.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get UInt8Type

    def relu chosenName features t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "Relu" [features.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get features.typetag

    def loopCond chosenName input:
        wrappers = makeOutputWrappers "LoopCond" [input.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get BoolType

    def squaredDifference chosenName x y t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "SquaredDifference" [x.wrapper, y.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get x.typetag

    def exit chosenName data t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "Exit" [data.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get data.typetag

    def cropAndResize chosenName image boxes boxInd cropSize t method extrapolationValue:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "method" nameCStr:
            CString.with method valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        CString.with "extrapolation_value" nameCStr:
            callHandlingError "add_attr_float" None [attrList.toCArg, nameCStr.toCArg, CFloat.fromReal extrapolationValue . toCArg]
        wrappers = makeOutputWrappers "CropAndResize" [image.wrapper, boxes.wrapper, boxInd.wrapper, cropSize.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get FloatType

    def refEnter chosenName data t frameName isConstant parallelIterations:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "frame_name" nameCStr:
            CString.with frameName valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        CString.with "is_constant" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if isConstant then 1 else 0) . toCArg]
        CString.with "parallel_iterations" nameCStr:
                callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt parallelIterations . toCArg]
        wrappers = makeOutputWrappers "RefEnter" [data.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get data.typetag

    def shardedFilespec chosenName basename numShards:
        wrappers = makeOutputWrappers "ShardedFilespec" [basename.wrapper, numShards.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get StringType

    def extractJpegShape chosenName contents outputType:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "output_type" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt outputType.num . toCArg]
        wrappers = makeOutputWrappers "ExtractJpegShape" [contents.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get outputType

    def batchMatrixInverse chosenName input adjoint t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "adjoint" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if adjoint then 1 else 0) . toCArg]
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "BatchMatrixInverse" [input.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get input.typetag

    def tensorArraySplit chosenName handle value lengths flowIn t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "TensorArraySplit" [handle.wrapper, value.wrapper, lengths.wrapper, flowIn.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get FloatType

    def switch chosenName data pred t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "Switch" [data.wrapper, pred.wrapper] 2 attrList chosenName
            (TFOutput (wrappers.getAt 0) data.typetag, TFOutput (wrappers.getAt 1) data.typetag)

    def shardedFilename chosenName basename shard numShards:
        wrappers = makeOutputWrappers "ShardedFilename" [basename.wrapper, shard.wrapper, numShards.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get StringType

    def denseToDenseSetOperation chosenName set1 set2 setOperation validateIndices t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "set_operation" nameCStr:
            CString.with setOperation valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        CString.with "validate_indices" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if validateIndices then 1 else 0) . toCArg]
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "DenseToDenseSetOperation" [set1.wrapper, set2.wrapper] 3 attrList chosenName
            (TFOutput (wrappers.getAt 0) Int64Type, TFOutput (wrappers.getAt 1) set1.typetag, TFOutput (wrappers.getAt 2) Int64Type)

    def fusedPadConv2D chosenName input paddings filter t mode strides padding:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "mode" nameCStr:
            CString.with mode valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        CString.with "strides" nameCStr:
            cvalues = strides.map CInt64.fromInt
            Array CInt64 . with cvalues cvaluesArray:
                callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
        CString.with "padding" nameCStr:
            CString.with padding valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        wrappers = makeOutputWrappers "FusedPadConv2D" [input.wrapper, paddings.wrapper, filter.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get input.typetag

    def conv2DBackpropInput chosenName inputSizes filter outBackprop t strides useCudnnOnGpu padding dataFormat dilations:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "strides" nameCStr:
            cvalues = strides.map CInt64.fromInt
            Array CInt64 . with cvalues cvaluesArray:
                callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
        CString.with "use_cudnn_on_gpu" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useCudnnOnGpu then 1 else 0) . toCArg]
        CString.with "padding" nameCStr:
            CString.with padding valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        CString.with "data_format" nameCStr:
            CString.with dataFormat valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        CString.with "dilations" nameCStr:
            cvalues = dilations.map CInt64.fromInt
            Array CInt64 . with cvalues cvaluesArray:
                callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt dilations.length . toCArg]
        wrappers = makeOutputWrappers "Conv2DBackpropInput" [inputSizes.wrapper, filter.wrapper, outBackprop.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get filter.typetag

    def equal chosenName x y t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "Equal" [x.wrapper, y.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get BoolType

    def tensorArrayGatherV2 chosenName handle indices flowIn dtype elementShape:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "dtype" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt dtype.num . toCArg]
        CString.with "element_shape" nameCStr:
            cdims = elementShape.map CInt64.fromInt
            Array CInt64 . with cdims cdimsArray:
                callHandlingError "add_attr_shape" None [attrList.toCArg, nameCStr.toCArg, cdimsArray.toCArg, CUInt32.fromInt elementShape.length . toCArg]
        wrappers = makeOutputWrappers "TensorArrayGatherV2" [handle.wrapper, indices.wrapper, flowIn.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get dtype

    def histogramSummary chosenName tag values t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "HistogramSummary" [tag.wrapper, values.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get StringType

    def tPUEmbeddingActivations chosenName embeddingVariable slicedActivations tableId lookupId:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "table_id" nameCStr:
                callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt tableId . toCArg]
        CString.with "lookup_id" nameCStr:
                callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt lookupId . toCArg]
        wrappers = makeOutputWrappers "TPUEmbeddingActivations" [embeddingVariable.wrapper, slicedActivations.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get FloatType

    def refSwitch chosenName data pred t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "RefSwitch" [data.wrapper, pred.wrapper] 2 attrList chosenName
            (TFOutput (wrappers.getAt 0) data.typetag, TFOutput (wrappers.getAt 1) data.typetag)

    def sparseTensorDenseMatMul chosenName aIndices aValues aShape b t tindices adjointA adjointB:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "Tindices" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
        CString.with "adjoint_a" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if adjointA then 1 else 0) . toCArg]
        CString.with "adjoint_b" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if adjointB then 1 else 0) . toCArg]
        wrappers = makeOutputWrappers "SparseTensorDenseMatMul" [aIndices.wrapper, aValues.wrapper, aShape.wrapper, b.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get aValues.typetag

    def segmentProd chosenName data segmentIds t tindices:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "Tindices" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
        wrappers = makeOutputWrappers "SegmentProd" [data.wrapper, segmentIds.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get data.typetag

    def tensorArrayGather chosenName handle indices flowIn dtype elementShape:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "dtype" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt dtype.num . toCArg]
        CString.with "element_shape" nameCStr:
            cdims = elementShape.map CInt64.fromInt
            Array CInt64 . with cdims cdimsArray:
                callHandlingError "add_attr_shape" None [attrList.toCArg, nameCStr.toCArg, cdimsArray.toCArg, CUInt32.fromInt elementShape.length . toCArg]
        wrappers = makeOutputWrappers "TensorArrayGather" [handle.wrapper, indices.wrapper, flowIn.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get dtype

    def batchCholeskyGrad chosenName l grad t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "BatchCholeskyGrad" [l.wrapper, grad.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get l.typetag

    def generateBigQueryReaderPartitions chosenName projectId datasetId tableId columns timestampMillis numPartitions testEndPoint:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "project_id" nameCStr:
            CString.with projectId valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        CString.with "dataset_id" nameCStr:
            CString.with datasetId valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        CString.with "table_id" nameCStr:
            CString.with tableId valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        CString.with "columns" nameCStr:
            len = columns.length
            cValues = ManagedPointer (Pointer CInt64) . mallocElems len
            indexed = 0.upto (len - 1) . zip columns
            indexed.each (idx, elem):
                cValues.moveElems idx . write (CString.fromText elem)
            callHandlingError "add_attr_string_list" None [attrList.toCArg, nameCStr.toCArg, cValues.toCArg, CUInt32.fromInt len . toCArg]
            0.upto (len - 1) . each (idx: cValues.moveElems idx . read . free)
        CString.with "timestamp_millis" nameCStr:
                callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt timestampMillis . toCArg]
        CString.with "num_partitions" nameCStr:
                callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt numPartitions . toCArg]
        CString.with "test_end_point" nameCStr:
            CString.with testEndPoint valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        wrappers = makeOutputWrappers "GenerateBigQueryReaderPartitions" [] 1 attrList chosenName
        TFOutput wrappers.head.get StringType

    def scatterNdAdd chosenName ref indices updates t tindices useLocking:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "Tindices" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
        CString.with "use_locking" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useLocking then 1 else 0) . toCArg]
        wrappers = makeOutputWrappers "ScatterNdAdd" [ref.wrapper, indices.wrapper, updates.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get ref.typetag

    def assign chosenName ref value t validateShape useLocking:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "validate_shape" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if validateShape then 1 else 0) . toCArg]
        CString.with "use_locking" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useLocking then 1 else 0) . toCArg]
        wrappers = makeOutputWrappers "Assign" [ref.wrapper, value.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get ref.typetag

    def argMax chosenName input dimension t tidx outputType:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "Tidx" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tidx.num . toCArg]
        CString.with "output_type" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt outputType.num . toCArg]
        wrappers = makeOutputWrappers "ArgMax" [input.wrapper, dimension.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get outputType

    def readerReset chosenName readerHandle:
        wrappers = makeOutputWrappers "ReaderReset" [readerHandle.wrapper] 0 attrList chosenName
        None

    def digamma chosenName x t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "Digamma" [x.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get x.typetag

    def lookupTableExport chosenName tableHandle tkeys tvalues:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "Tkeys" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tkeys.num . toCArg]
        CString.with "Tvalues" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tvalues.num . toCArg]
        wrappers = makeOutputWrappers "LookupTableExport" [tableHandle.wrapper] 2 attrList chosenName
            (TFOutput (wrappers.getAt 0) tkeys, TFOutput (wrappers.getAt 1) tvalues)

    def debugGradientRefIdentity chosenName input t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "DebugGradientRefIdentity" [input.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get input.typetag

    def erf chosenName x t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "Erf" [x.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get x.typetag

    def floor chosenName x t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "Floor" [x.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get x.typetag

    def resizeBilinear chosenName images size t alignCorners:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "align_corners" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if alignCorners then 1 else 0) . toCArg]
        wrappers = makeOutputWrappers "ResizeBilinear" [images.wrapper, size.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get FloatType

    def copyHost chosenName input t tensorName debugOpsSpec:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "tensor_name" nameCStr:
            CString.with tensorName valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        CString.with "debug_ops_spec" nameCStr:
            len = debugOpsSpec.length
            cValues = ManagedPointer (Pointer CInt64) . mallocElems len
            indexed = 0.upto (len - 1) . zip debugOpsSpec
            indexed.each (idx, elem):
                cValues.moveElems idx . write (CString.fromText elem)
            callHandlingError "add_attr_string_list" None [attrList.toCArg, nameCStr.toCArg, cValues.toCArg, CUInt32.fromInt len . toCArg]
            0.upto (len - 1) . each (idx: cValues.moveElems idx . read . free)
        wrappers = makeOutputWrappers "CopyHost" [input.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get input.typetag

    def gcsConfigureBlockCache chosenName maxCacheSize blockSize maxStaleness:
        wrappers = makeOutputWrappers "GcsConfigureBlockCache" [maxCacheSize.wrapper, blockSize.wrapper, maxStaleness.wrapper] 0 attrList chosenName
        None

    def serializeManySparse chosenName sparseIndices sparseValues sparseShape t outType:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "out_type" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt outType.num . toCArg]
        wrappers = makeOutputWrappers "SerializeManySparse" [sparseIndices.wrapper, sparseValues.wrapper, sparseShape.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get outType

    def acosh chosenName x t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "Acosh" [x.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get x.typetag

    def isFinite chosenName x t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "IsFinite" [x.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get BoolType

    def batchMatrixSolveLs chosenName matrix rhs l2Regularizer t fast:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "fast" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if fast then 1 else 0) . toCArg]
        wrappers = makeOutputWrappers "BatchMatrixSolveLs" [matrix.wrapper, rhs.wrapper, l2Regularizer.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get matrix.typetag

    def debugGradientIdentity chosenName input t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "DebugGradientIdentity" [input.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get input.typetag

    def isNan chosenName x t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "IsNan" [x.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get BoolType

    def realDiv chosenName x y t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "RealDiv" [x.wrapper, y.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get x.typetag

    def lgamma chosenName x t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "Lgamma" [x.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get x.typetag

    def scatterNd chosenName indices updates shape t tindices:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "Tindices" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
        wrappers = makeOutputWrappers "ScatterNd" [indices.wrapper, updates.wrapper, shape.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get updates.typetag

    def all chosenName input reductionIndices keepDims tidx:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "keep_dims" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if keepDims then 1 else 0) . toCArg]
        CString.with "Tidx" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tidx.num . toCArg]
        wrappers = makeOutputWrappers "All" [input.wrapper, reductionIndices.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get BoolType

    def selfAdjointEig chosenName input t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "SelfAdjointEig" [input.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get input.typetag

    def conv3DBackpropInput chosenName input filter outBackprop t strides padding dilations:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "strides" nameCStr:
            cvalues = strides.map CInt64.fromInt
            Array CInt64 . with cvalues cvaluesArray:
                callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
        CString.with "padding" nameCStr:
            CString.with padding valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        CString.with "dilations" nameCStr:
            cvalues = dilations.map CInt64.fromInt
            Array CInt64 . with cvalues cvaluesArray:
                callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt dilations.length . toCArg]
        wrappers = makeOutputWrappers "Conv3DBackpropInput" [input.wrapper, filter.wrapper, outBackprop.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get input.typetag

    def stackPush chosenName handle elem t swapMemory:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "swap_memory" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if swapMemory then 1 else 0) . toCArg]
        wrappers = makeOutputWrappers "StackPush" [handle.wrapper, elem.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get elem.typetag

    def maxPool3D chosenName input ksize strides padding dataFormat t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "ksize" nameCStr:
            cvalues = ksize.map CInt64.fromInt
            Array CInt64 . with cvalues cvaluesArray:
                callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt ksize.length . toCArg]
        CString.with "strides" nameCStr:
            cvalues = strides.map CInt64.fromInt
            Array CInt64 . with cvalues cvaluesArray:
                callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
        CString.with "padding" nameCStr:
            CString.with padding valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        CString.with "data_format" nameCStr:
            CString.with dataFormat valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "MaxPool3D" [input.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get input.typetag

    def applyGradientDescent chosenName var alpha delta t useLocking:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "use_locking" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useLocking then 1 else 0) . toCArg]
        wrappers = makeOutputWrappers "ApplyGradientDescent" [var.wrapper, alpha.wrapper, delta.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get var.typetag

    def resizeArea chosenName images size t alignCorners:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "align_corners" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if alignCorners then 1 else 0) . toCArg]
        wrappers = makeOutputWrappers "ResizeArea" [images.wrapper, size.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get FloatType

    def stringToHashBucket chosenName stringTensor numBuckets:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "num_buckets" nameCStr:
                callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt numBuckets . toCArg]
        wrappers = makeOutputWrappers "StringToHashBucket" [stringTensor.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get Int64Type

    def applyAdagradDA chosenName var gradientAccumulator gradientSquaredAccumulator grad lr l1 l2 globalStep t useLocking:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "use_locking" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useLocking then 1 else 0) . toCArg]
        wrappers = makeOutputWrappers "ApplyAdagradDA" [var.wrapper, gradientAccumulator.wrapper, gradientSquaredAccumulator.wrapper, grad.wrapper, lr.wrapper, l1.wrapper, l2.wrapper, globalStep.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get var.typetag

    def igammaGradA chosenName a x t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "IgammaGradA" [a.wrapper, x.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get a.typetag

    def sparseSegmentMeanGrad chosenName grad indices segmentIds outputDim0 t tidx:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "Tidx" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tidx.num . toCArg]
        wrappers = makeOutputWrappers "SparseSegmentMeanGrad" [grad.wrapper, indices.wrapper, segmentIds.wrapper, outputDim0.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get grad.typetag

    def cudnnRNNParamsSize chosenName numLayers numUnits inputSize t s rnnMode inputMode direction dropout seed seed2:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "S" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt s.num . toCArg]
        CString.with "rnn_mode" nameCStr:
            CString.with rnnMode valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        CString.with "input_mode" nameCStr:
            CString.with inputMode valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        CString.with "direction" nameCStr:
            CString.with direction valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        CString.with "dropout" nameCStr:
            callHandlingError "add_attr_float" None [attrList.toCArg, nameCStr.toCArg, CFloat.fromReal dropout . toCArg]
        CString.with "seed" nameCStr:
                callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt seed . toCArg]
        CString.with "seed2" nameCStr:
                callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt seed2 . toCArg]
        wrappers = makeOutputWrappers "CudnnRNNParamsSize" [numLayers.wrapper, numUnits.wrapper, inputSize.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get s

    def queueIsClosed chosenName handle:
        wrappers = makeOutputWrappers "QueueIsClosed" [handle.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get BoolType

    def compareAndBitpack chosenName input threshold t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "CompareAndBitpack" [input.wrapper, threshold.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get UInt8Type

    def conv3DBackpropInputV2 chosenName inputSizes filter outBackprop t strides padding dataFormat dilations tshape:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "strides" nameCStr:
            cvalues = strides.map CInt64.fromInt
            Array CInt64 . with cvalues cvaluesArray:
                callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
        CString.with "padding" nameCStr:
            CString.with padding valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        CString.with "data_format" nameCStr:
            CString.with dataFormat valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        CString.with "dilations" nameCStr:
            cvalues = dilations.map CInt64.fromInt
            Array CInt64 . with cvalues cvaluesArray:
                callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt dilations.length . toCArg]
        CString.with "Tshape" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tshape.num . toCArg]
        wrappers = makeOutputWrappers "Conv3DBackpropInputV2" [inputSizes.wrapper, filter.wrapper, outBackprop.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get filter.typetag

    def depthToSpace chosenName input t blockSize dataFormat:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "block_size" nameCStr:
                callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt blockSize . toCArg]
        CString.with "data_format" nameCStr:
            CString.with dataFormat valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        wrappers = makeOutputWrappers "DepthToSpace" [input.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get input.typetag

    def adjustHue chosenName images delta:
        wrappers = makeOutputWrappers "AdjustHue" [images.wrapper, delta.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get FloatType

    def tensorArrayWrite chosenName handle index value flowIn t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "TensorArrayWrite" [handle.wrapper, index.wrapper, value.wrapper, flowIn.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get FloatType

    def tensorArrayWriteV2 chosenName handle index value flowIn t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "TensorArrayWriteV2" [handle.wrapper, index.wrapper, value.wrapper, flowIn.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get FloatType

    def matrixTriangularSolve chosenName matrix rhs lower adjoint t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "lower" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if lower then 1 else 0) . toCArg]
        CString.with "adjoint" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if adjoint then 1 else 0) . toCArg]
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "MatrixTriangularSolve" [matrix.wrapper, rhs.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get matrix.typetag

    def barrierClose chosenName handle cancelPendingEnqueues:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "cancel_pending_enqueues" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if cancelPendingEnqueues then 1 else 0) . toCArg]
        wrappers = makeOutputWrappers "BarrierClose" [handle.wrapper] 0 attrList chosenName
        None

    def truncateDiv chosenName x y t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "TruncateDiv" [x.wrapper, y.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get x.typetag

    def scatterUpdate chosenName ref indices updates t tindices useLocking:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "Tindices" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
        CString.with "use_locking" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useLocking then 1 else 0) . toCArg]
        wrappers = makeOutputWrappers "ScatterUpdate" [ref.wrapper, indices.wrapper, updates.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get ref.typetag

    def cTCGreedyDecoder chosenName inputs sequenceLength mergeRepeated:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "merge_repeated" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if mergeRepeated then 1 else 0) . toCArg]
        wrappers = makeOutputWrappers "CTCGreedyDecoder" [inputs.wrapper, sequenceLength.wrapper] 4 attrList chosenName
            (TFOutput (wrappers.getAt 0) Int64Type, TFOutput (wrappers.getAt 1) Int64Type, TFOutput (wrappers.getAt 2) Int64Type, TFOutput (wrappers.getAt 3) FloatType)

    def padV2 chosenName input paddings constantValues t tpaddings:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "Tpaddings" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tpaddings.num . toCArg]
        wrappers = makeOutputWrappers "PadV2" [input.wrapper, paddings.wrapper, constantValues.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get input.typetag

    def mfcc chosenName spectrogram sampleRate upperFrequencyLimit lowerFrequencyLimit filterbankChannelCount dctCoefficientCount:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "upper_frequency_limit" nameCStr:
            callHandlingError "add_attr_float" None [attrList.toCArg, nameCStr.toCArg, CFloat.fromReal upperFrequencyLimit . toCArg]
        CString.with "lower_frequency_limit" nameCStr:
            callHandlingError "add_attr_float" None [attrList.toCArg, nameCStr.toCArg, CFloat.fromReal lowerFrequencyLimit . toCArg]
        CString.with "filterbank_channel_count" nameCStr:
                callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt filterbankChannelCount . toCArg]
        CString.with "dct_coefficient_count" nameCStr:
                callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt dctCoefficientCount . toCArg]
        wrappers = makeOutputWrappers "Mfcc" [spectrogram.wrapper, sampleRate.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get FloatType

    def decodeWav chosenName contents desiredChannels desiredSamples:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "desired_channels" nameCStr:
                callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt desiredChannels . toCArg]
        CString.with "desired_samples" nameCStr:
                callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt desiredSamples . toCArg]
        wrappers = makeOutputWrappers "DecodeWav" [contents.wrapper] 2 attrList chosenName
            (TFOutput (wrappers.getAt 0) FloatType, TFOutput (wrappers.getAt 1) Int32Type)

    def unique chosenName x t outIdx:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "out_idx" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt outIdx.num . toCArg]
        wrappers = makeOutputWrappers "Unique" [x.wrapper] 2 attrList chosenName
            (TFOutput (wrappers.getAt 0) x.typetag, TFOutput (wrappers.getAt 1) outIdx)

    def spaceToBatch chosenName input paddings t tpaddings blockSize:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "Tpaddings" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tpaddings.num . toCArg]
        CString.with "block_size" nameCStr:
                callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt blockSize . toCArg]
        wrappers = makeOutputWrappers "SpaceToBatch" [input.wrapper, paddings.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get input.typetag

    def unbatch chosenName batchedTensor batchIndex id timeoutMicros container sharedName t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "timeout_micros" nameCStr:
                callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt timeoutMicros . toCArg]
        CString.with "container" nameCStr:
            CString.with container valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        CString.with "shared_name" nameCStr:
            CString.with sharedName valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "Unbatch" [batchedTensor.wrapper, batchIndex.wrapper, id.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get batchedTensor.typetag

    def countUpTo chosenName ref limit t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "limit" nameCStr:
                callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt limit . toCArg]
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "CountUpTo" [ref.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get ref.typetag

    def roll chosenName input shift axis t tshift taxis:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "Tshift" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tshift.num . toCArg]
        CString.with "Taxis" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt taxis.num . toCArg]
        wrappers = makeOutputWrappers "Roll" [input.wrapper, shift.wrapper, axis.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get input.typetag

    def adjustContrast chosenName images contrastFactor minValue maxValue t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "AdjustContrast" [images.wrapper, contrastFactor.wrapper, minValue.wrapper, maxValue.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get FloatType

    def audioSpectrogram chosenName input windowSize stride magnitudeSquared:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "window_size" nameCStr:
                callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt windowSize . toCArg]
        CString.with "stride" nameCStr:
                callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt stride . toCArg]
        CString.with "magnitude_squared" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if magnitudeSquared then 1 else 0) . toCArg]
        wrappers = makeOutputWrappers "AudioSpectrogram" [input.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get FloatType

    def invGrad chosenName y dy t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "InvGrad" [y.wrapper, dy.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get y.typetag

    def stridedSlice chosenName input begin end strides t index beginMask endMask ellipsisMask newAxisMask shrinkAxisMask:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "Index" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt index.num . toCArg]
        CString.with "begin_mask" nameCStr:
                callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt beginMask . toCArg]
        CString.with "end_mask" nameCStr:
                callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt endMask . toCArg]
        CString.with "ellipsis_mask" nameCStr:
                callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt ellipsisMask . toCArg]
        CString.with "new_axis_mask" nameCStr:
                callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt newAxisMask . toCArg]
        CString.with "shrink_axis_mask" nameCStr:
                callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt shrinkAxisMask . toCArg]
        wrappers = makeOutputWrappers "StridedSlice" [input.wrapper, begin.wrapper, end.wrapper, strides.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get input.typetag

    def logicalNot chosenName x:
        wrappers = makeOutputWrappers "LogicalNot" [x.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get BoolType

    def readerRead chosenName readerHandle queueHandle:
        wrappers = makeOutputWrappers "ReaderRead" [readerHandle.wrapper, queueHandle.wrapper] 2 attrList chosenName
            (TFOutput (wrappers.getAt 0) StringType, TFOutput (wrappers.getAt 1) StringType)

    def readerRestoreState chosenName readerHandle state:
        wrappers = makeOutputWrappers "ReaderRestoreState" [readerHandle.wrapper, state.wrapper] 0 attrList chosenName
        None

    def reduceJoin chosenName inputs reductionIndices keepDims separator:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "keep_dims" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if keepDims then 1 else 0) . toCArg]
        CString.with "separator" nameCStr:
            CString.with separator valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        wrappers = makeOutputWrappers "ReduceJoin" [inputs.wrapper, reductionIndices.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get StringType

    def sparseAddGrad chosenName backpropValGrad aIndices bIndices sumIndices t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "SparseAddGrad" [backpropValGrad.wrapper, aIndices.wrapper, bIndices.wrapper, sumIndices.wrapper] 2 attrList chosenName
            (TFOutput (wrappers.getAt 0) backpropValGrad.typetag, TFOutput (wrappers.getAt 1) backpropValGrad.typetag)

    def maxPoolGradGrad chosenName origInput origOutput grad ksize strides padding dataFormat t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "ksize" nameCStr:
            cvalues = ksize.map CInt64.fromInt
            Array CInt64 . with cvalues cvaluesArray:
                callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt ksize.length . toCArg]
        CString.with "strides" nameCStr:
            cvalues = strides.map CInt64.fromInt
            Array CInt64 . with cvalues cvaluesArray:
                callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
        CString.with "padding" nameCStr:
            CString.with padding valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        CString.with "data_format" nameCStr:
            CString.with dataFormat valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "MaxPoolGradGrad" [origInput.wrapper, origOutput.wrapper, grad.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get origInput.typetag

    def tensorArrayRead chosenName handle index flowIn dtype:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "dtype" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt dtype.num . toCArg]
        wrappers = makeOutputWrappers "TensorArrayRead" [handle.wrapper, index.wrapper, flowIn.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get dtype

    def shape chosenName input t outType:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "out_type" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt outType.num . toCArg]
        wrappers = makeOutputWrappers "Shape" [input.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get outType

    def pow chosenName x y t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "Pow" [x.wrapper, y.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get x.typetag

    def sdcaFprint chosenName input:
        wrappers = makeOutputWrappers "SdcaFprint" [input.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get Int64Type

    def readerReadUpTo chosenName readerHandle queueHandle numRecords:
        wrappers = makeOutputWrappers "ReaderReadUpTo" [readerHandle.wrapper, queueHandle.wrapper, numRecords.wrapper] 2 attrList chosenName
            (TFOutput (wrappers.getAt 0) StringType, TFOutput (wrappers.getAt 1) StringType)

    def batchMatrixSolve chosenName matrix rhs adjoint t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "adjoint" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if adjoint then 1 else 0) . toCArg]
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "BatchMatrixSolve" [matrix.wrapper, rhs.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get matrix.typetag

    def serializeSparse chosenName sparseIndices sparseValues sparseShape t outType:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "out_type" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt outType.num . toCArg]
        wrappers = makeOutputWrappers "SerializeSparse" [sparseIndices.wrapper, sparseValues.wrapper, sparseShape.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get outType

    def drawBoundingBoxes chosenName images boxes t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "DrawBoundingBoxes" [images.wrapper, boxes.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get images.typetag

    def spaceToDepth chosenName input t blockSize dataFormat:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "block_size" nameCStr:
                callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt blockSize . toCArg]
        CString.with "data_format" nameCStr:
            CString.with dataFormat valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        wrappers = makeOutputWrappers "SpaceToDepth" [input.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get input.typetag

    def generateVocabRemapping chosenName newVocabFile oldVocabFile newVocabOffset numNewVocab oldVocabSize:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "new_vocab_offset" nameCStr:
                callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt newVocabOffset . toCArg]
        CString.with "num_new_vocab" nameCStr:
                callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt numNewVocab . toCArg]
        CString.with "old_vocab_size" nameCStr:
                callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt oldVocabSize . toCArg]
        wrappers = makeOutputWrappers "GenerateVocabRemapping" [newVocabFile.wrapper, oldVocabFile.wrapper] 2 attrList chosenName
            (TFOutput (wrappers.getAt 0) Int64Type, TFOutput (wrappers.getAt 1) Int32Type)

    def abort chosenName errorMsg exitWithoutError:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "error_msg" nameCStr:
            CString.with errorMsg valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        CString.with "exit_without_error" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if exitWithoutError then 1 else 0) . toCArg]
        wrappers = makeOutputWrappers "Abort" [] 0 attrList chosenName
        None

    def mod chosenName x y t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "Mod" [x.wrapper, y.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get x.typetag

    def assignAdd chosenName ref value t useLocking:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "use_locking" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useLocking then 1 else 0) . toCArg]
        wrappers = makeOutputWrappers "AssignAdd" [ref.wrapper, value.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get ref.typetag

    def avgPool3DGrad chosenName origInputShape grad ksize strides padding dataFormat t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "ksize" nameCStr:
            cvalues = ksize.map CInt64.fromInt
            Array CInt64 . with cvalues cvaluesArray:
                callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt ksize.length . toCArg]
        CString.with "strides" nameCStr:
            cvalues = strides.map CInt64.fromInt
            Array CInt64 . with cvalues cvaluesArray:
                callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
        CString.with "padding" nameCStr:
            CString.with padding valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        CString.with "data_format" nameCStr:
            CString.with dataFormat valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "AvgPool3DGrad" [origInputShape.wrapper, grad.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get grad.typetag

    def unbatchGrad chosenName originalInput batchIndex grad id container sharedName t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "container" nameCStr:
            CString.with container valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        CString.with "shared_name" nameCStr:
            CString.with sharedName valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "UnbatchGrad" [originalInput.wrapper, batchIndex.wrapper, grad.wrapper, id.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get originalInput.typetag

    def debugNanCount chosenName input t deviceName tensorName debugUrls gatedGrpc:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "device_name" nameCStr:
            CString.with deviceName valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        CString.with "tensor_name" nameCStr:
            CString.with tensorName valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        CString.with "debug_urls" nameCStr:
            len = debugUrls.length
            cValues = ManagedPointer (Pointer CInt64) . mallocElems len
            indexed = 0.upto (len - 1) . zip debugUrls
            indexed.each (idx, elem):
                cValues.moveElems idx . write (CString.fromText elem)
            callHandlingError "add_attr_string_list" None [attrList.toCArg, nameCStr.toCArg, cValues.toCArg, CUInt32.fromInt len . toCArg]
            0.upto (len - 1) . each (idx: cValues.moveElems idx . read . free)
        CString.with "gated_grpc" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if gatedGrpc then 1 else 0) . toCArg]
        wrappers = makeOutputWrappers "DebugNanCount" [input.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get Int64Type

    def applyRMSProp chosenName var ms mom lr rho momentum epsilon grad t useLocking:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "use_locking" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useLocking then 1 else 0) . toCArg]
        wrappers = makeOutputWrappers "ApplyRMSProp" [var.wrapper, ms.wrapper, mom.wrapper, lr.wrapper, rho.wrapper, momentum.wrapper, epsilon.wrapper, grad.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get var.typetag

    def fakeQuantWithMinMaxVars chosenName inputs min max numBits narrowRange:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "num_bits" nameCStr:
                callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt numBits . toCArg]
        CString.with "narrow_range" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if narrowRange then 1 else 0) . toCArg]
        wrappers = makeOutputWrappers "FakeQuantWithMinMaxVars" [inputs.wrapper, min.wrapper, max.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get FloatType

    def cropAndResizeGradImage chosenName grads boxes boxInd imageSize t method:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "method" nameCStr:
            CString.with method valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        wrappers = makeOutputWrappers "CropAndResizeGradImage" [grads.wrapper, boxes.wrapper, boxInd.wrapper, imageSize.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get t

    def queueClose chosenName handle cancelPendingEnqueues:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "cancel_pending_enqueues" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if cancelPendingEnqueues then 1 else 0) . toCArg]
        wrappers = makeOutputWrappers "QueueClose" [handle.wrapper] 0 attrList chosenName
        None

    def scatterMin chosenName ref indices updates t tindices useLocking:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "Tindices" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
        CString.with "use_locking" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useLocking then 1 else 0) . toCArg]
        wrappers = makeOutputWrappers "ScatterMin" [ref.wrapper, indices.wrapper, updates.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get ref.typetag

    def readFile chosenName filename:
        wrappers = makeOutputWrappers "ReadFile" [filename.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get StringType

    def stringToHashBucketFast chosenName input numBuckets:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "num_buckets" nameCStr:
                callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt numBuckets . toCArg]
        wrappers = makeOutputWrappers "StringToHashBucketFast" [input.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get Int64Type

    def accumulatorSetGlobalStep chosenName handle newGlobalStep:
        wrappers = makeOutputWrappers "AccumulatorSetGlobalStep" [handle.wrapper, newGlobalStep.wrapper] 0 attrList chosenName
        None

    def matrixDiagPart chosenName input t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "MatrixDiagPart" [input.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get input.typetag

    def placeholder chosenName dtype shape:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "dtype" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt dtype.num . toCArg]
        CString.with "shape" nameCStr:
            cdims = shape.map CInt64.fromInt
            Array CInt64 . with cdims cdimsArray:
                callHandlingError "add_attr_shape" None [attrList.toCArg, nameCStr.toCArg, cdimsArray.toCArg, CUInt32.fromInt shape.length . toCArg]
        wrappers = makeOutputWrappers "Placeholder" [] 1 attrList chosenName
        TFOutput wrappers.head.get dtype

    def abs chosenName x t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "Abs" [x.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get x.typetag

    def accumulatorApplyGradient chosenName handle localStep gradient dtype:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "dtype" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt dtype.num . toCArg]
        wrappers = makeOutputWrappers "AccumulatorApplyGradient" [handle.wrapper, localStep.wrapper, gradient.wrapper] 0 attrList chosenName
        None

    def sparseAccumulatorApplyGradient chosenName handle localStep gradientIndices gradientValues gradientShape dtype hasKnownShape:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "dtype" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt dtype.num . toCArg]
        CString.with "has_known_shape" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if hasKnownShape then 1 else 0) . toCArg]
        wrappers = makeOutputWrappers "SparseAccumulatorApplyGradient" [handle.wrapper, localStep.wrapper, gradientIndices.wrapper, gradientValues.wrapper, gradientShape.wrapper] 0 attrList chosenName
        None

    def atanh chosenName x t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "Atanh" [x.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get x.typetag

    def conv2D chosenName input filter t strides useCudnnOnGpu padding dataFormat dilations:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "strides" nameCStr:
            cvalues = strides.map CInt64.fromInt
            Array CInt64 . with cvalues cvaluesArray:
                callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
        CString.with "use_cudnn_on_gpu" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useCudnnOnGpu then 1 else 0) . toCArg]
        CString.with "padding" nameCStr:
            CString.with padding valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        CString.with "data_format" nameCStr:
            CString.with dataFormat valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        CString.with "dilations" nameCStr:
            cvalues = dilations.map CInt64.fromInt
            Array CInt64 . with cvalues cvaluesArray:
                callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt dilations.length . toCArg]
        wrappers = makeOutputWrappers "Conv2D" [input.wrapper, filter.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get input.typetag

    def tensorArrayClose chosenName handle:
        wrappers = makeOutputWrappers "TensorArrayClose" [handle.wrapper] 0 attrList chosenName
        None

    def scatterSub chosenName ref indices updates t tindices useLocking:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "Tindices" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
        CString.with "use_locking" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useLocking then 1 else 0) . toCArg]
        wrappers = makeOutputWrappers "ScatterSub" [ref.wrapper, indices.wrapper, updates.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get ref.typetag

    def applyFtrl chosenName var accum linear grad lr l1 l2 lrPower t useLocking:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "use_locking" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useLocking then 1 else 0) . toCArg]
        wrappers = makeOutputWrappers "ApplyFtrl" [var.wrapper, accum.wrapper, linear.wrapper, grad.wrapper, lr.wrapper, l1.wrapper, l2.wrapper, lrPower.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get var.typetag

    def serializeTensor chosenName tensor t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "SerializeTensor" [tensor.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get StringType

    def fusedBatchNormGradV2 chosenName yBackprop x scale reserveSpace1 reserveSpace2 t u epsilon dataFormat isTraining:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "U" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt u.num . toCArg]
        CString.with "epsilon" nameCStr:
            callHandlingError "add_attr_float" None [attrList.toCArg, nameCStr.toCArg, CFloat.fromReal epsilon . toCArg]
        CString.with "data_format" nameCStr:
            CString.with dataFormat valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        CString.with "is_training" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if isTraining then 1 else 0) . toCArg]
        wrappers = makeOutputWrappers "FusedBatchNormGradV2" [yBackprop.wrapper, x.wrapper, scale.wrapper, reserveSpace1.wrapper, reserveSpace2.wrapper] 5 attrList chosenName
            (TFOutput (wrappers.getAt 0) yBackprop.typetag, TFOutput (wrappers.getAt 1) reserveSpace1.typetag, TFOutput (wrappers.getAt 2) reserveSpace1.typetag, TFOutput (wrappers.getAt 3) reserveSpace1.typetag, TFOutput (wrappers.getAt 4) reserveSpace1.typetag)

    def batchNormWithGlobalNormalization chosenName t m v beta gamma t varianceEpsilon scaleAfterNormalization:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "variance_epsilon" nameCStr:
            callHandlingError "add_attr_float" None [attrList.toCArg, nameCStr.toCArg, CFloat.fromReal varianceEpsilon . toCArg]
        CString.with "scale_after_normalization" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if scaleAfterNormalization then 1 else 0) . toCArg]
        wrappers = makeOutputWrappers "BatchNormWithGlobalNormalization" [t.wrapper, m.wrapper, v.wrapper, beta.wrapper, gamma.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get t.typetag

    def controlTrigger chosenName:
        wrappers = makeOutputWrappers "ControlTrigger" [] 0 attrList chosenName
        None

    def tensorArrayReadV2 chosenName handle index flowIn dtype:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "dtype" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt dtype.num . toCArg]
        wrappers = makeOutputWrappers "TensorArrayReadV2" [handle.wrapper, index.wrapper, flowIn.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get dtype

    def placeholderWithDefault chosenName input dtype shape:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "dtype" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt dtype.num . toCArg]
        CString.with "shape" nameCStr:
            cdims = shape.map CInt64.fromInt
            Array CInt64 . with cdims cdimsArray:
                callHandlingError "add_attr_shape" None [attrList.toCArg, nameCStr.toCArg, cdimsArray.toCArg, CUInt32.fromInt shape.length . toCArg]
        wrappers = makeOutputWrappers "PlaceholderWithDefault" [input.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get input.typetag

    def decodeBase64 chosenName input:
        wrappers = makeOutputWrappers "DecodeBase64" [input.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get StringType

    def seluGrad chosenName gradients outputs t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "SeluGrad" [gradients.wrapper, outputs.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get gradients.typetag

    def sqrtGrad chosenName y dy t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "SqrtGrad" [y.wrapper, dy.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get y.typetag

    def refExit chosenName data t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "RefExit" [data.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get data.typetag

    def snapshot chosenName input t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "Snapshot" [input.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get input.typetag

    def sparseApplyAdagradDA chosenName var gradientAccumulator gradientSquaredAccumulator grad indices lr l1 l2 globalStep t tindices useLocking:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "Tindices" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
        CString.with "use_locking" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useLocking then 1 else 0) . toCArg]
        wrappers = makeOutputWrappers "SparseApplyAdagradDA" [var.wrapper, gradientAccumulator.wrapper, gradientSquaredAccumulator.wrapper, grad.wrapper, indices.wrapper, lr.wrapper, l1.wrapper, l2.wrapper, globalStep.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get var.typetag

    def divNoNan chosenName x y t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "DivNoNan" [x.wrapper, y.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get x.typetag

    def tensorArrayScatter chosenName handle indices value flowIn t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "TensorArrayScatter" [handle.wrapper, indices.wrapper, value.wrapper, flowIn.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get FloatType

    def sparseReduceMax chosenName inputIndices inputValues inputShape reductionAxes keepDims t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "keep_dims" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if keepDims then 1 else 0) . toCArg]
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "SparseReduceMax" [inputIndices.wrapper, inputValues.wrapper, inputShape.wrapper, reductionAxes.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get inputValues.typetag

    def fractionalMaxPool chosenName value poolingRatio pseudoRandom overlapping deterministic seed seed2 t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "pooling_ratio" nameCStr:
            cvalues = poolingRatio.map CFloat.fromReal
            Array CFloat . with cvalues cvaluesArray:
                callHandlingError "add_attr_float_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt poolingRatio.length . toCArg]
        CString.with "pseudo_random" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if pseudoRandom then 1 else 0) . toCArg]
        CString.with "overlapping" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if overlapping then 1 else 0) . toCArg]
        CString.with "deterministic" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if deterministic then 1 else 0) . toCArg]
        CString.with "seed" nameCStr:
                callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt seed . toCArg]
        CString.with "seed2" nameCStr:
                callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt seed2 . toCArg]
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "FractionalMaxPool" [value.wrapper] 3 attrList chosenName
            (TFOutput (wrappers.getAt 0) value.typetag, TFOutput (wrappers.getAt 1) Int64Type, TFOutput (wrappers.getAt 2) Int64Type)

    def scatterNdNonAliasingAdd chosenName input indices updates t tindices:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "Tindices" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
        wrappers = makeOutputWrappers "ScatterNdNonAliasingAdd" [input.wrapper, indices.wrapper, updates.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get input.typetag

    def tensorArraySize chosenName handle flowIn:
        wrappers = makeOutputWrappers "TensorArraySize" [handle.wrapper, flowIn.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get Int32Type

    def resizeNearestNeighborGrad chosenName grads size t alignCorners:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "align_corners" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if alignCorners then 1 else 0) . toCArg]
        wrappers = makeOutputWrappers "ResizeNearestNeighborGrad" [grads.wrapper, size.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get grads.typetag

    def tensorArraySizeV2 chosenName handle flowIn:
        wrappers = makeOutputWrappers "TensorArraySizeV2" [handle.wrapper, flowIn.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get Int32Type

    def barrierReadySize chosenName handle:
        wrappers = makeOutputWrappers "BarrierReadySize" [handle.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get Int32Type

    def fakeQuantWithMinMaxArgs chosenName inputs min max numBits narrowRange:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "min" nameCStr:
            callHandlingError "add_attr_float" None [attrList.toCArg, nameCStr.toCArg, CFloat.fromReal min . toCArg]
        CString.with "max" nameCStr:
            callHandlingError "add_attr_float" None [attrList.toCArg, nameCStr.toCArg, CFloat.fromReal max . toCArg]
        CString.with "num_bits" nameCStr:
                callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt numBits . toCArg]
        CString.with "narrow_range" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if narrowRange then 1 else 0) . toCArg]
        wrappers = makeOutputWrappers "FakeQuantWithMinMaxArgs" [inputs.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get FloatType

    def maxPoolV2 chosenName input ksize strides t padding dataFormat:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "padding" nameCStr:
            CString.with padding valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        CString.with "data_format" nameCStr:
            CString.with dataFormat valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        wrappers = makeOutputWrappers "MaxPoolV2" [input.wrapper, ksize.wrapper, strides.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get input.typetag

    def decodeJSONExample chosenName jsonExamples:
        wrappers = makeOutputWrappers "DecodeJSONExample" [jsonExamples.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get StringType

    def sparseAdd chosenName aIndices aValues aShape bIndices bValues bShape thresh t treal:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "Treal" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt treal.num . toCArg]
        wrappers = makeOutputWrappers "SparseAdd" [aIndices.wrapper, aValues.wrapper, aShape.wrapper, bIndices.wrapper, bValues.wrapper, bShape.wrapper, thresh.wrapper] 3 attrList chosenName
            (TFOutput (wrappers.getAt 0) Int64Type, TFOutput (wrappers.getAt 1) aValues.typetag, TFOutput (wrappers.getAt 2) Int64Type)

    def initializeTable chosenName tableHandle keys values tkey tval:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "Tkey" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tkey.num . toCArg]
        CString.with "Tval" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tval.num . toCArg]
        wrappers = makeOutputWrappers "InitializeTable" [tableHandle.wrapper, keys.wrapper, values.wrapper] 0 attrList chosenName
        None

    def tensorSummary chosenName tensor t description labels displayName:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "description" nameCStr:
            CString.with description valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        CString.with "labels" nameCStr:
            len = labels.length
            cValues = ManagedPointer (Pointer CInt64) . mallocElems len
            indexed = 0.upto (len - 1) . zip labels
            indexed.each (idx, elem):
                cValues.moveElems idx . write (CString.fromText elem)
            callHandlingError "add_attr_string_list" None [attrList.toCArg, nameCStr.toCArg, cValues.toCArg, CUInt32.fromInt len . toCArg]
            0.upto (len - 1) . each (idx: cValues.moveElems idx . read . free)
        CString.with "display_name" nameCStr:
            CString.with displayName valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        wrappers = makeOutputWrappers "TensorSummary" [tensor.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get StringType

    def imageSummary chosenName tag tensor maxImages t badColor:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "max_images" nameCStr:
                callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt maxImages . toCArg]
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "bad_color" nameCStr:
                callHandlingError "add_attr_tensor" None [attrList.toCArg, nameCStr.toCArg, badColor.ptr.toCArg]
        wrappers = makeOutputWrappers "ImageSummary" [tag.wrapper, tensor.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get StringType

    def avgPool chosenName value ksize strides padding dataFormat t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "ksize" nameCStr:
            cvalues = ksize.map CInt64.fromInt
            Array CInt64 . with cvalues cvaluesArray:
                callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt ksize.length . toCArg]
        CString.with "strides" nameCStr:
            cvalues = strides.map CInt64.fromInt
            Array CInt64 . with cvalues cvaluesArray:
                callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
        CString.with "padding" nameCStr:
            CString.with padding valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        CString.with "data_format" nameCStr:
            CString.with dataFormat valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "AvgPool" [value.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get value.typetag

    def fill chosenName dims value t indexType:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "index_type" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt indexType.num . toCArg]
        wrappers = makeOutputWrappers "Fill" [dims.wrapper, value.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get value.typetag

    def asinh chosenName x t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "Asinh" [x.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get x.typetag

    def tanhGrad chosenName y dy t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "TanhGrad" [y.wrapper, dy.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get y.typetag

    def scalarSummary chosenName tags values t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "ScalarSummary" [tags.wrapper, values.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get StringType

    def uniqueWithCounts chosenName x t outIdx:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "out_idx" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt outIdx.num . toCArg]
        wrappers = makeOutputWrappers "UniqueWithCounts" [x.wrapper] 3 attrList chosenName
            (TFOutput (wrappers.getAt 0) x.typetag, TFOutput (wrappers.getAt 1) outIdx, TFOutput (wrappers.getAt 2) outIdx)

    def decodeRaw chosenName bytes outType littleEndian:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "out_type" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt outType.num . toCArg]
        CString.with "little_endian" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if littleEndian then 1 else 0) . toCArg]
        wrappers = makeOutputWrappers "DecodeRaw" [bytes.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get outType

    def eluGrad chosenName gradients outputs t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "EluGrad" [gradients.wrapper, outputs.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get gradients.typetag

    def staticRegexReplace chosenName input pattern rewrite replaceGlobal:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "pattern" nameCStr:
            CString.with pattern valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        CString.with "rewrite" nameCStr:
            CString.with rewrite valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        CString.with "replace_global" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if replaceGlobal then 1 else 0) . toCArg]
        wrappers = makeOutputWrappers "StaticRegexReplace" [input.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get StringType

    def matrixBandPart chosenName input numLower numUpper t tindex:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "Tindex" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindex.num . toCArg]
        wrappers = makeOutputWrappers "MatrixBandPart" [input.wrapper, numLower.wrapper, numUpper.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get input.typetag

    def decodeCompressed chosenName bytes compressionType:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "compression_type" nameCStr:
            CString.with compressionType valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        wrappers = makeOutputWrappers "DecodeCompressed" [bytes.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get StringType

    def maxPoolWithArgmax chosenName input ksize strides targmax padding t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "ksize" nameCStr:
            cvalues = ksize.map CInt64.fromInt
            Array CInt64 . with cvalues cvaluesArray:
                callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt ksize.length . toCArg]
        CString.with "strides" nameCStr:
            cvalues = strides.map CInt64.fromInt
            Array CInt64 . with cvalues cvaluesArray:
                callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
        CString.with "Targmax" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt targmax.num . toCArg]
        CString.with "padding" nameCStr:
            CString.with padding valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "MaxPoolWithArgmax" [input.wrapper] 2 attrList chosenName
            (TFOutput (wrappers.getAt 0) input.typetag, TFOutput (wrappers.getAt 1) targmax)

    def parseTensor chosenName serialized outType:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "out_type" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt outType.num . toCArg]
        wrappers = makeOutputWrappers "ParseTensor" [serialized.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get outType

    def rank chosenName input t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "Rank" [input.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get Int32Type

    def barrierInsertMany chosenName handle keys values t componentIndex:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "component_index" nameCStr:
                callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt componentIndex . toCArg]
        wrappers = makeOutputWrappers "BarrierInsertMany" [handle.wrapper, keys.wrapper, values.wrapper] 0 attrList chosenName
        None

    def sparseApplyAdagrad chosenName var accum lr grad indices t tindices useLocking updateSlots:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "Tindices" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
        CString.with "use_locking" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useLocking then 1 else 0) . toCArg]
        CString.with "update_slots" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if updateSlots then 1 else 0) . toCArg]
        wrappers = makeOutputWrappers "SparseApplyAdagrad" [var.wrapper, accum.wrapper, lr.wrapper, grad.wrapper, indices.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get var.typetag

    def linSpace chosenName start stop num t tidx:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "Tidx" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tidx.num . toCArg]
        wrappers = makeOutputWrappers "LinSpace" [start.wrapper, stop.wrapper, num.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get start.typetag

    def applyAdam chosenName var m v beta1Power beta2Power lr beta1 beta2 epsilon grad t useLocking useNesterov:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "use_locking" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useLocking then 1 else 0) . toCArg]
        CString.with "use_nesterov" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useNesterov then 1 else 0) . toCArg]
        wrappers = makeOutputWrappers "ApplyAdam" [var.wrapper, m.wrapper, v.wrapper, beta1Power.wrapper, beta2Power.wrapper, lr.wrapper, beta1.wrapper, beta2.wrapper, epsilon.wrapper, grad.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get var.typetag

    def pad chosenName input paddings t tpaddings:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "Tpaddings" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tpaddings.num . toCArg]
        wrappers = makeOutputWrappers "Pad" [input.wrapper, paddings.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get input.typetag

    def writeFile chosenName filename contents:
        wrappers = makeOutputWrappers "WriteFile" [filename.wrapper, contents.wrapper] 0 attrList chosenName
        None

    def applyAdadelta chosenName var accum accumUpdate lr rho epsilon grad t useLocking:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "use_locking" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useLocking then 1 else 0) . toCArg]
        wrappers = makeOutputWrappers "ApplyAdadelta" [var.wrapper, accum.wrapper, accumUpdate.wrapper, lr.wrapper, rho.wrapper, epsilon.wrapper, grad.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get var.typetag

    def batchMatrixDiag chosenName diagonal t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "BatchMatrixDiag" [diagonal.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get diagonal.typetag

    def fakeQuantWithMinMaxArgsGradient chosenName gradients inputs min max numBits narrowRange:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "min" nameCStr:
            callHandlingError "add_attr_float" None [attrList.toCArg, nameCStr.toCArg, CFloat.fromReal min . toCArg]
        CString.with "max" nameCStr:
            callHandlingError "add_attr_float" None [attrList.toCArg, nameCStr.toCArg, CFloat.fromReal max . toCArg]
        CString.with "num_bits" nameCStr:
                callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt numBits . toCArg]
        CString.with "narrow_range" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if narrowRange then 1 else 0) . toCArg]
        wrappers = makeOutputWrappers "FakeQuantWithMinMaxArgsGradient" [gradients.wrapper, inputs.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get FloatType

    def applyPowerSign chosenName var m lr logbase signDecay beta grad t useLocking:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "use_locking" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useLocking then 1 else 0) . toCArg]
        wrappers = makeOutputWrappers "ApplyPowerSign" [var.wrapper, m.wrapper, lr.wrapper, logbase.wrapper, signDecay.wrapper, beta.wrapper, grad.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get var.typetag

    def batchMatMul chosenName x y t adjX adjY:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "adj_x" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if adjX then 1 else 0) . toCArg]
        CString.with "adj_y" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if adjY then 1 else 0) . toCArg]
        wrappers = makeOutputWrappers "BatchMatMul" [x.wrapper, y.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get x.typetag

    def sparseSlice chosenName indices values shape start size t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "SparseSlice" [indices.wrapper, values.wrapper, shape.wrapper, start.wrapper, size.wrapper] 3 attrList chosenName
            (TFOutput (wrappers.getAt 0) Int64Type, TFOutput (wrappers.getAt 1) values.typetag, TFOutput (wrappers.getAt 2) Int64Type)

    def l2Loss chosenName t t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "L2Loss" [t.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get t.typetag

    def denseToSparseSetOperation chosenName set1 set2Indices set2Values set2Shape setOperation validateIndices t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "set_operation" nameCStr:
            CString.with setOperation valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        CString.with "validate_indices" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if validateIndices then 1 else 0) . toCArg]
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "DenseToSparseSetOperation" [set1.wrapper, set2Indices.wrapper, set2Values.wrapper, set2Shape.wrapper] 3 attrList chosenName
            (TFOutput (wrappers.getAt 0) Int64Type, TFOutput (wrappers.getAt 1) set1.typetag, TFOutput (wrappers.getAt 2) Int64Type)

    def sparseToSparseSetOperation chosenName set1Indices set1Values set1Shape set2Indices set2Values set2Shape setOperation validateIndices t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "set_operation" nameCStr:
            CString.with setOperation valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        CString.with "validate_indices" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if validateIndices then 1 else 0) . toCArg]
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "SparseToSparseSetOperation" [set1Indices.wrapper, set1Values.wrapper, set1Shape.wrapper, set2Indices.wrapper, set2Values.wrapper, set2Shape.wrapper] 3 attrList chosenName
            (TFOutput (wrappers.getAt 0) Int64Type, TFOutput (wrappers.getAt 1) set1Values.typetag, TFOutput (wrappers.getAt 2) Int64Type)

    def deserializeSparse chosenName serializedSparse dtype tserialized:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "dtype" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt dtype.num . toCArg]
        CString.with "Tserialized" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tserialized.num . toCArg]
        wrappers = makeOutputWrappers "DeserializeSparse" [serializedSparse.wrapper] 3 attrList chosenName
            (TFOutput (wrappers.getAt 0) Int64Type, TFOutput (wrappers.getAt 1) dtype, TFOutput (wrappers.getAt 2) Int64Type)

    def deserializeManySparse chosenName serializedSparse dtype:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "dtype" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt dtype.num . toCArg]
        wrappers = makeOutputWrappers "DeserializeManySparse" [serializedSparse.wrapper] 3 attrList chosenName
            (TFOutput (wrappers.getAt 0) Int64Type, TFOutput (wrappers.getAt 1) dtype, TFOutput (wrappers.getAt 2) Int64Type)

    def immutableConst chosenName dtype shape memoryRegionName:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "dtype" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt dtype.num . toCArg]
        CString.with "shape" nameCStr:
            cdims = shape.map CInt64.fromInt
            Array CInt64 . with cdims cdimsArray:
                callHandlingError "add_attr_shape" None [attrList.toCArg, nameCStr.toCArg, cdimsArray.toCArg, CUInt32.fromInt shape.length . toCArg]
        CString.with "memory_region_name" nameCStr:
            CString.with memoryRegionName valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        wrappers = makeOutputWrappers "ImmutableConst" [] 1 attrList chosenName
        TFOutput wrappers.head.get dtype

    def sparseToDense chosenName sparseIndices outputShape sparseValues defaultValue validateIndices t tindices:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "validate_indices" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if validateIndices then 1 else 0) . toCArg]
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "Tindices" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
        wrappers = makeOutputWrappers "SparseToDense" [sparseIndices.wrapper, outputShape.wrapper, sparseValues.wrapper, defaultValue.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get sparseValues.typetag

    def batchToSpace chosenName input crops t blockSize tidx:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "block_size" nameCStr:
                callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt blockSize . toCArg]
        CString.with "Tidx" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tidx.num . toCArg]
        wrappers = makeOutputWrappers "BatchToSpace" [input.wrapper, crops.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get input.typetag

    def listDiff chosenName x y t outIdx:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "out_idx" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt outIdx.num . toCArg]
        wrappers = makeOutputWrappers "ListDiff" [x.wrapper, y.wrapper] 2 attrList chosenName
            (TFOutput (wrappers.getAt 0) x.typetag, TFOutput (wrappers.getAt 1) outIdx)

    def sparseReorder chosenName inputIndices inputValues inputShape t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "SparseReorder" [inputIndices.wrapper, inputValues.wrapper, inputShape.wrapper] 2 attrList chosenName
            (TFOutput (wrappers.getAt 0) Int64Type, TFOutput (wrappers.getAt 1) inputValues.typetag)

    def tensorArraySplitV2 chosenName handle value lengths flowIn t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "TensorArraySplitV2" [handle.wrapper, value.wrapper, lengths.wrapper, flowIn.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get FloatType

    def sparseReshape chosenName inputIndices inputShape newShape:
        wrappers = makeOutputWrappers "SparseReshape" [inputIndices.wrapper, inputShape.wrapper, newShape.wrapper] 2 attrList chosenName
            (TFOutput (wrappers.getAt 0) Int64Type, TFOutput (wrappers.getAt 1) Int64Type)

    def sparseTensorDenseAdd chosenName aIndices aValues aShape b t tindices:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "Tindices" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
        wrappers = makeOutputWrappers "SparseTensorDenseAdd" [aIndices.wrapper, aValues.wrapper, aShape.wrapper, b.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get aValues.typetag

    def sparseReduceSum chosenName inputIndices inputValues inputShape reductionAxes keepDims t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "keep_dims" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if keepDims then 1 else 0) . toCArg]
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "SparseReduceSum" [inputIndices.wrapper, inputValues.wrapper, inputShape.wrapper, reductionAxes.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get inputValues.typetag

    def sparseReduceSumSparse chosenName inputIndices inputValues inputShape reductionAxes keepDims t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "keep_dims" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if keepDims then 1 else 0) . toCArg]
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "SparseReduceSumSparse" [inputIndices.wrapper, inputValues.wrapper, inputShape.wrapper, reductionAxes.wrapper] 3 attrList chosenName
            (TFOutput (wrappers.getAt 0) Int64Type, TFOutput (wrappers.getAt 1) inputValues.typetag, TFOutput (wrappers.getAt 2) Int64Type)

    def mul chosenName x y t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "Mul" [x.wrapper, y.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get x.typetag

    def sparseDenseCwiseMul chosenName spIndices spValues spShape dense t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "SparseDenseCwiseMul" [spIndices.wrapper, spValues.wrapper, spShape.wrapper, dense.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get spValues.typetag

    def sparseSoftmax chosenName spIndices spValues spShape t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "SparseSoftmax" [spIndices.wrapper, spValues.wrapper, spShape.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get spValues.typetag

    def sparseSparseMinimum chosenName aIndices aValues aShape bIndices bValues bShape t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "SparseSparseMinimum" [aIndices.wrapper, aValues.wrapper, aShape.wrapper, bIndices.wrapper, bValues.wrapper, bShape.wrapper] 2 attrList chosenName
            (TFOutput (wrappers.getAt 0) Int64Type, TFOutput (wrappers.getAt 1) aValues.typetag)

    def tile chosenName input multiples t tmultiples:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "Tmultiples" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tmultiples.num . toCArg]
        wrappers = makeOutputWrappers "Tile" [input.wrapper, multiples.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get input.typetag

    def dilation2DBackpropFilter chosenName input filter outBackprop t strides rates padding:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "strides" nameCStr:
            cvalues = strides.map CInt64.fromInt
            Array CInt64 . with cvalues cvaluesArray:
                callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
        CString.with "rates" nameCStr:
            cvalues = rates.map CInt64.fromInt
            Array CInt64 . with cvalues cvaluesArray:
                callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt rates.length . toCArg]
        CString.with "padding" nameCStr:
            CString.with padding valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        wrappers = makeOutputWrappers "Dilation2DBackpropFilter" [input.wrapper, filter.wrapper, outBackprop.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get input.typetag

    def lookupTableImport chosenName tableHandle keys values tin tout:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "Tin" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tin.num . toCArg]
        CString.with "Tout" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tout.num . toCArg]
        wrappers = makeOutputWrappers "LookupTableImport" [tableHandle.wrapper, keys.wrapper, values.wrapper] 0 attrList chosenName
        None

    def const chosenName value dtype:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "value" nameCStr:
                callHandlingError "add_attr_tensor" None [attrList.toCArg, nameCStr.toCArg, value.ptr.toCArg]
        CString.with "dtype" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt dtype.num . toCArg]
        wrappers = makeOutputWrappers "Const" [] 1 attrList chosenName
        TFOutput wrappers.head.get dtype

    def sparseFillEmptyRows chosenName indices values denseShape defaultValue t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "SparseFillEmptyRows" [indices.wrapper, values.wrapper, denseShape.wrapper, defaultValue.wrapper] 4 attrList chosenName
            (TFOutput (wrappers.getAt 0) Int64Type, TFOutput (wrappers.getAt 1) values.typetag, TFOutput (wrappers.getAt 2) BoolType, TFOutput (wrappers.getAt 3) Int64Type)

    def reverse chosenName tensor dims t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "Reverse" [tensor.wrapper, dims.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get tensor.typetag

    def logSoftmax chosenName logits t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "LogSoftmax" [logits.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get logits.typetag

    def invertPermutation chosenName x t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "InvertPermutation" [x.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get x.typetag

    def mirrorPadGrad chosenName input paddings t tpaddings mode:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "Tpaddings" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tpaddings.num . toCArg]
        CString.with "mode" nameCStr:
            CString.with mode valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        wrappers = makeOutputWrappers "MirrorPadGrad" [input.wrapper, paddings.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get input.typetag

    def onesLike chosenName x t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "OnesLike" [x.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get x.typetag

    def sparseFillEmptyRowsGrad chosenName reverseIndexMap gradValues t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "SparseFillEmptyRowsGrad" [reverseIndexMap.wrapper, gradValues.wrapper] 2 attrList chosenName
            (TFOutput (wrappers.getAt 0) gradValues.typetag, TFOutput (wrappers.getAt 1) gradValues.typetag)

    def diag chosenName diagonal t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "Diag" [diagonal.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get diagonal.typetag

    def fakeQuantWithMinMaxVarsPerChannel chosenName inputs min max numBits narrowRange:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "num_bits" nameCStr:
                callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt numBits . toCArg]
        CString.with "narrow_range" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if narrowRange then 1 else 0) . toCArg]
        wrappers = makeOutputWrappers "FakeQuantWithMinMaxVarsPerChannel" [inputs.wrapper, min.wrapper, max.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get FloatType

    def encodeJpeg chosenName image format quality progressive optimizeSize chromaDownsampling densityUnit xDensity yDensity xmpMetadata:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "format" nameCStr:
            CString.with format valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        CString.with "quality" nameCStr:
                callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt quality . toCArg]
        CString.with "progressive" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if progressive then 1 else 0) . toCArg]
        CString.with "optimize_size" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if optimizeSize then 1 else 0) . toCArg]
        CString.with "chroma_downsampling" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if chromaDownsampling then 1 else 0) . toCArg]
        CString.with "density_unit" nameCStr:
            CString.with densityUnit valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        CString.with "x_density" nameCStr:
                callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt xDensity . toCArg]
        CString.with "y_density" nameCStr:
                callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt yDensity . toCArg]
        CString.with "xmp_metadata" nameCStr:
            CString.with xmpMetadata valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        wrappers = makeOutputWrappers "EncodeJpeg" [image.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get StringType

    def add chosenName x y t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "Add" [x.wrapper, y.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get x.typetag

    def randomGammaGrad chosenName alpha sample t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "RandomGammaGrad" [alpha.wrapper, sample.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get alpha.typetag

    def sparseAccumulatorTakeGradient chosenName handle numRequired dtype:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "dtype" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt dtype.num . toCArg]
        wrappers = makeOutputWrappers "SparseAccumulatorTakeGradient" [handle.wrapper, numRequired.wrapper] 3 attrList chosenName
            (TFOutput (wrappers.getAt 0) Int64Type, TFOutput (wrappers.getAt 1) dtype, TFOutput (wrappers.getAt 2) Int64Type)

    def floorMod chosenName x y t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "FloorMod" [x.wrapper, y.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get x.typetag

    def statelessRandomUniform chosenName shape seed dtype t tseed:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "dtype" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt dtype.num . toCArg]
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "Tseed" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tseed.num . toCArg]
        wrappers = makeOutputWrappers "StatelessRandomUniform" [shape.wrapper, seed.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get dtype

    def statelessRandomNormal chosenName shape seed dtype t tseed:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "dtype" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt dtype.num . toCArg]
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "Tseed" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tseed.num . toCArg]
        wrappers = makeOutputWrappers "StatelessRandomNormal" [shape.wrapper, seed.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get dtype

    def statelessMultinomial chosenName logits numSamples seed t tseed outputDtype:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "Tseed" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tseed.num . toCArg]
        CString.with "output_dtype" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt outputDtype.num . toCArg]
        wrappers = makeOutputWrappers "StatelessMultinomial" [logits.wrapper, numSamples.wrapper, seed.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get outputDtype

    def regexReplace chosenName input pattern rewrite replaceGlobal:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "replace_global" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if replaceGlobal then 1 else 0) . toCArg]
        wrappers = makeOutputWrappers "RegexReplace" [input.wrapper, pattern.wrapper, rewrite.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get StringType

    def regexFullMatch chosenName input pattern:
        wrappers = makeOutputWrappers "RegexFullMatch" [input.wrapper, pattern.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get BoolType

    def tensorArrayScatterV2 chosenName handle indices value flowIn t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "TensorArrayScatterV2" [handle.wrapper, indices.wrapper, value.wrapper, flowIn.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get FloatType

    def asString chosenName input t precision scientific shortest width fill:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "precision" nameCStr:
                callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt precision . toCArg]
        CString.with "scientific" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if scientific then 1 else 0) . toCArg]
        CString.with "shortest" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if shortest then 1 else 0) . toCArg]
        CString.with "width" nameCStr:
                callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt width . toCArg]
        CString.with "fill" nameCStr:
            CString.with fill valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        wrappers = makeOutputWrappers "AsString" [input.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get StringType

    def stringSplit chosenName input delimiter skipEmpty:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "skip_empty" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if skipEmpty then 1 else 0) . toCArg]
        wrappers = makeOutputWrappers "StringSplit" [input.wrapper, delimiter.wrapper] 3 attrList chosenName
            (TFOutput (wrappers.getAt 0) Int64Type, TFOutput (wrappers.getAt 1) StringType, TFOutput (wrappers.getAt 2) Int64Type)

    def stringSplitV2 chosenName input sep maxsplit:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "maxsplit" nameCStr:
                callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt maxsplit . toCArg]
        wrappers = makeOutputWrappers "StringSplitV2" [input.wrapper, sep.wrapper] 3 attrList chosenName
            (TFOutput (wrappers.getAt 0) Int64Type, TFOutput (wrappers.getAt 1) StringType, TFOutput (wrappers.getAt 2) Int64Type)

    def stringStrip chosenName input:
        wrappers = makeOutputWrappers "StringStrip" [input.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get StringType

    def stringToHashBucketStrong chosenName input numBuckets key:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "num_buckets" nameCStr:
                callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt numBuckets . toCArg]
        CString.with "key" nameCStr:
            cvalues = key.map CInt64.fromInt
            Array CInt64 . with cvalues cvaluesArray:
                callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt key.length . toCArg]
        wrappers = makeOutputWrappers "StringToHashBucketStrong" [input.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get Int64Type

    def stringLength chosenName input:
        wrappers = makeOutputWrappers "StringLength" [input.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get Int32Type

    def tensorArrayCloseV2 chosenName handle:
        wrappers = makeOutputWrappers "TensorArrayCloseV2" [handle.wrapper] 0 attrList chosenName
        None

    def encodeBase64 chosenName input pad:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "pad" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if pad then 1 else 0) . toCArg]
        wrappers = makeOutputWrappers "EncodeBase64" [input.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get StringType

    def applyAdaMax chosenName var m v beta1Power lr beta1 beta2 epsilon grad t useLocking:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "use_locking" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useLocking then 1 else 0) . toCArg]
        wrappers = makeOutputWrappers "ApplyAdaMax" [var.wrapper, m.wrapper, v.wrapper, beta1Power.wrapper, lr.wrapper, beta1.wrapper, beta2.wrapper, epsilon.wrapper, grad.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get var.typetag

    def prod chosenName input reductionIndices keepDims t tidx:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "keep_dims" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if keepDims then 1 else 0) . toCArg]
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "Tidx" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tidx.num . toCArg]
        wrappers = makeOutputWrappers "Prod" [input.wrapper, reductionIndices.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get input.typetag

    def isVariableInitialized chosenName ref dtype:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "dtype" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt dtype.num . toCArg]
        wrappers = makeOutputWrappers "IsVariableInitialized" [ref.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get BoolType

    def gather chosenName params indices validateIndices tparams tindices:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "validate_indices" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if validateIndices then 1 else 0) . toCArg]
        CString.with "Tparams" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tparams.num . toCArg]
        CString.with "Tindices" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
        wrappers = makeOutputWrappers "Gather" [params.wrapper, indices.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get params.typetag

    def destroyTemporaryVariable chosenName ref t varName:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "var_name" nameCStr:
            CString.with varName valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        wrappers = makeOutputWrappers "DestroyTemporaryVariable" [ref.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get ref.typetag

    def cast chosenName x srcT dstT truncate:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "SrcT" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt srcT.num . toCArg]
        CString.with "DstT" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt dstT.num . toCArg]
        CString.with "Truncate" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if truncate then 1 else 0) . toCArg]
        wrappers = makeOutputWrappers "Cast" [x.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get dstT

    def assignSub chosenName ref value t useLocking:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "use_locking" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useLocking then 1 else 0) . toCArg]
        wrappers = makeOutputWrappers "AssignSub" [ref.wrapper, value.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get ref.typetag

    def scatterAdd chosenName ref indices updates t tindices useLocking:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "Tindices" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
        CString.with "use_locking" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useLocking then 1 else 0) . toCArg]
        wrappers = makeOutputWrappers "ScatterAdd" [ref.wrapper, indices.wrapper, updates.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get ref.typetag

    def scatterMul chosenName ref indices updates t tindices useLocking:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "Tindices" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
        CString.with "use_locking" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useLocking then 1 else 0) . toCArg]
        wrappers = makeOutputWrappers "ScatterMul" [ref.wrapper, indices.wrapper, updates.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get ref.typetag

    def scatterMax chosenName ref indices updates t tindices useLocking:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "Tindices" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
        CString.with "use_locking" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useLocking then 1 else 0) . toCArg]
        wrappers = makeOutputWrappers "ScatterMax" [ref.wrapper, indices.wrapper, updates.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get ref.typetag

    def mirrorPad chosenName input paddings t tpaddings mode:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "Tpaddings" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tpaddings.num . toCArg]
        CString.with "mode" nameCStr:
            CString.with mode valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        wrappers = makeOutputWrappers "MirrorPad" [input.wrapper, paddings.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get input.typetag

    def batchMatrixDiagPart chosenName input t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "BatchMatrixDiagPart" [input.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get input.typetag

    def scatterNdUpdate chosenName ref indices updates t tindices useLocking:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "Tindices" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
        CString.with "use_locking" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useLocking then 1 else 0) . toCArg]
        wrappers = makeOutputWrappers "ScatterNdUpdate" [ref.wrapper, indices.wrapper, updates.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get ref.typetag

    def div chosenName x y t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "Div" [x.wrapper, y.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get x.typetag

    def scatterNdSub chosenName ref indices updates t tindices useLocking:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "Tindices" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
        CString.with "use_locking" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useLocking then 1 else 0) . toCArg]
        wrappers = makeOutputWrappers "ScatterNdSub" [ref.wrapper, indices.wrapper, updates.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get ref.typetag

    def topK chosenName input k sorted t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "k" nameCStr:
                callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt k . toCArg]
        CString.with "sorted" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if sorted then 1 else 0) . toCArg]
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "TopK" [input.wrapper] 2 attrList chosenName
            (TFOutput (wrappers.getAt 0) input.typetag, TFOutput (wrappers.getAt 1) Int32Type)

    def applyProximalGradientDescent chosenName var alpha l1 l2 delta t useLocking:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "use_locking" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useLocking then 1 else 0) . toCArg]
        wrappers = makeOutputWrappers "ApplyProximalGradientDescent" [var.wrapper, alpha.wrapper, l1.wrapper, l2.wrapper, delta.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get var.typetag

    def matchingFiles chosenName pattern:
        wrappers = makeOutputWrappers "MatchingFiles" [pattern.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get StringType

    def sparseApplyProximalGradientDescent chosenName var alpha l1 l2 grad indices t tindices useLocking:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "Tindices" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
        CString.with "use_locking" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useLocking then 1 else 0) . toCArg]
        wrappers = makeOutputWrappers "SparseApplyProximalGradientDescent" [var.wrapper, alpha.wrapper, l1.wrapper, l2.wrapper, grad.wrapper, indices.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get var.typetag

    def sparseApplyAdadelta chosenName var accum accumUpdate lr rho epsilon grad indices t tindices useLocking:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "Tindices" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
        CString.with "use_locking" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useLocking then 1 else 0) . toCArg]
        wrappers = makeOutputWrappers "SparseApplyAdadelta" [var.wrapper, accum.wrapper, accumUpdate.wrapper, lr.wrapper, rho.wrapper, epsilon.wrapper, grad.wrapper, indices.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get var.typetag

    def audioSummaryV2 chosenName tag tensor sampleRate maxOutputs:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "max_outputs" nameCStr:
                callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt maxOutputs . toCArg]
        wrappers = makeOutputWrappers "AudioSummaryV2" [tag.wrapper, tensor.wrapper, sampleRate.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get StringType

    def applyAdagrad chosenName var accum lr grad t useLocking updateSlots:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "use_locking" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useLocking then 1 else 0) . toCArg]
        CString.with "update_slots" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if updateSlots then 1 else 0) . toCArg]
        wrappers = makeOutputWrappers "ApplyAdagrad" [var.wrapper, accum.wrapper, lr.wrapper, grad.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get var.typetag

    def matrixSolveLs chosenName matrix rhs l2Regularizer t fast:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "fast" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if fast then 1 else 0) . toCArg]
        wrappers = makeOutputWrappers "MatrixSolveLs" [matrix.wrapper, rhs.wrapper, l2Regularizer.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get matrix.typetag

    def bitwiseOr chosenName x y t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "BitwiseOr" [x.wrapper, y.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get x.typetag

    def applyProximalAdagrad chosenName var accum lr l1 l2 grad t useLocking:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "use_locking" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useLocking then 1 else 0) . toCArg]
        wrappers = makeOutputWrappers "ApplyProximalAdagrad" [var.wrapper, accum.wrapper, lr.wrapper, l1.wrapper, l2.wrapper, grad.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get var.typetag

    def sparseApplyFtrl chosenName var accum linear grad indices lr l1 l2 lrPower t tindices useLocking:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "Tindices" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
        CString.with "use_locking" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useLocking then 1 else 0) . toCArg]
        wrappers = makeOutputWrappers "SparseApplyFtrl" [var.wrapper, accum.wrapper, linear.wrapper, grad.wrapper, indices.wrapper, lr.wrapper, l1.wrapper, l2.wrapper, lrPower.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get var.typetag

    def sub chosenName x y t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "Sub" [x.wrapper, y.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get x.typetag

    def isInf chosenName x t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "IsInf" [x.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get BoolType

    def applyFtrlV2 chosenName var accum linear grad lr l1 l2 l2Shrinkage lrPower t useLocking:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "use_locking" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useLocking then 1 else 0) . toCArg]
        wrappers = makeOutputWrappers "ApplyFtrlV2" [var.wrapper, accum.wrapper, linear.wrapper, grad.wrapper, lr.wrapper, l1.wrapper, l2.wrapper, l2Shrinkage.wrapper, lrPower.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get var.typetag

    def bitwiseXor chosenName x y t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "BitwiseXor" [x.wrapper, y.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get x.typetag

    def stringToNumber chosenName stringTensor outType:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "out_type" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt outType.num . toCArg]
        wrappers = makeOutputWrappers "StringToNumber" [stringTensor.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get outType

    def sparseDenseCwiseDiv chosenName spIndices spValues spShape dense t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "SparseDenseCwiseDiv" [spIndices.wrapper, spValues.wrapper, spShape.wrapper, dense.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get spValues.typetag

    def applyMomentum chosenName var accum lr grad momentum t useLocking useNesterov:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "use_locking" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useLocking then 1 else 0) . toCArg]
        CString.with "use_nesterov" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useNesterov then 1 else 0) . toCArg]
        wrappers = makeOutputWrappers "ApplyMomentum" [var.wrapper, accum.wrapper, lr.wrapper, grad.wrapper, momentum.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get var.typetag

    def sparseApplyMomentum chosenName var accum lr grad indices momentum t tindices useLocking useNesterov:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "Tindices" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
        CString.with "use_locking" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useLocking then 1 else 0) . toCArg]
        CString.with "use_nesterov" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useNesterov then 1 else 0) . toCArg]
        wrappers = makeOutputWrappers "SparseApplyMomentum" [var.wrapper, accum.wrapper, lr.wrapper, grad.wrapper, indices.wrapper, momentum.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get var.typetag

    def crossReplicaSum chosenName input groupAssignment t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "CrossReplicaSum" [input.wrapper, groupAssignment.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get input.typetag

    def applyCenteredRMSProp chosenName var mg ms mom lr rho momentum epsilon grad t useLocking:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "use_locking" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useLocking then 1 else 0) . toCArg]
        wrappers = makeOutputWrappers "ApplyCenteredRMSProp" [var.wrapper, mg.wrapper, ms.wrapper, mom.wrapper, lr.wrapper, rho.wrapper, momentum.wrapper, epsilon.wrapper, grad.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get var.typetag

    def sparseApplyRMSProp chosenName var ms mom lr rho momentum epsilon grad indices t tindices useLocking:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "Tindices" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
        CString.with "use_locking" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useLocking then 1 else 0) . toCArg]
        wrappers = makeOutputWrappers "SparseApplyRMSProp" [var.wrapper, ms.wrapper, mom.wrapper, lr.wrapper, rho.wrapper, momentum.wrapper, epsilon.wrapper, grad.wrapper, indices.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get var.typetag

    def sparseApplyCenteredRMSProp chosenName var mg ms mom lr rho momentum epsilon grad indices t tindices useLocking:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "Tindices" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
        CString.with "use_locking" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useLocking then 1 else 0) . toCArg]
        wrappers = makeOutputWrappers "SparseApplyCenteredRMSProp" [var.wrapper, mg.wrapper, ms.wrapper, mom.wrapper, lr.wrapper, rho.wrapper, momentum.wrapper, epsilon.wrapper, grad.wrapper, indices.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get var.typetag

    def size chosenName input t outType:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "out_type" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt outType.num . toCArg]
        wrappers = makeOutputWrappers "Size" [input.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get outType

    def biasAddV1 chosenName value bias t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "BiasAddV1" [value.wrapper, bias.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get value.typetag

    def reverseV2 chosenName tensor axis tidx t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "Tidx" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tidx.num . toCArg]
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "ReverseV2" [tensor.wrapper, axis.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get tensor.typetag

    def applyAddSign chosenName var m lr alpha signDecay beta grad t useLocking:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "use_locking" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useLocking then 1 else 0) . toCArg]
        wrappers = makeOutputWrappers "ApplyAddSign" [var.wrapper, m.wrapper, lr.wrapper, alpha.wrapper, signDecay.wrapper, beta.wrapper, grad.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get var.typetag

    def matrixDeterminant chosenName input t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "MatrixDeterminant" [input.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get input.typetag

    def readerNumWorkUnitsCompleted chosenName readerHandle:
        wrappers = makeOutputWrappers "ReaderNumWorkUnitsCompleted" [readerHandle.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get Int64Type

    def gcsConfigureCredentials chosenName json:
        wrappers = makeOutputWrappers "GcsConfigureCredentials" [json.wrapper] 0 attrList chosenName
        None

    def softplus chosenName features t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "Softplus" [features.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get features.typetag

    def expm1 chosenName x t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "Expm1" [x.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get x.typetag

    def nextIteration chosenName data t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "NextIteration" [data.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get data.typetag

    def fact chosenName:
        wrappers = makeOutputWrappers "Fact" [] 1 attrList chosenName
        TFOutput wrappers.head.get StringType

    def bitwiseAnd chosenName x y t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "BitwiseAnd" [x.wrapper, y.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get x.typetag

    def leftShift chosenName x y t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "LeftShift" [x.wrapper, y.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get x.typetag

    def rightShift chosenName x y t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "RightShift" [x.wrapper, y.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get x.typetag

    def inplaceUpdate chosenName x i v t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "InplaceUpdate" [x.wrapper, i.wrapper, v.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get x.typetag

    def sigmoid chosenName x t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "Sigmoid" [x.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get x.typetag

    def inplaceAdd chosenName x i v t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "InplaceAdd" [x.wrapper, i.wrapper, v.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get x.typetag

    def inplaceSub chosenName x i v t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "InplaceSub" [x.wrapper, i.wrapper, v.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get x.typetag

    def unravelIndex chosenName indices dims tidx:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "Tidx" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tidx.num . toCArg]
        wrappers = makeOutputWrappers "UnravelIndex" [indices.wrapper, dims.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get indices.typetag

    def broadcastTo chosenName input shape t tidx:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "Tidx" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tidx.num . toCArg]
        wrappers = makeOutputWrappers "BroadcastTo" [input.wrapper, shape.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get input.typetag

    def hostConst chosenName value dtype:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "value" nameCStr:
                callHandlingError "add_attr_tensor" None [attrList.toCArg, nameCStr.toCArg, value.ptr.toCArg]
        CString.with "dtype" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt dtype.num . toCArg]
        wrappers = makeOutputWrappers "HostConst" [] 1 attrList chosenName
        TFOutput wrappers.head.get dtype

    def refNextIteration chosenName data t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "RefNextIteration" [data.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get data.typetag

    def zerosLike chosenName x t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "ZerosLike" [x.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get x.typetag

    def invert chosenName x t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "Invert" [x.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get x.typetag

    def matrixDiag chosenName diagonal t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "MatrixDiag" [diagonal.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get diagonal.typetag

    def floorDiv chosenName x y t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "FloorDiv" [x.wrapper, y.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get x.typetag

    def editDistance chosenName hypothesisIndices hypothesisValues hypothesisShape truthIndices truthValues truthShape normalize t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "normalize" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if normalize then 1 else 0) . toCArg]
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "EditDistance" [hypothesisIndices.wrapper, hypothesisValues.wrapper, hypothesisShape.wrapper, truthIndices.wrapper, truthValues.wrapper, truthShape.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get FloatType

    def gatherV2 chosenName params indices axis tparams tindices taxis:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "Tparams" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tparams.num . toCArg]
        CString.with "Tindices" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
        CString.with "Taxis" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt taxis.num . toCArg]
        wrappers = makeOutputWrappers "GatherV2" [params.wrapper, indices.wrapper, axis.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get params.typetag

    def erfc chosenName x t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "Erfc" [x.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get x.typetag

    def gatherNd chosenName params indices tparams tindices:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "Tparams" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tparams.num . toCArg]
        CString.with "Tindices" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
        wrappers = makeOutputWrappers "GatherNd" [params.wrapper, indices.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get params.typetag

    def refIdentity chosenName input t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "RefIdentity" [input.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get input.typetag

    def stopGradient chosenName input t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "StopGradient" [input.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get input.typetag

    def asin chosenName x t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "Asin" [x.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get x.typetag

    def preventGradient chosenName input t message:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "message" nameCStr:
            CString.with message valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        wrappers = makeOutputWrappers "PreventGradient" [input.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get input.typetag

    def checkNumerics chosenName tensor t message:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "message" nameCStr:
            CString.with message valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        wrappers = makeOutputWrappers "CheckNumerics" [tensor.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get tensor.typetag

    def conjugateTranspose chosenName x perm t tperm:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "Tperm" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tperm.num . toCArg]
        wrappers = makeOutputWrappers "ConjugateTranspose" [x.wrapper, perm.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get x.typetag

    def uniqueV2 chosenName x axis t taxis outIdx:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "Taxis" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt taxis.num . toCArg]
        CString.with "out_idx" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt outIdx.num . toCArg]
        wrappers = makeOutputWrappers "UniqueV2" [x.wrapper, axis.wrapper] 2 attrList chosenName
            (TFOutput (wrappers.getAt 0) x.typetag, TFOutput (wrappers.getAt 1) outIdx)

    def uniqueWithCountsV2 chosenName x axis t taxis outIdx:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "Taxis" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt taxis.num . toCArg]
        CString.with "out_idx" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt outIdx.num . toCArg]
        wrappers = makeOutputWrappers "UniqueWithCountsV2" [x.wrapper, axis.wrapper] 3 attrList chosenName
            (TFOutput (wrappers.getAt 0) x.typetag, TFOutput (wrappers.getAt 1) outIdx, TFOutput (wrappers.getAt 2) outIdx)

    def reverseSequence chosenName input seqLengths seqDim batchDim t tlen:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "seq_dim" nameCStr:
                callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt seqDim . toCArg]
        CString.with "batch_dim" nameCStr:
                callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt batchDim . toCArg]
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "Tlen" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tlen.num . toCArg]
        wrappers = makeOutputWrappers "ReverseSequence" [input.wrapper, seqLengths.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get input.typetag

    def rsqrtGrad chosenName y dy t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "RsqrtGrad" [y.wrapper, dy.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get y.typetag

    def slice chosenName input begin size t index:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "Index" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt index.num . toCArg]
        wrappers = makeOutputWrappers "Slice" [input.wrapper, begin.wrapper, size.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get input.typetag

    def copy chosenName input t tensorName debugOpsSpec:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "tensor_name" nameCStr:
            CString.with tensorName valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        CString.with "debug_ops_spec" nameCStr:
            len = debugOpsSpec.length
            cValues = ManagedPointer (Pointer CInt64) . mallocElems len
            indexed = 0.upto (len - 1) . zip debugOpsSpec
            indexed.each (idx, elem):
                cValues.moveElems idx . write (CString.fromText elem)
            callHandlingError "add_attr_string_list" None [attrList.toCArg, nameCStr.toCArg, cValues.toCArg, CUInt32.fromInt len . toCArg]
            0.upto (len - 1) . each (idx: cValues.moveElems idx . read . free)
        wrappers = makeOutputWrappers "Copy" [input.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get input.typetag

    def stridedSliceGrad chosenName shape begin end strides dy t index beginMask endMask ellipsisMask newAxisMask shrinkAxisMask:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "Index" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt index.num . toCArg]
        CString.with "begin_mask" nameCStr:
                callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt beginMask . toCArg]
        CString.with "end_mask" nameCStr:
                callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt endMask . toCArg]
        CString.with "ellipsis_mask" nameCStr:
                callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt ellipsisMask . toCArg]
        CString.with "new_axis_mask" nameCStr:
                callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt newAxisMask . toCArg]
        CString.with "shrink_axis_mask" nameCStr:
                callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt shrinkAxisMask . toCArg]
        wrappers = makeOutputWrappers "StridedSliceGrad" [shape.wrapper, begin.wrapper, end.wrapper, strides.wrapper, dy.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get dy.typetag

    def stridedSliceAssign chosenName ref begin end strides value t index beginMask endMask ellipsisMask newAxisMask shrinkAxisMask:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "Index" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt index.num . toCArg]
        CString.with "begin_mask" nameCStr:
                callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt beginMask . toCArg]
        CString.with "end_mask" nameCStr:
                callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt endMask . toCArg]
        CString.with "ellipsis_mask" nameCStr:
                callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt ellipsisMask . toCArg]
        CString.with "new_axis_mask" nameCStr:
                callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt newAxisMask . toCArg]
        CString.with "shrink_axis_mask" nameCStr:
                callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt shrinkAxisMask . toCArg]
        wrappers = makeOutputWrappers "StridedSliceAssign" [ref.wrapper, begin.wrapper, end.wrapper, strides.wrapper, value.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get ref.typetag

    def tileGrad chosenName input multiples t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "TileGrad" [input.wrapper, multiples.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get input.typetag

    def dataFormatDimMap chosenName x t srcFormat dstFormat:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "src_format" nameCStr:
            CString.with srcFormat valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        CString.with "dst_format" nameCStr:
            CString.with dstFormat valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        wrappers = makeOutputWrappers "DataFormatDimMap" [x.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get x.typetag

    def broadcastArgs chosenName s0 s1 t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "BroadcastArgs" [s0.wrapper, s1.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get s0.typetag

    def broadcastGradientArgs chosenName s0 s1 t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "BroadcastGradientArgs" [s0.wrapper, s1.wrapper] 2 attrList chosenName
            (TFOutput (wrappers.getAt 0) s0.typetag, TFOutput (wrappers.getAt 1) s0.typetag)

    def placeholderV2 chosenName dtype shape:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "dtype" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt dtype.num . toCArg]
        CString.with "shape" nameCStr:
            cdims = shape.map CInt64.fromInt
            Array CInt64 . with cdims cdimsArray:
                callHandlingError "add_attr_shape" None [attrList.toCArg, nameCStr.toCArg, cdimsArray.toCArg, CUInt32.fromInt shape.length . toCArg]
        wrappers = makeOutputWrappers "PlaceholderV2" [] 1 attrList chosenName
        TFOutput wrappers.head.get dtype

    def expandDims chosenName input dim t tdim:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "Tdim" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tdim.num . toCArg]
        wrappers = makeOutputWrappers "ExpandDims" [input.wrapper, dim.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get input.typetag

    def squeeze chosenName input t squeezeDims:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "squeeze_dims" nameCStr:
            cvalues = squeezeDims.map CInt64.fromInt
            Array CInt64 . with cvalues cvaluesArray:
                callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt squeezeDims.length . toCArg]
        wrappers = makeOutputWrappers "Squeeze" [input.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get input.typetag

    def spaceToBatchND chosenName input blockShape paddings t tblockShape tpaddings:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "Tblock_shape" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tblockShape.num . toCArg]
        CString.with "Tpaddings" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tpaddings.num . toCArg]
        wrappers = makeOutputWrappers "SpaceToBatchND" [input.wrapper, blockShape.wrapper, paddings.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get input.typetag

    def quantizeAndDequantizeV2 chosenName input inputMin inputMax signedInput numBits rangeGiven t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "signed_input" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if signedInput then 1 else 0) . toCArg]
        CString.with "num_bits" nameCStr:
                callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt numBits . toCArg]
        CString.with "range_given" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if rangeGiven then 1 else 0) . toCArg]
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "QuantizeAndDequantizeV2" [input.wrapper, inputMin.wrapper, inputMax.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get input.typetag

    def batchToSpaceND chosenName input blockShape crops t tblockShape tcrops:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "Tblock_shape" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tblockShape.num . toCArg]
        CString.with "Tcrops" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tcrops.num . toCArg]
        wrappers = makeOutputWrappers "BatchToSpaceND" [input.wrapper, blockShape.wrapper, crops.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get input.typetag

    def extractImagePatches chosenName images ksizes strides rates t padding:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "ksizes" nameCStr:
            cvalues = ksizes.map CInt64.fromInt
            Array CInt64 . with cvalues cvaluesArray:
                callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt ksizes.length . toCArg]
        CString.with "strides" nameCStr:
            cvalues = strides.map CInt64.fromInt
            Array CInt64 . with cvalues cvaluesArray:
                callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
        CString.with "rates" nameCStr:
            cvalues = rates.map CInt64.fromInt
            Array CInt64 . with cvalues cvaluesArray:
                callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt rates.length . toCArg]
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "padding" nameCStr:
            CString.with padding valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        wrappers = makeOutputWrappers "ExtractImagePatches" [images.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get images.typetag

    def bitcast chosenName input t type:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "type" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt type.num . toCArg]
        wrappers = makeOutputWrappers "Bitcast" [input.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get type

    def accumulatorNumAccumulated chosenName handle:
        wrappers = makeOutputWrappers "AccumulatorNumAccumulated" [handle.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get Int32Type

    def oneHot chosenName indices depth onValue offValue axis t tI:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "axis" nameCStr:
                callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt axis . toCArg]
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "TI" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tI.num . toCArg]
        wrappers = makeOutputWrappers "OneHot" [indices.wrapper, depth.wrapper, onValue.wrapper, offValue.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get onValue.typetag

    def where chosenName input t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "Where" [input.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get Int64Type

    def quantizeAndDequantize chosenName input signedInput numBits rangeGiven inputMin inputMax t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "signed_input" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if signedInput then 1 else 0) . toCArg]
        CString.with "num_bits" nameCStr:
                callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt numBits . toCArg]
        CString.with "range_given" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if rangeGiven then 1 else 0) . toCArg]
        CString.with "input_min" nameCStr:
            callHandlingError "add_attr_float" None [attrList.toCArg, nameCStr.toCArg, CFloat.fromReal inputMin . toCArg]
        CString.with "input_max" nameCStr:
            callHandlingError "add_attr_float" None [attrList.toCArg, nameCStr.toCArg, CFloat.fromReal inputMax . toCArg]
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "QuantizeAndDequantize" [input.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get input.typetag

    def quantizeAndDequantizeV3 chosenName input inputMin inputMax numBits signedInput rangeGiven t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "signed_input" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if signedInput then 1 else 0) . toCArg]
        CString.with "range_given" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if rangeGiven then 1 else 0) . toCArg]
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "QuantizeAndDequantizeV3" [input.wrapper, inputMin.wrapper, inputMax.wrapper, numBits.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get input.typetag

    def sparseApplyProximalAdagrad chosenName var accum lr l1 l2 grad indices t tindices useLocking:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "Tindices" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
        CString.with "use_locking" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useLocking then 1 else 0) . toCArg]
        wrappers = makeOutputWrappers "SparseApplyProximalAdagrad" [var.wrapper, accum.wrapper, lr.wrapper, l1.wrapper, l2.wrapper, grad.wrapper, indices.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get var.typetag

    def quantizedReshape chosenName tensor shape inputMin inputMax t tshape:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "Tshape" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tshape.num . toCArg]
        wrappers = makeOutputWrappers "QuantizedReshape" [tensor.wrapper, shape.wrapper, inputMin.wrapper, inputMax.wrapper] 3 attrList chosenName
            (TFOutput (wrappers.getAt 0) tensor.typetag, TFOutput (wrappers.getAt 1) FloatType, TFOutput (wrappers.getAt 2) FloatType)

    def diagPart chosenName input t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "DiagPart" [input.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get input.typetag

    def fakeQuantWithMinMaxVarsPerChannelGradient chosenName gradients inputs min max numBits narrowRange:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "num_bits" nameCStr:
                callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt numBits . toCArg]
        CString.with "narrow_range" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if narrowRange then 1 else 0) . toCArg]
        wrappers = makeOutputWrappers "FakeQuantWithMinMaxVarsPerChannelGradient" [gradients.wrapper, inputs.wrapper, min.wrapper, max.wrapper] 3 attrList chosenName
            (TFOutput (wrappers.getAt 0) FloatType, TFOutput (wrappers.getAt 1) FloatType, TFOutput (wrappers.getAt 2) FloatType)

    def batchMatrixSetDiag chosenName input diagonal t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "BatchMatrixSetDiag" [input.wrapper, diagonal.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get input.typetag

    def batchMatrixBandPart chosenName input numLower numUpper t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "BatchMatrixBandPart" [input.wrapper, numLower.wrapper, numUpper.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get input.typetag

    def batchMatrixDeterminant chosenName input t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "BatchMatrixDeterminant" [input.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get input.typetag

    def enter chosenName data t frameName isConstant parallelIterations:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "frame_name" nameCStr:
            CString.with frameName valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        CString.with "is_constant" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if isConstant then 1 else 0) . toCArg]
        CString.with "parallel_iterations" nameCStr:
                callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt parallelIterations . toCArg]
        wrappers = makeOutputWrappers "Enter" [data.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get data.typetag

    def neg chosenName x t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "Neg" [x.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get x.typetag

    def reciprocalGrad chosenName y dy t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "ReciprocalGrad" [y.wrapper, dy.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get y.typetag

    def square chosenName x t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "Square" [x.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get x.typetag

    def conv3DBackpropFilter chosenName input filter outBackprop t strides padding dilations:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "strides" nameCStr:
            cvalues = strides.map CInt64.fromInt
            Array CInt64 . with cvalues cvaluesArray:
                callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt strides.length . toCArg]
        CString.with "padding" nameCStr:
            CString.with padding valCStr:
                callHandlingError "add_attr_string" None [attrList.toCArg, nameCStr.toCArg, valCStr.toCArg]
        CString.with "dilations" nameCStr:
            cvalues = dilations.map CInt64.fromInt
            Array CInt64 . with cvalues cvaluesArray:
                callHandlingError "add_attr_int_list" None [attrList.toCArg, nameCStr.toCArg, cvaluesArray.toCArg, CUInt32.fromInt dilations.length . toCArg]
        wrappers = makeOutputWrappers "Conv3DBackpropFilter" [input.wrapper, filter.wrapper, outBackprop.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get input.typetag

    def sqrt chosenName x t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "Sqrt" [x.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get x.typetag

    def exp chosenName x t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "Exp" [x.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get x.typetag

    def log chosenName x t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "Log" [x.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get x.typetag

    def sparseSegmentMeanWithNumSegments chosenName data indices segmentIds numSegments t tidx tnumsegments:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "Tidx" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tidx.num . toCArg]
        CString.with "Tnumsegments" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tnumsegments.num . toCArg]
        wrappers = makeOutputWrappers "SparseSegmentMeanWithNumSegments" [data.wrapper, indices.wrapper, segmentIds.wrapper, numSegments.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get data.typetag

    def cosh chosenName x t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "Cosh" [x.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get x.typetag

    def segmentMax chosenName data segmentIds t tindices:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "Tindices" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
        wrappers = makeOutputWrappers "SegmentMax" [data.wrapper, segmentIds.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get data.typetag

    def tanh chosenName x t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "Tanh" [x.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get x.typetag

    def hSVToRGB chosenName images t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "HSVToRGB" [images.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get images.typetag

    def sigmoidGrad chosenName y dy t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "SigmoidGrad" [y.wrapper, dy.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get y.typetag

    def sin chosenName x t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "Sin" [x.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get x.typetag

    def acos chosenName x t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "Acos" [x.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get x.typetag

    def scatterDiv chosenName ref indices updates t tindices useLocking:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "Tindices" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tindices.num . toCArg]
        CString.with "use_locking" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if useLocking then 1 else 0) . toCArg]
        wrappers = makeOutputWrappers "ScatterDiv" [ref.wrapper, indices.wrapper, updates.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get ref.typetag

    def encodeWav chosenName audio sampleRate:
        wrappers = makeOutputWrappers "EncodeWav" [audio.wrapper, sampleRate.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get StringType

    def atan chosenName x t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "Atan" [x.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get x.typetag

    def besselI0e chosenName x t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "BesselI0e" [x.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get x.typetag

    def min chosenName input reductionIndices keepDims t tidx:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "keep_dims" nameCStr:
            callHandlingError "add_attr_bool" None [attrList.toCArg, nameCStr.toCArg, CUChar.fromInt (if keepDims then 1 else 0) . toCArg]
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "Tidx" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tidx.num . toCArg]
        wrappers = makeOutputWrappers "Min" [input.wrapper, reductionIndices.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get input.typetag

    def transpose chosenName x perm t tperm:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "Tperm" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tperm.num . toCArg]
        wrappers = makeOutputWrappers "Transpose" [x.wrapper, perm.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get x.typetag

    def besselI1e chosenName x t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "BesselI1e" [x.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get x.typetag

    def sign chosenName x t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "Sign" [x.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get x.typetag

    def ceil chosenName x t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "Ceil" [x.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get x.typetag

    def rint chosenName x t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "Rint" [x.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get x.typetag

    def addV2 chosenName x y t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "AddV2" [x.wrapper, y.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get x.typetag

    def encodePng chosenName image compression t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "compression" nameCStr:
                callHandlingError "add_attr_int" None [attrList.toCArg, nameCStr.toCArg, CInt64.fromInt compression . toCArg]
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "EncodePng" [image.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get StringType

    def tensorArrayPack chosenName handle flowIn dtype elementShape:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "dtype" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt dtype.num . toCArg]
        CString.with "element_shape" nameCStr:
            cdims = elementShape.map CInt64.fromInt
            Array CInt64 . with cdims cdimsArray:
                callHandlingError "add_attr_shape" None [attrList.toCArg, nameCStr.toCArg, cdimsArray.toCArg, CUInt32.fromInt elementShape.length . toCArg]
        wrappers = makeOutputWrappers "TensorArrayPack" [handle.wrapper, flowIn.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get dtype

    def maximum chosenName x y t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "Maximum" [x.wrapper, y.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get x.typetag

    def truncateMod chosenName x y t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "TruncateMod" [x.wrapper, y.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get x.typetag

    def sparseSegmentSqrtNWithNumSegments chosenName data indices segmentIds numSegments t tidx tnumsegments:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        CString.with "Tidx" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tidx.num . toCArg]
        CString.with "Tnumsegments" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt tnumsegments.num . toCArg]
        wrappers = makeOutputWrappers "SparseSegmentSqrtNWithNumSegments" [data.wrapper, indices.wrapper, segmentIds.wrapper, numSegments.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get data.typetag

    def igammac chosenName a x t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "Igammac" [a.wrapper, x.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get a.typetag

    def igamma chosenName a x t:
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "T" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt t.num . toCArg]
        wrappers = makeOutputWrappers "Igamma" [a.wrapper, x.wrapper] 1 attrList chosenName
        TFOutput wrappers.head.get a.typetag
