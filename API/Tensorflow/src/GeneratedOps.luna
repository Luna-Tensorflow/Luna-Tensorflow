import Tensorflow.CWrappers.Operations
import Tensorflow.Types
import Tensorflow.Operations

def partitionedcall in0:
    wrappers = makeOutputWrappers "PartitionedCall" [in0] 1 ""
    TFOutput wrappers.head.get

def for in0 in1 in2 in3:
    wrappers = makeOutputWrappers "For" [in0, in1, in2, in3] 1 ""
    TFOutput wrappers.head.get

def statelesswhile in0:
    wrappers = makeOutputWrappers "StatelessWhile" [in0] 1 ""
    TFOutput wrappers.head.get

def statelessif in0 in1:
    wrappers = makeOutputWrappers "StatelessIf" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def symbolicgradient in0:
    wrappers = makeOutputWrappers "SymbolicGradient" [in0] 1 ""
    TFOutput wrappers.head.get

def underscorearraytolist in0:
    wrappers = makeOutputWrappers "_ArrayToList" [in0] 1 ""
    TFOutput wrappers.head.get

def quantizedbatchnormwithglobalnormalization in0 in1 in2 in3 in4 in5 in6 in7 in8 in9 in10 in11 in12 in13 in14:
    wrappers = makeOutputWrappers "QuantizedBatchNormWithGlobalNormalization" [in0, in1, in2, in3, in4, in5, in6, in7, in8, in9, in10, in11, in12, in13, in14] 3 ""
    wrappers.each (wrapper: TFOutput wrapper)

def quantizedrelu6 in0 in1 in2:
    wrappers = makeOutputWrappers "QuantizedRelu6" [in0, in1, in2] 3 ""
    wrappers.each (wrapper: TFOutput wrapper)

def quantizedrelu in0 in1 in2:
    wrappers = makeOutputWrappers "QuantizedRelu" [in0, in1, in2] 3 ""
    wrappers.each (wrapper: TFOutput wrapper)

def quantizedconv2d in0 in1 in2 in3 in4 in5:
    wrappers = makeOutputWrappers "QuantizedConv2D" [in0, in1, in2, in3, in4, in5] 3 ""
    wrappers.each (wrapper: TFOutput wrapper)

def quantizedbiasadd in0 in1 in2 in3 in4 in5:
    wrappers = makeOutputWrappers "QuantizedBiasAdd" [in0, in1, in2, in3, in4, in5] 3 ""
    wrappers.each (wrapper: TFOutput wrapper)

def quantizedavgpool in0 in1 in2:
    wrappers = makeOutputWrappers "QuantizedAvgPool" [in0, in1, in2] 3 ""
    wrappers.each (wrapper: TFOutput wrapper)

def fractionalavgpoolgrad in0 in1 in2 in3:
    wrappers = makeOutputWrappers "FractionalAvgPoolGrad" [in0, in1, in2, in3] 1 ""
    TFOutput wrappers.head.get

def fractionalavgpool in0:
    wrappers = makeOutputWrappers "FractionalAvgPool" [in0] 3 ""
    wrappers.each (wrapper: TFOutput wrapper)

def fractionalmaxpoolgrad in0 in1 in2 in3 in4:
    wrappers = makeOutputWrappers "FractionalMaxPoolGrad" [in0, in1, in2, in3, in4] 1 ""
    TFOutput wrappers.head.get

def topkv2 in0 in1:
    wrappers = makeOutputWrappers "TopKV2" [in0, in1] 2 ""
    wrappers.each (wrapper: TFOutput wrapper)

def intopkv2 in0 in1 in2:
    wrappers = makeOutputWrappers "InTopKV2" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def intopk in0 in1:
    wrappers = makeOutputWrappers "InTopK" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def sparsesoftmaxcrossentropywithlogits in0 in1:
    wrappers = makeOutputWrappers "SparseSoftmaxCrossEntropyWithLogits" [in0, in1] 2 ""
    wrappers.each (wrapper: TFOutput wrapper)

def softmaxcrossentropywithlogits in0 in1:
    wrappers = makeOutputWrappers "SoftmaxCrossEntropyWithLogits" [in0, in1] 2 ""
    wrappers.each (wrapper: TFOutput wrapper)

def softmax in0:
    wrappers = makeOutputWrappers "Softmax" [in0] 1 ""
    TFOutput wrappers.head.get

def softsigngrad in0 in1:
    wrappers = makeOutputWrappers "SoftsignGrad" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def softsign in0:
    wrappers = makeOutputWrappers "Softsign" [in0] 1 ""
    TFOutput wrappers.head.get

def elu in0:
    wrappers = makeOutputWrappers "Elu" [in0] 1 ""
    TFOutput wrappers.head.get

def relu6grad in0 in1:
    wrappers = makeOutputWrappers "Relu6Grad" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def relu6 in0:
    wrappers = makeOutputWrappers "Relu6" [in0] 1 ""
    TFOutput wrappers.head.get

def relugrad in0 in1:
    wrappers = makeOutputWrappers "ReluGrad" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def dilation2dbackpropinput in0 in1 in2:
    wrappers = makeOutputWrappers "Dilation2DBackpropInput" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def maxpoolgradgradwithargmax in0 in1 in2:
    wrappers = makeOutputWrappers "MaxPoolGradGradWithArgmax" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def maxpoolgradwithargmax in0 in1 in2:
    wrappers = makeOutputWrappers "MaxPoolGradWithArgmax" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def maxpoolgradgradv2 in0 in1 in2 in3 in4:
    wrappers = makeOutputWrappers "MaxPoolGradGradV2" [in0, in1, in2, in3, in4] 1 ""
    TFOutput wrappers.head.get

def maxpoolgrad in0 in1 in2:
    wrappers = makeOutputWrappers "MaxPoolGrad" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def maxpool in0:
    wrappers = makeOutputWrappers "MaxPool" [in0] 1 ""
    TFOutput wrappers.head.get

def lrn in0:
    wrappers = makeOutputWrappers "LRN" [in0] 1 ""
    TFOutput wrappers.head.get

def maxpool3dgrad in0 in1 in2:
    wrappers = makeOutputWrappers "MaxPool3DGrad" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def maxpool3dgradgrad in0 in1 in2:
    wrappers = makeOutputWrappers "MaxPool3DGradGrad" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def conv3dbackpropfilterv2 in0 in1 in2:
    wrappers = makeOutputWrappers "Conv3DBackpropFilterV2" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def conv3d in0 in1:
    wrappers = makeOutputWrappers "Conv3D" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def depthwiseconv2dnativebackpropfilter in0 in1 in2:
    wrappers = makeOutputWrappers "DepthwiseConv2dNativeBackpropFilter" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def depthwiseconv2dnativebackpropinput in0 in1 in2:
    wrappers = makeOutputWrappers "DepthwiseConv2dNativeBackpropInput" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def depthwiseconv2dnative in0 in1:
    wrappers = makeOutputWrappers "DepthwiseConv2dNative" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def fusedresizeandpadconv2d in0 in1 in2 in3:
    wrappers = makeOutputWrappers "FusedResizeAndPadConv2D" [in0, in1, in2, in3] 1 ""
    TFOutput wrappers.head.get

def dataformatvecpermute in0:
    wrappers = makeOutputWrappers "DataFormatVecPermute" [in0] 1 ""
    TFOutput wrappers.head.get

def conv2dbackpropfilter in0 in1 in2:
    wrappers = makeOutputWrappers "Conv2DBackpropFilter" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def biasadd in0 in1:
    wrappers = makeOutputWrappers "BiasAdd" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def fusedbatchnorm in0 in1 in2 in3 in4:
    wrappers = makeOutputWrappers "FusedBatchNorm" [in0, in1, in2, in3, in4] 5 ""
    wrappers.each (wrapper: TFOutput wrapper)

def avgpoolgrad in0 in1:
    wrappers = makeOutputWrappers "AvgPoolGrad" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def clipbyvalue in0 in1 in2:
    wrappers = makeOutputWrappers "ClipByValue" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def requantizationrange in0 in1 in2:
    wrappers = makeOutputWrappers "RequantizationRange" [in0, in1, in2] 2 ""
    wrappers.each (wrapper: TFOutput wrapper)

def requantize in0 in1 in2 in3 in4:
    wrappers = makeOutputWrappers "Requantize" [in0, in1, in2, in3, in4] 3 ""
    wrappers.each (wrapper: TFOutput wrapper)

def quantizedadd in0 in1 in2 in3 in4 in5:
    wrappers = makeOutputWrappers "QuantizedAdd" [in0, in1, in2, in3, in4, in5] 3 ""
    wrappers.each (wrapper: TFOutput wrapper)

def quantizedmul in0 in1 in2 in3 in4 in5:
    wrappers = makeOutputWrappers "QuantizedMul" [in0, in1, in2, in3, in4, in5] 3 ""
    wrappers.each (wrapper: TFOutput wrapper)

def quantizedmatmul in0 in1 in2 in3 in4 in5:
    wrappers = makeOutputWrappers "QuantizedMatMul" [in0, in1, in2, in3, in4, in5] 3 ""
    wrappers.each (wrapper: TFOutput wrapper)

def cumprod in0 in1:
    wrappers = makeOutputWrappers "Cumprod" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def cumsum in0 in1:
    wrappers = makeOutputWrappers "Cumsum" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def bincount in0 in1 in2:
    wrappers = makeOutputWrappers "Bincount" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def histogramfixedwidth in0 in1 in2:
    wrappers = makeOutputWrappers "HistogramFixedWidth" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def imag in0:
    wrappers = makeOutputWrappers "Imag" [in0] 1 ""
    TFOutput wrappers.head.get

def complex in0 in1:
    wrappers = makeOutputWrappers "Complex" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def range in0 in1 in2:
    wrappers = makeOutputWrappers "Range" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def lrngrad in0 in1 in2:
    wrappers = makeOutputWrappers "LRNGrad" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def any in0 in1:
    wrappers = makeOutputWrappers "Any" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def sparsesegmentsqrtngrad in0 in1 in2 in3:
    wrappers = makeOutputWrappers "SparseSegmentSqrtNGrad" [in0, in1, in2, in3] 1 ""
    TFOutput wrappers.head.get

def sparsesegmentsqrtn in0 in1 in2:
    wrappers = makeOutputWrappers "SparseSegmentSqrtN" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def sparsesegmentmean in0 in1 in2:
    wrappers = makeOutputWrappers "SparseSegmentMean" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def sparsesegmentsumwithnumsegments in0 in1 in2 in3:
    wrappers = makeOutputWrappers "SparseSegmentSumWithNumSegments" [in0, in1, in2, in3] 1 ""
    TFOutput wrappers.head.get

def sparsesegmentsum in0 in1 in2:
    wrappers = makeOutputWrappers "SparseSegmentSum" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def unsortedsegmentprod in0 in1 in2:
    wrappers = makeOutputWrappers "UnsortedSegmentProd" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def unsortedsegmentmin in0 in1 in2:
    wrappers = makeOutputWrappers "UnsortedSegmentMin" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def nthelement in0 in1:
    wrappers = makeOutputWrappers "NthElement" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def unsortedsegmentmax in0 in1 in2:
    wrappers = makeOutputWrappers "UnsortedSegmentMax" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def unsortedsegmentsum in0 in1 in2:
    wrappers = makeOutputWrappers "UnsortedSegmentSum" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def segmentmin in0 in1:
    wrappers = makeOutputWrappers "SegmentMin" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def segmentmean in0 in1:
    wrappers = makeOutputWrappers "SegmentMean" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def argmin in0 in1:
    wrappers = makeOutputWrappers "ArgMin" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def max in0 in1:
    wrappers = makeOutputWrappers "Max" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def sum in0 in1:
    wrappers = makeOutputWrappers "Sum" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def sparsematmul in0 in1:
    wrappers = makeOutputWrappers "SparseMatMul" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def matmul in0 in1:
    wrappers = makeOutputWrappers "MatMul" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def select in0 in1 in2:
    wrappers = makeOutputWrappers "Select" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def logicalor in0 in1:
    wrappers = makeOutputWrappers "LogicalOr" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def logicaland in0 in1:
    wrappers = makeOutputWrappers "LogicalAnd" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def approximateequal in0 in1:
    wrappers = makeOutputWrappers "ApproximateEqual" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def notequal in0 in1:
    wrappers = makeOutputWrappers "NotEqual" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def greaterequal in0 in1:
    wrappers = makeOutputWrappers "GreaterEqual" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def greater in0 in1:
    wrappers = makeOutputWrappers "Greater" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def lessequal in0 in1:
    wrappers = makeOutputWrappers "LessEqual" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def quantizedrelux in0 in1 in2 in3:
    wrappers = makeOutputWrappers "QuantizedReluX" [in0, in1, in2, in3] 3 ""
    wrappers.each (wrapper: TFOutput wrapper)

def less in0 in1:
    wrappers = makeOutputWrappers "Less" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def betainc in0 in1 in2:
    wrappers = makeOutputWrappers "Betainc" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def polygamma in0 in1:
    wrappers = makeOutputWrappers "Polygamma" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def zeta in0 in1:
    wrappers = makeOutputWrappers "Zeta" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def mean in0 in1:
    wrappers = makeOutputWrappers "Mean" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def initializetablefromtextfile in0 in1:
    wrappers = makeOutputWrappers "InitializeTableFromTextFile" [in0, in1] 0 ""
    wrappers.each (wrapper: TFOutput wrapper)

def fakequantwithminmaxvarsgradient in0 in1 in2 in3:
    wrappers = makeOutputWrappers "FakeQuantWithMinMaxVarsGradient" [in0, in1, in2, in3] 3 ""
    wrappers.each (wrapper: TFOutput wrapper)

def minimum in0 in1:
    wrappers = makeOutputWrappers "Minimum" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def dynamicpartition in0 in1:
    wrappers = makeOutputWrappers "DynamicPartition" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def batchcholesky in0:
    wrappers = makeOutputWrappers "BatchCholesky" [in0] 1 ""
    TFOutput wrappers.head.get

def resizebilineargrad in0 in1:
    wrappers = makeOutputWrappers "ResizeBilinearGrad" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def lookuptablesize in0:
    wrappers = makeOutputWrappers "LookupTableSize" [in0] 1 ""
    TFOutput wrappers.head.get

def paddedbatchdatasetv2 in0 in1 in2 in3 in4:
    wrappers = makeOutputWrappers "PaddedBatchDatasetV2" [in0, in1, in2, in3, in4] 1 ""
    TFOutput wrappers.head.get

def bucketize in0:
    wrappers = makeOutputWrappers "Bucketize" [in0] 1 ""
    TFOutput wrappers.head.get

def lookuptableinsert in0 in1 in2:
    wrappers = makeOutputWrappers "LookupTableInsert" [in0, in1, in2] 0 ""
    wrappers.each (wrapper: TFOutput wrapper)

def tensorlistgather in0 in1:
    wrappers = makeOutputWrappers "TensorListGather" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def tpureplicatemetadata:
    wrappers = makeOutputWrappers "TPUReplicateMetadata" [] 0 ""
    wrappers.each (wrapper: TFOutput wrapper)

def batchmatrixtriangularsolve in0 in1:
    wrappers = makeOutputWrappers "BatchMatrixTriangularSolve" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def batchselfadjointeig in0:
    wrappers = makeOutputWrappers "BatchSelfAdjointEig" [in0] 1 ""
    TFOutput wrappers.head.get

def choleskygrad in0 in1:
    wrappers = makeOutputWrappers "CholeskyGrad" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def underscorelisttoarray in0:
    wrappers = makeOutputWrappers "_ListToArray" [in0] 1 ""
    TFOutput wrappers.head.get

def fusedbatchnormgrad in0 in1 in2 in3 in4:
    wrappers = makeOutputWrappers "FusedBatchNormGrad" [in0, in1, in2, in3, in4] 5 ""
    wrappers.each (wrapper: TFOutput wrapper)

def cos in0:
    wrappers = makeOutputWrappers "Cos" [in0] 1 ""
    TFOutput wrappers.head.get

def cholesky in0:
    wrappers = makeOutputWrappers "Cholesky" [in0] 1 ""
    TFOutput wrappers.head.get

def sparseapplyftrlv2 in0 in1 in2 in3 in4 in5 in6 in7 in8 in9:
    wrappers = makeOutputWrappers "SparseApplyFtrlV2" [in0, in1, in2, in3, in4, in5, in6, in7, in8, in9] 1 ""
    TFOutput wrappers.head.get

def tensorlistscatter in0 in1 in2:
    wrappers = makeOutputWrappers "TensorListScatter" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def maxpoolgradv2 in0 in1 in2 in3 in4:
    wrappers = makeOutputWrappers "MaxPoolGradV2" [in0, in1, in2, in3, in4] 1 ""
    TFOutput wrappers.head.get

def readernumrecordsproduced in0:
    wrappers = makeOutputWrappers "ReaderNumRecordsProduced" [in0] 1 ""
    TFOutput wrappers.head.get

def matrixinverse in0:
    wrappers = makeOutputWrappers "MatrixInverse" [in0] 1 ""
    TFOutput wrappers.head.get

def statelesstruncatednormal in0 in1:
    wrappers = makeOutputWrappers "StatelessTruncatedNormal" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def noop:
    wrappers = makeOutputWrappers "NoOp" [] 0 ""
    wrappers.each (wrapper: TFOutput wrapper)

def nonmaxsuppressionv4 in0 in1 in2 in3 in4:
    wrappers = makeOutputWrappers "NonMaxSuppressionV4" [in0, in1, in2, in3, in4] 2 ""
    wrappers.each (wrapper: TFOutput wrapper)

def nonmaxsuppression in0 in1 in2:
    wrappers = makeOutputWrappers "NonMaxSuppression" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def nonmaxsuppressionwithoverlaps in0 in1 in2 in3 in4:
    wrappers = makeOutputWrappers "NonMaxSuppressionWithOverlaps" [in0, in1, in2, in3, in4] 1 ""
    TFOutput wrappers.head.get

def computeaccidentalhits in0 in1:
    wrappers = makeOutputWrappers "ComputeAccidentalHits" [in0, in1] 3 ""
    wrappers.each (wrapper: TFOutput wrapper)

def fft3d in0:
    wrappers = makeOutputWrappers "FFT3D" [in0] 1 ""
    TFOutput wrappers.head.get

def cropandresizegradboxes in0 in1 in2 in3:
    wrappers = makeOutputWrappers "CropAndResizeGradBoxes" [in0, in1, in2, in3] 1 ""
    TFOutput wrappers.head.get

def extractglimpse in0 in1 in2:
    wrappers = makeOutputWrappers "ExtractGlimpse" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def optimizedataset in0 in1:
    wrappers = makeOutputWrappers "OptimizeDataset" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def sparseslicegrad in0 in1 in2 in3:
    wrappers = makeOutputWrappers "SparseSliceGrad" [in0, in1, in2, in3] 1 ""
    TFOutput wrappers.head.get

def batchsvd in0:
    wrappers = makeOutputWrappers "BatchSvd" [in0] 3 ""
    wrappers.each (wrapper: TFOutput wrapper)

def rgbtohsv in0:
    wrappers = makeOutputWrappers "RGBToHSV" [in0] 1 ""
    TFOutput wrappers.head.get

def decodegif in0:
    wrappers = makeOutputWrappers "DecodeGif" [in0] 1 ""
    TFOutput wrappers.head.get

def decodepng in0:
    wrappers = makeOutputWrappers "DecodePng" [in0] 1 ""
    TFOutput wrappers.head.get

def adjustsaturation in0 in1:
    wrappers = makeOutputWrappers "AdjustSaturation" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def matrixsolve in0 in1:
    wrappers = makeOutputWrappers "MatrixSolve" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def datasettograph in0:
    wrappers = makeOutputWrappers "DatasetToGraph" [in0] 1 ""
    TFOutput wrappers.head.get

def softplusgrad in0 in1:
    wrappers = makeOutputWrappers "SoftplusGrad" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def selfadjointeigv2 in0:
    wrappers = makeOutputWrappers "SelfAdjointEigV2" [in0] 2 ""
    wrappers.each (wrapper: TFOutput wrapper)

def decodejpeg in0:
    wrappers = makeOutputWrappers "DecodeJpeg" [in0] 1 ""
    TFOutput wrappers.head.get

def fakeparam:
    wrappers = makeOutputWrappers "FakeParam" [] 1 ""
    TFOutput wrappers.head.get

def matrixlogarithm in0:
    wrappers = makeOutputWrappers "MatrixLogarithm" [in0] 1 ""
    TFOutput wrappers.head.get

def resizenearestneighbor in0 in1:
    wrappers = makeOutputWrappers "ResizeNearestNeighbor" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def resizebicubicgrad in0 in1:
    wrappers = makeOutputWrappers "ResizeBicubicGrad" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def resizebicubic in0 in1:
    wrappers = makeOutputWrappers "ResizeBicubic" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def log1p in0:
    wrappers = makeOutputWrappers "Log1p" [in0] 1 ""
    TFOutput wrappers.head.get

def encodeproto in0 in1:
    wrappers = makeOutputWrappers "EncodeProto" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def tpucompilationresult:
    wrappers = makeOutputWrappers "TPUCompilationResult" [] 1 ""
    TFOutput wrappers.head.get

def optionalfromvalue in0:
    wrappers = makeOutputWrappers "OptionalFromValue" [in0] 1 ""
    TFOutput wrappers.head.get

def nonmaxsuppressionv2 in0 in1 in2 in3:
    wrappers = makeOutputWrappers "NonMaxSuppressionV2" [in0, in1, in2, in3] 1 ""
    TFOutput wrappers.head.get

def reshape in0 in1:
    wrappers = makeOutputWrappers "Reshape" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def avgpool3d in0:
    wrappers = makeOutputWrappers "AvgPool3D" [in0] 1 ""
    TFOutput wrappers.head.get

def sinkdataset in0:
    wrappers = makeOutputWrappers "SinkDataset" [in0] 1 ""
    TFOutput wrappers.head.get

def cross in0 in1:
    wrappers = makeOutputWrappers "Cross" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def prependfromqueueandpaddedbatchdataset in0 in1 in2 in3:
    wrappers = makeOutputWrappers "PrependFromQueueAndPaddedBatchDataset" [in0, in1, in2, in3] 1 ""
    TFOutput wrappers.head.get

def tensorarrayunpack in0 in1 in2:
    wrappers = makeOutputWrappers "TensorArrayUnpack" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def sinh in0:
    wrappers = makeOutputWrappers "Sinh" [in0] 1 ""
    TFOutput wrappers.head.get

def dilation2d in0 in1:
    wrappers = makeOutputWrappers "Dilation2D" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def filterdataset in0 in1:
    wrappers = makeOutputWrappers "FilterDataset" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def tensorarrayconcatv2 in0 in1:
    wrappers = makeOutputWrappers "TensorArrayConcatV2" [in0, in1] 2 ""
    wrappers.each (wrapper: TFOutput wrapper)

def atan2 in0 in1:
    wrappers = makeOutputWrappers "Atan2" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def identity in0:
    wrappers = makeOutputWrappers "Identity" [in0] 1 ""
    TFOutput wrappers.head.get

def adjustcontrastv2 in0 in1:
    wrappers = makeOutputWrappers "AdjustContrastv2" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def boostedtreesmakestatssummary in0 in1 in2 in3:
    wrappers = makeOutputWrappers "BoostedTreesMakeStatsSummary" [in0, in1, in2, in3] 1 ""
    TFOutput wrappers.head.get

def nonmaxsuppressionv3 in0 in1 in2 in3 in4:
    wrappers = makeOutputWrappers "NonMaxSuppressionV3" [in0, in1, in2, in3, in4] 1 ""
    TFOutput wrappers.head.get

def batchnormwithglobalnormalizationgrad in0 in1 in2 in3 in4:
    wrappers = makeOutputWrappers "BatchNormWithGlobalNormalizationGrad" [in0, in1, in2, in3, in4] 5 ""
    wrappers.each (wrapper: TFOutput wrapper)

def optionalgetvalue in0:
    wrappers = makeOutputWrappers "OptionalGetValue" [in0] 1 ""
    TFOutput wrappers.head.get

def shuffleandrepeatdataset in0 in1 in2 in3 in4:
    wrappers = makeOutputWrappers "ShuffleAndRepeatDataset" [in0, in1, in2, in3, in4] 1 ""
    TFOutput wrappers.head.get

def shuffledataset in0 in1 in2 in3:
    wrappers = makeOutputWrappers "ShuffleDataset" [in0, in1, in2, in3] 1 ""
    TFOutput wrappers.head.get

def logmatrixdeterminant in0:
    wrappers = makeOutputWrappers "LogMatrixDeterminant" [in0] 2 ""
    wrappers.each (wrapper: TFOutput wrapper)

def selu in0:
    wrappers = makeOutputWrappers "Selu" [in0] 1 ""
    TFOutput wrappers.head.get

def setsize in0 in1 in2:
    wrappers = makeOutputWrappers "SetSize" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def substr in0 in1 in2:
    wrappers = makeOutputWrappers "Substr" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def slidedataset in0 in1 in2 in3:
    wrappers = makeOutputWrappers "SlideDataset" [in0, in1, in2, in3] 1 ""
    TFOutput wrappers.head.get

def debugnumericsummary in0:
    wrappers = makeOutputWrappers "DebugNumericSummary" [in0] 1 ""
    TFOutput wrappers.head.get

def fusedbatchnormv2 in0 in1 in2 in3 in4:
    wrappers = makeOutputWrappers "FusedBatchNormV2" [in0, in1, in2, in3, in4] 5 ""
    wrappers.each (wrapper: TFOutput wrapper)

def debugidentity in0:
    wrappers = makeOutputWrappers "DebugIdentity" [in0] 1 ""
    TFOutput wrappers.head.get

def accumulatortakegradient in0 in1:
    wrappers = makeOutputWrappers "AccumulatorTakeGradient" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def interleavedataset in0 in1 in2 in3:
    wrappers = makeOutputWrappers "InterleaveDataset" [in0, in1, in2, in3] 1 ""
    TFOutput wrappers.head.get

def scandataset in0 in1 in2:
    wrappers = makeOutputWrappers "ScanDataset" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def densetosparsebatchdataset in0 in1 in2:
    wrappers = makeOutputWrappers "DenseToSparseBatchDataset" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def prefetchdataset in0 in1:
    wrappers = makeOutputWrappers "PrefetchDataset" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def tensorsummaryv2 in0 in1 in2:
    wrappers = makeOutputWrappers "TensorSummaryV2" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def parallelmapdataset in0 in1 in2:
    wrappers = makeOutputWrappers "ParallelMapDataset" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def tensorarrayconcat in0 in1:
    wrappers = makeOutputWrappers "TensorArrayConcat" [in0, in1] 2 ""
    wrappers.each (wrapper: TFOutput wrapper)

def parseexampledataset in0 in1 in2:
    wrappers = makeOutputWrappers "ParseExampleDataset" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def reciprocal in0:
    wrappers = makeOutputWrappers "Reciprocal" [in0] 1 ""
    TFOutput wrappers.head.get

def qr in0:
    wrappers = makeOutputWrappers "Qr" [in0] 2 ""
    wrappers.each (wrapper: TFOutput wrapper)

def audiosummary in0 in1:
    wrappers = makeOutputWrappers "AudioSummary" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def real in0:
    wrappers = makeOutputWrappers "Real" [in0] 1 ""
    TFOutput wrappers.head.get

def repeatdataset in0 in1:
    wrappers = makeOutputWrappers "RepeatDataset" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def sparsereducemaxsparse in0 in1 in2 in3:
    wrappers = makeOutputWrappers "SparseReduceMaxSparse" [in0, in1, in2, in3] 3 ""
    wrappers.each (wrapper: TFOutput wrapper)

def barrierincompletesize in0:
    wrappers = makeOutputWrappers "BarrierIncompleteSize" [in0] 1 ""
    TFOutput wrappers.head.get

def segmentsum in0 in1:
    wrappers = makeOutputWrappers "SegmentSum" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def batchfft3d in0:
    wrappers = makeOutputWrappers "BatchFFT3D" [in0] 1 ""
    TFOutput wrappers.head.get

def zipdataset in0:
    wrappers = makeOutputWrappers "ZipDataset" [in0] 1 ""
    TFOutput wrappers.head.get

def tensorlistgetitem in0 in1:
    wrappers = makeOutputWrappers "TensorListGetItem" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def round in0:
    wrappers = makeOutputWrappers "Round" [in0] 1 ""
    TFOutput wrappers.head.get

def matrixsetdiag in0 in1:
    wrappers = makeOutputWrappers "MatrixSetDiag" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def sparsesparsemaximum in0 in1 in2 in3 in4 in5:
    wrappers = makeOutputWrappers "SparseSparseMaximum" [in0, in1, in2, in3, in4, in5] 2 ""
    wrappers.each (wrapper: TFOutput wrapper)

def queuedequeueupto in0 in1:
    wrappers = makeOutputWrappers "QueueDequeueUpTo" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def matrixexponential in0:
    wrappers = makeOutputWrappers "MatrixExponential" [in0] 1 ""
    TFOutput wrappers.head.get

def biasaddgrad in0:
    wrappers = makeOutputWrappers "BiasAddGrad" [in0] 1 ""
    TFOutput wrappers.head.get

def queuesize in0:
    wrappers = makeOutputWrappers "QueueSize" [in0] 1 ""
    TFOutput wrappers.head.get

def sparsedensecwiseadd in0 in1 in2 in3:
    wrappers = makeOutputWrappers "SparseDenseCwiseAdd" [in0, in1, in2, in3] 1 ""
    TFOutput wrappers.head.get

def lookuptablefind in0 in1 in2:
    wrappers = makeOutputWrappers "LookupTableFind" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def ensureshape in0:
    wrappers = makeOutputWrappers "EnsureShape" [in0] 1 ""
    TFOutput wrappers.head.get

def stackclose in0:
    wrappers = makeOutputWrappers "StackClose" [in0] 0 ""
    wrappers.each (wrapper: TFOutput wrapper)

def readerserializestate in0:
    wrappers = makeOutputWrappers "ReaderSerializeState" [in0] 1 ""
    TFOutput wrappers.head.get

def tan in0:
    wrappers = makeOutputWrappers "Tan" [in0] 1 ""
    TFOutput wrappers.head.get

def decodebmp in0:
    wrappers = makeOutputWrappers "DecodeBmp" [in0] 1 ""
    TFOutput wrappers.head.get

def rsqrt in0:
    wrappers = makeOutputWrappers "Rsqrt" [in0] 1 ""
    TFOutput wrappers.head.get

def ctcloss in0 in1 in2 in3:
    wrappers = makeOutputWrappers "CTCLoss" [in0, in1, in2, in3] 2 ""
    wrappers.each (wrapper: TFOutput wrapper)

def quantizedresizebilinear in0 in1 in2 in3:
    wrappers = makeOutputWrappers "QuantizedResizeBilinear" [in0, in1, in2, in3] 3 ""
    wrappers.each (wrapper: TFOutput wrapper)

def stackpop in0:
    wrappers = makeOutputWrappers "StackPop" [in0] 1 ""
    TFOutput wrappers.head.get

def svd in0:
    wrappers = makeOutputWrappers "Svd" [in0] 3 ""
    wrappers.each (wrapper: TFOutput wrapper)

def batchselfadjointeigv2 in0:
    wrappers = makeOutputWrappers "BatchSelfAdjointEigV2" [in0] 2 ""
    wrappers.each (wrapper: TFOutput wrapper)

def inv in0:
    wrappers = makeOutputWrappers "Inv" [in0] 1 ""
    TFOutput wrappers.head.get

def populationcount in0:
    wrappers = makeOutputWrappers "PopulationCount" [in0] 1 ""
    TFOutput wrappers.head.get

def decodeandcropjpeg in0 in1:
    wrappers = makeOutputWrappers "DecodeAndCropJpeg" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def underscoremkladd in0 in1 in2 in3:
    wrappers = makeOutputWrappers "_MklAdd" [in0, in1, in2, in3] 2 ""
    wrappers.each (wrapper: TFOutput wrapper)

def bytesproducedstatsdataset in0 in1:
    wrappers = makeOutputWrappers "BytesProducedStatsDataset" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def relu in0:
    wrappers = makeOutputWrappers "Relu" [in0] 1 ""
    TFOutput wrappers.head.get

def loopcond in0:
    wrappers = makeOutputWrappers "LoopCond" [in0] 1 ""
    TFOutput wrappers.head.get

def squareddifference in0 in1:
    wrappers = makeOutputWrappers "SquaredDifference" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def exit in0:
    wrappers = makeOutputWrappers "Exit" [in0] 1 ""
    TFOutput wrappers.head.get

def cropandresize in0 in1 in2 in3:
    wrappers = makeOutputWrappers "CropAndResize" [in0, in1, in2, in3] 1 ""
    TFOutput wrappers.head.get

def refenter in0:
    wrappers = makeOutputWrappers "RefEnter" [in0] 1 ""
    TFOutput wrappers.head.get

def tensorlistfromtensor in0 in1:
    wrappers = makeOutputWrappers "TensorListFromTensor" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def refmerge in0:
    wrappers = makeOutputWrappers "RefMerge" [in0] 2 ""
    wrappers.each (wrapper: TFOutput wrapper)

def remotefusedgraphexecute in0:
    wrappers = makeOutputWrappers "RemoteFusedGraphExecute" [in0] 1 ""
    TFOutput wrappers.head.get

def shardedfilespec in0 in1:
    wrappers = makeOutputWrappers "ShardedFilespec" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def extractjpegshape in0:
    wrappers = makeOutputWrappers "ExtractJpegShape" [in0] 1 ""
    TFOutput wrappers.head.get

def batchmatrixinverse in0:
    wrappers = makeOutputWrappers "BatchMatrixInverse" [in0] 1 ""
    TFOutput wrappers.head.get

def tensorarraysplit in0 in1 in2 in3:
    wrappers = makeOutputWrappers "TensorArraySplit" [in0, in1, in2, in3] 1 ""
    TFOutput wrappers.head.get

def batchifft in0:
    wrappers = makeOutputWrappers "BatchIFFT" [in0] 1 ""
    TFOutput wrappers.head.get

def switch in0 in1:
    wrappers = makeOutputWrappers "Switch" [in0, in1] 2 ""
    wrappers.each (wrapper: TFOutput wrapper)

def shardedfilename in0 in1 in2:
    wrappers = makeOutputWrappers "ShardedFilename" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def densetodensesetoperation in0 in1:
    wrappers = makeOutputWrappers "DenseToDenseSetOperation" [in0, in1] 3 ""
    wrappers.each (wrapper: TFOutput wrapper)

def fusedpadconv2d in0 in1 in2:
    wrappers = makeOutputWrappers "FusedPadConv2D" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def conv2dbackpropinput in0 in1 in2:
    wrappers = makeOutputWrappers "Conv2DBackpropInput" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def dynamicstitch in0 in1:
    wrappers = makeOutputWrappers "DynamicStitch" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def equal in0 in1:
    wrappers = makeOutputWrappers "Equal" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def tensorarraygatherv2 in0 in1 in2:
    wrappers = makeOutputWrappers "TensorArrayGatherV2" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def datasettosingleelement in0:
    wrappers = makeOutputWrappers "DatasetToSingleElement" [in0] 1 ""
    TFOutput wrappers.head.get

def histogramsummary in0 in1:
    wrappers = makeOutputWrappers "HistogramSummary" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def tpuembeddingactivations in0 in1:
    wrappers = makeOutputWrappers "TPUEmbeddingActivations" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def optionalhasvalue in0:
    wrappers = makeOutputWrappers "OptionalHasValue" [in0] 1 ""
    TFOutput wrappers.head.get

def refswitch in0 in1:
    wrappers = makeOutputWrappers "RefSwitch" [in0, in1] 2 ""
    wrappers.each (wrapper: TFOutput wrapper)

def sparsetensordensematmul in0 in1 in2 in3:
    wrappers = makeOutputWrappers "SparseTensorDenseMatMul" [in0, in1, in2, in3] 1 ""
    TFOutput wrappers.head.get

def segmentprod in0 in1:
    wrappers = makeOutputWrappers "SegmentProd" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def tensorarraygather in0 in1 in2:
    wrappers = makeOutputWrappers "TensorArrayGather" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def batchcholeskygrad in0 in1:
    wrappers = makeOutputWrappers "BatchCholeskyGrad" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def generatebigqueryreaderpartitions:
    wrappers = makeOutputWrappers "GenerateBigQueryReaderPartitions" [] 1 ""
    TFOutput wrappers.head.get

def emptytensorlist in0:
    wrappers = makeOutputWrappers "EmptyTensorList" [in0] 1 ""
    TFOutput wrappers.head.get

def scatterndadd in0 in1 in2:
    wrappers = makeOutputWrappers "ScatterNdAdd" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def parsesequenceexample in0 in1 in2:
    wrappers = makeOutputWrappers "ParseSequenceExample" [in0, in1, in2] 9 ""
    wrappers.each (wrapper: TFOutput wrapper)

def assign in0 in1:
    wrappers = makeOutputWrappers "Assign" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def argmax in0 in1:
    wrappers = makeOutputWrappers "ArgMax" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def readerreset in0:
    wrappers = makeOutputWrappers "ReaderReset" [in0] 0 ""
    wrappers.each (wrapper: TFOutput wrapper)

def conj in0:
    wrappers = makeOutputWrappers "Conj" [in0] 1 ""
    TFOutput wrappers.head.get

def batchfunction in0 in1:
    wrappers = makeOutputWrappers "BatchFunction" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def underscoreparallelconcatupdate in0 in1:
    wrappers = makeOutputWrappers "_ParallelConcatUpdate" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def digamma in0:
    wrappers = makeOutputWrappers "Digamma" [in0] 1 ""
    TFOutput wrappers.head.get

def lookuptableexport in0:
    wrappers = makeOutputWrappers "LookupTableExport" [in0] 2 ""
    wrappers.each (wrapper: TFOutput wrapper)

def complexabs in0:
    wrappers = makeOutputWrappers "ComplexAbs" [in0] 1 ""
    TFOutput wrappers.head.get

def debuggradientrefidentity in0:
    wrappers = makeOutputWrappers "DebugGradientRefIdentity" [in0] 1 ""
    TFOutput wrappers.head.get

def batchfft2d in0:
    wrappers = makeOutputWrappers "BatchFFT2D" [in0] 1 ""
    TFOutput wrappers.head.get

def erf in0:
    wrappers = makeOutputWrappers "Erf" [in0] 1 ""
    TFOutput wrappers.head.get

def floor in0:
    wrappers = makeOutputWrappers "Floor" [in0] 1 ""
    TFOutput wrappers.head.get

def resizebilinear in0 in1:
    wrappers = makeOutputWrappers "ResizeBilinear" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def copyhost in0:
    wrappers = makeOutputWrappers "CopyHost" [in0] 1 ""
    TFOutput wrappers.head.get

def concatenatedataset in0 in1:
    wrappers = makeOutputWrappers "ConcatenateDataset" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def tpureplicatedoutput in0:
    wrappers = makeOutputWrappers "TPUReplicatedOutput" [in0] 1 ""
    TFOutput wrappers.head.get

def refselect in0 in1:
    wrappers = makeOutputWrappers "RefSelect" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def gcsconfigureblockcache in0 in1 in2:
    wrappers = makeOutputWrappers "GcsConfigureBlockCache" [in0, in1, in2] 0 ""
    wrappers.each (wrapper: TFOutput wrapper)

def serializemanysparse in0 in1 in2:
    wrappers = makeOutputWrappers "SerializeManySparse" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def acosh in0:
    wrappers = makeOutputWrappers "Acosh" [in0] 1 ""
    TFOutput wrappers.head.get

def batchfft in0:
    wrappers = makeOutputWrappers "BatchFFT" [in0] 1 ""
    TFOutput wrappers.head.get

def isfinite in0:
    wrappers = makeOutputWrappers "IsFinite" [in0] 1 ""
    TFOutput wrappers.head.get

def paddedbatchdataset in0 in1 in2 in3:
    wrappers = makeOutputWrappers "PaddedBatchDataset" [in0, in1, in2, in3] 1 ""
    TFOutput wrappers.head.get

def batchmatrixsolvels in0 in1 in2:
    wrappers = makeOutputWrappers "BatchMatrixSolveLs" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def debuggradientidentity in0:
    wrappers = makeOutputWrappers "DebugGradientIdentity" [in0] 1 ""
    TFOutput wrappers.head.get

def isnan in0:
    wrappers = makeOutputWrappers "IsNan" [in0] 1 ""
    TFOutput wrappers.head.get

def realdiv in0 in1:
    wrappers = makeOutputWrappers "RealDiv" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def lgamma in0:
    wrappers = makeOutputWrappers "Lgamma" [in0] 1 ""
    TFOutput wrappers.head.get

def scatternd in0 in1 in2:
    wrappers = makeOutputWrappers "ScatterNd" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def all in0 in1:
    wrappers = makeOutputWrappers "All" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def selfadjointeig in0:
    wrappers = makeOutputWrappers "SelfAdjointEig" [in0] 1 ""
    TFOutput wrappers.head.get

def conv3dbackpropinput in0 in1 in2:
    wrappers = makeOutputWrappers "Conv3DBackpropInput" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def stackpush in0 in1:
    wrappers = makeOutputWrappers "StackPush" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def maxpool3d in0:
    wrappers = makeOutputWrappers "MaxPool3D" [in0] 1 ""
    TFOutput wrappers.head.get

def applygradientdescent in0 in1 in2:
    wrappers = makeOutputWrappers "ApplyGradientDescent" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def resizearea in0 in1:
    wrappers = makeOutputWrappers "ResizeArea" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def takedataset in0 in1:
    wrappers = makeOutputWrappers "TakeDataset" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def stringtohashbucket in0:
    wrappers = makeOutputWrappers "StringToHashBucket" [in0] 1 ""
    TFOutput wrappers.head.get

def batchdatasetv2 in0 in1 in2:
    wrappers = makeOutputWrappers "BatchDatasetV2" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def applyadagradda in0 in1 in2 in3 in4 in5 in6 in7:
    wrappers = makeOutputWrappers "ApplyAdagradDA" [in0, in1, in2, in3, in4, in5, in6, in7] 1 ""
    TFOutput wrappers.head.get

def igammagrada in0 in1:
    wrappers = makeOutputWrappers "IgammaGradA" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def sparsesegmentmeangrad in0 in1 in2 in3:
    wrappers = makeOutputWrappers "SparseSegmentMeanGrad" [in0, in1, in2, in3] 1 ""
    TFOutput wrappers.head.get

def cudnnrnnparamssize in0 in1 in2:
    wrappers = makeOutputWrappers "CudnnRNNParamsSize" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def tpureplicatedinput in0:
    wrappers = makeOutputWrappers "TPUReplicatedInput" [in0] 1 ""
    TFOutput wrappers.head.get

def queueisclosed in0:
    wrappers = makeOutputWrappers "QueueIsClosed" [in0] 1 ""
    TFOutput wrappers.head.get

def compareandbitpack in0 in1:
    wrappers = makeOutputWrappers "CompareAndBitpack" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def conv3dbackpropinputv2 in0 in1 in2:
    wrappers = makeOutputWrappers "Conv3DBackpropInputV2" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def depthtospace in0:
    wrappers = makeOutputWrappers "DepthToSpace" [in0] 1 ""
    TFOutput wrappers.head.get

def adjusthue in0 in1:
    wrappers = makeOutputWrappers "AdjustHue" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def batch in0:
    wrappers = makeOutputWrappers "Batch" [in0] 3 ""
    wrappers.each (wrapper: TFOutput wrapper)

def tensorarraywrite in0 in1 in2 in3:
    wrappers = makeOutputWrappers "TensorArrayWrite" [in0, in1, in2, in3] 1 ""
    TFOutput wrappers.head.get

def tensorarraywritev2 in0 in1 in2 in3:
    wrappers = makeOutputWrappers "TensorArrayWriteV2" [in0, in1, in2, in3] 1 ""
    TFOutput wrappers.head.get

def matrixtriangularsolve in0 in1:
    wrappers = makeOutputWrappers "MatrixTriangularSolve" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def barrierclose in0:
    wrappers = makeOutputWrappers "BarrierClose" [in0] 0 ""
    wrappers.each (wrapper: TFOutput wrapper)

def truncatediv in0 in1:
    wrappers = makeOutputWrappers "TruncateDiv" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def quantizedmaxpool in0 in1 in2:
    wrappers = makeOutputWrappers "QuantizedMaxPool" [in0, in1, in2] 3 ""
    wrappers.each (wrapper: TFOutput wrapper)

def scatterupdate in0 in1 in2:
    wrappers = makeOutputWrappers "ScatterUpdate" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def ctcgreedydecoder in0 in1:
    wrappers = makeOutputWrappers "CTCGreedyDecoder" [in0, in1] 4 ""
    wrappers.each (wrapper: TFOutput wrapper)

def padv2 in0 in1 in2:
    wrappers = makeOutputWrappers "PadV2" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def mfcc in0 in1:
    wrappers = makeOutputWrappers "Mfcc" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def decodewav in0:
    wrappers = makeOutputWrappers "DecodeWav" [in0] 2 ""
    wrappers.each (wrapper: TFOutput wrapper)

def unique in0:
    wrappers = makeOutputWrappers "Unique" [in0] 2 ""
    wrappers.each (wrapper: TFOutput wrapper)

def datasettotfrecord in0 in1 in2:
    wrappers = makeOutputWrappers "DatasetToTFRecord" [in0, in1, in2] 0 ""
    wrappers.each (wrapper: TFOutput wrapper)

def spacetobatch in0 in1:
    wrappers = makeOutputWrappers "SpaceToBatch" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def unbatch in0 in1 in2:
    wrappers = makeOutputWrappers "Unbatch" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def countupto in0:
    wrappers = makeOutputWrappers "CountUpTo" [in0] 1 ""
    TFOutput wrappers.head.get

def cudnnrnncanonicaltoparams in0 in1 in2 in3 in4:
    wrappers = makeOutputWrappers "CudnnRNNCanonicalToParams" [in0, in1, in2, in3, in4] 1 ""
    TFOutput wrappers.head.get

def filterbylastcomponentdataset in0:
    wrappers = makeOutputWrappers "FilterByLastComponentDataset" [in0] 1 ""
    TFOutput wrappers.head.get

def merge in0:
    wrappers = makeOutputWrappers "Merge" [in0] 2 ""
    wrappers.each (wrapper: TFOutput wrapper)

def roll in0 in1 in2:
    wrappers = makeOutputWrappers "Roll" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def adjustcontrast in0 in1 in2 in3:
    wrappers = makeOutputWrappers "AdjustContrast" [in0, in1, in2, in3] 1 ""
    TFOutput wrappers.head.get

def ctcbeamsearchdecoder in0 in1:
    wrappers = makeOutputWrappers "CTCBeamSearchDecoder" [in0, in1] 4 ""
    wrappers.each (wrapper: TFOutput wrapper)

def audiospectrogram in0:
    wrappers = makeOutputWrappers "AudioSpectrogram" [in0] 1 ""
    TFOutput wrappers.head.get

def invgrad in0 in1:
    wrappers = makeOutputWrappers "InvGrad" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def tensorlistreserve in0 in1:
    wrappers = makeOutputWrappers "TensorListReserve" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def stridedslice in0 in1 in2 in3:
    wrappers = makeOutputWrappers "StridedSlice" [in0, in1, in2, in3] 1 ""
    TFOutput wrappers.head.get

def logicalnot in0:
    wrappers = makeOutputWrappers "LogicalNot" [in0] 1 ""
    TFOutput wrappers.head.get

def rfft3d in0 in1:
    wrappers = makeOutputWrappers "RFFT3D" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def readerread in0 in1:
    wrappers = makeOutputWrappers "ReaderRead" [in0, in1] 2 ""
    wrappers.each (wrapper: TFOutput wrapper)

def readerrestorestate in0 in1:
    wrappers = makeOutputWrappers "ReaderRestoreState" [in0, in1] 0 ""
    wrappers.each (wrapper: TFOutput wrapper)

def reducejoin in0 in1:
    wrappers = makeOutputWrappers "ReduceJoin" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def sparseaddgrad in0 in1 in2 in3:
    wrappers = makeOutputWrappers "SparseAddGrad" [in0, in1, in2, in3] 2 ""
    wrappers.each (wrapper: TFOutput wrapper)

def maxpoolgradgrad in0 in1 in2:
    wrappers = makeOutputWrappers "MaxPoolGradGrad" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def tensorlistpopback in0:
    wrappers = makeOutputWrappers "TensorListPopBack" [in0] 2 ""
    wrappers.each (wrapper: TFOutput wrapper)

def paralleldynamicstitch in0 in1:
    wrappers = makeOutputWrappers "ParallelDynamicStitch" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def tensorlistelementshape in0:
    wrappers = makeOutputWrappers "TensorListElementShape" [in0] 1 ""
    TFOutput wrappers.head.get

def underscoremklsquareddifference in0 in1 in2 in3:
    wrappers = makeOutputWrappers "_MklSquaredDifference" [in0, in1, in2, in3] 2 ""
    wrappers.each (wrapper: TFOutput wrapper)

def queuedequeue in0:
    wrappers = makeOutputWrappers "QueueDequeue" [in0] 1 ""
    TFOutput wrappers.head.get

def tensorarrayread in0 in1 in2:
    wrappers = makeOutputWrappers "TensorArrayRead" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def shape in0:
    wrappers = makeOutputWrappers "Shape" [in0] 1 ""
    TFOutput wrappers.head.get

def pow in0 in1:
    wrappers = makeOutputWrappers "Pow" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def sdcafprint in0:
    wrappers = makeOutputWrappers "SdcaFprint" [in0] 1 ""
    TFOutput wrappers.head.get

def readerreadupto in0 in1 in2:
    wrappers = makeOutputWrappers "ReaderReadUpTo" [in0, in1, in2] 2 ""
    wrappers.each (wrapper: TFOutput wrapper)

def batchmatrixsolve in0 in1:
    wrappers = makeOutputWrappers "BatchMatrixSolve" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def rfft2d in0 in1:
    wrappers = makeOutputWrappers "RFFT2D" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def serializesparse in0 in1 in2:
    wrappers = makeOutputWrappers "SerializeSparse" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def drawboundingboxes in0 in1:
    wrappers = makeOutputWrappers "DrawBoundingBoxes" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def spacetodepth in0:
    wrappers = makeOutputWrappers "SpaceToDepth" [in0] 1 ""
    TFOutput wrappers.head.get

def generatevocabremapping in0 in1:
    wrappers = makeOutputWrappers "GenerateVocabRemapping" [in0, in1] 2 ""
    wrappers.each (wrapper: TFOutput wrapper)

def queueenqueue in0 in1:
    wrappers = makeOutputWrappers "QueueEnqueue" [in0, in1] 0 ""
    wrappers.each (wrapper: TFOutput wrapper)

def abort:
    wrappers = makeOutputWrappers "Abort" [] 0 ""
    wrappers.each (wrapper: TFOutput wrapper)

def mod in0 in1:
    wrappers = makeOutputWrappers "Mod" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def assignadd in0 in1:
    wrappers = makeOutputWrappers "AssignAdd" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def avgpool3dgrad in0 in1:
    wrappers = makeOutputWrappers "AvgPool3DGrad" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def unbatchgrad in0 in1 in2 in3:
    wrappers = makeOutputWrappers "UnbatchGrad" [in0, in1, in2, in3] 1 ""
    TFOutput wrappers.head.get

def parsesinglesequenceexample in0 in1 in2 in3 in4 in5 in6 in7:
    wrappers = makeOutputWrappers "ParseSingleSequenceExample" [in0, in1, in2, in3, in4, in5, in6, in7] 8 ""
    wrappers.each (wrapper: TFOutput wrapper)

def debugnancount in0:
    wrappers = makeOutputWrappers "DebugNanCount" [in0] 1 ""
    TFOutput wrappers.head.get

def applyrmsprop in0 in1 in2 in3 in4 in5 in6 in7:
    wrappers = makeOutputWrappers "ApplyRMSProp" [in0, in1, in2, in3, in4, in5, in6, in7] 1 ""
    TFOutput wrappers.head.get

def fakequantwithminmaxvars in0 in1 in2:
    wrappers = makeOutputWrappers "FakeQuantWithMinMaxVars" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def decodeprotov2 in0:
    wrappers = makeOutputWrappers "DecodeProtoV2" [in0] 2 ""
    wrappers.each (wrapper: TFOutput wrapper)

def optionalnone:
    wrappers = makeOutputWrappers "OptionalNone" [] 1 ""
    TFOutput wrappers.head.get

def cropandresizegradimage in0 in1 in2 in3:
    wrappers = makeOutputWrappers "CropAndResizeGradImage" [in0, in1, in2, in3] 1 ""
    TFOutput wrappers.head.get

def queueclose in0:
    wrappers = makeOutputWrappers "QueueClose" [in0] 0 ""
    wrappers.each (wrapper: TFOutput wrapper)

def scattermin in0 in1 in2:
    wrappers = makeOutputWrappers "ScatterMin" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def readfile in0:
    wrappers = makeOutputWrappers "ReadFile" [in0] 1 ""
    TFOutput wrappers.head.get

def concatv2 in0 in1:
    wrappers = makeOutputWrappers "ConcatV2" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def stringtohashbucketfast in0:
    wrappers = makeOutputWrappers "StringToHashBucketFast" [in0] 1 ""
    TFOutput wrappers.head.get

def batchdataset in0 in1:
    wrappers = makeOutputWrappers "BatchDataset" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def accumulatorsetglobalstep in0 in1:
    wrappers = makeOutputWrappers "AccumulatorSetGlobalStep" [in0, in1] 0 ""
    wrappers.each (wrapper: TFOutput wrapper)

def matrixdiagpart in0:
    wrappers = makeOutputWrappers "MatrixDiagPart" [in0] 1 ""
    TFOutput wrappers.head.get

def cachedataset in0 in1:
    wrappers = makeOutputWrappers "CacheDataset" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def placeholder:
    wrappers = makeOutputWrappers "Placeholder" [] 1 ""
    TFOutput wrappers.head.get

def abs in0:
    wrappers = makeOutputWrappers "Abs" [in0] 1 ""
    TFOutput wrappers.head.get

def accumulatorapplygradient in0 in1 in2:
    wrappers = makeOutputWrappers "AccumulatorApplyGradient" [in0, in1, in2] 0 ""
    wrappers.each (wrapper: TFOutput wrapper)

def sparseaccumulatorapplygradient in0 in1 in2 in3 in4:
    wrappers = makeOutputWrappers "SparseAccumulatorApplyGradient" [in0, in1, in2, in3, in4] 0 ""
    wrappers.each (wrapper: TFOutput wrapper)

def atanh in0:
    wrappers = makeOutputWrappers "Atanh" [in0] 1 ""
    TFOutput wrappers.head.get

def pack in0:
    wrappers = makeOutputWrappers "Pack" [in0] 1 ""
    TFOutput wrappers.head.get

def conv2d in0 in1:
    wrappers = makeOutputWrappers "Conv2D" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def tensorarrayclose in0:
    wrappers = makeOutputWrappers "TensorArrayClose" [in0] 0 ""
    wrappers.each (wrapper: TFOutput wrapper)

def scattersub in0 in1 in2:
    wrappers = makeOutputWrappers "ScatterSub" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def applyftrl in0 in1 in2 in3 in4 in5 in6 in7:
    wrappers = makeOutputWrappers "ApplyFtrl" [in0, in1, in2, in3, in4, in5, in6, in7] 1 ""
    TFOutput wrappers.head.get

def serializetensor in0:
    wrappers = makeOutputWrappers "SerializeTensor" [in0] 1 ""
    TFOutput wrappers.head.get

def underscorehostcast in0:
    wrappers = makeOutputWrappers "_HostCast" [in0] 1 ""
    TFOutput wrappers.head.get

def fusedbatchnormgradv2 in0 in1 in2 in3 in4:
    wrappers = makeOutputWrappers "FusedBatchNormGradV2" [in0, in1, in2, in3, in4] 5 ""
    wrappers.each (wrapper: TFOutput wrapper)

def mapdataset in0 in1:
    wrappers = makeOutputWrappers "MapDataset" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def batchnormwithglobalnormalization in0 in1 in2 in3 in4:
    wrappers = makeOutputWrappers "BatchNormWithGlobalNormalization" [in0, in1, in2, in3, in4] 1 ""
    TFOutput wrappers.head.get

def controltrigger:
    wrappers = makeOutputWrappers "ControlTrigger" [] 0 ""
    wrappers.each (wrapper: TFOutput wrapper)

def tensorarrayreadv2 in0 in1 in2:
    wrappers = makeOutputWrappers "TensorArrayReadV2" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def placeholderwithdefault in0:
    wrappers = makeOutputWrappers "PlaceholderWithDefault" [in0] 1 ""
    TFOutput wrappers.head.get

def decodebase64 in0:
    wrappers = makeOutputWrappers "DecodeBase64" [in0] 1 ""
    TFOutput wrappers.head.get

def selugrad in0 in1:
    wrappers = makeOutputWrappers "SeluGrad" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def sqrtgrad in0 in1:
    wrappers = makeOutputWrappers "SqrtGrad" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def refexit in0:
    wrappers = makeOutputWrappers "RefExit" [in0] 1 ""
    TFOutput wrappers.head.get

def snapshot in0:
    wrappers = makeOutputWrappers "Snapshot" [in0] 1 ""
    TFOutput wrappers.head.get

def sparseapplyadagradda in0 in1 in2 in3 in4 in5 in6 in7 in8:
    wrappers = makeOutputWrappers "SparseApplyAdagradDA" [in0, in1, in2, in3, in4, in5, in6, in7, in8] 1 ""
    TFOutput wrappers.head.get

def divnonan in0 in1:
    wrappers = makeOutputWrappers "DivNoNan" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def tensorarrayscatter in0 in1 in2 in3:
    wrappers = makeOutputWrappers "TensorArrayScatter" [in0, in1, in2, in3] 1 ""
    TFOutput wrappers.head.get

def sparsereducemax in0 in1 in2 in3:
    wrappers = makeOutputWrappers "SparseReduceMax" [in0, in1, in2, in3] 1 ""
    TFOutput wrappers.head.get

def barriertakemany in0 in1:
    wrappers = makeOutputWrappers "BarrierTakeMany" [in0, in1] 3 ""
    wrappers.each (wrapper: TFOutput wrapper)

def fractionalmaxpool in0:
    wrappers = makeOutputWrappers "FractionalMaxPool" [in0] 3 ""
    wrappers.each (wrapper: TFOutput wrapper)

def scatterndnonaliasingadd in0 in1 in2:
    wrappers = makeOutputWrappers "ScatterNdNonAliasingAdd" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def tensorarraysize in0 in1:
    wrappers = makeOutputWrappers "TensorArraySize" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def resizenearestneighborgrad in0 in1:
    wrappers = makeOutputWrappers "ResizeNearestNeighborGrad" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def tensorarraysizev2 in0 in1:
    wrappers = makeOutputWrappers "TensorArraySizeV2" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def cudnnrnnparamstocanonical in0 in1 in2 in3:
    wrappers = makeOutputWrappers "CudnnRNNParamsToCanonical" [in0, in1, in2, in3] 2 ""
    wrappers.each (wrapper: TFOutput wrapper)

def shapen in0:
    wrappers = makeOutputWrappers "ShapeN" [in0] 1 ""
    TFOutput wrappers.head.get

def barrierreadysize in0:
    wrappers = makeOutputWrappers "BarrierReadySize" [in0] 1 ""
    TFOutput wrappers.head.get

def fakequantwithminmaxargs in0:
    wrappers = makeOutputWrappers "FakeQuantWithMinMaxArgs" [in0] 1 ""
    TFOutput wrappers.head.get

def maxpoolv2 in0 in1 in2:
    wrappers = makeOutputWrappers "MaxPoolV2" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def groupbywindowdataset in0 in1 in2 in3:
    wrappers = makeOutputWrappers "GroupByWindowDataset" [in0, in1, in2, in3] 1 ""
    TFOutput wrappers.head.get

def mapandbatchdataset in0 in1 in2 in3 in4:
    wrappers = makeOutputWrappers "MapAndBatchDataset" [in0, in1, in2, in3, in4] 1 ""
    TFOutput wrappers.head.get

def decodejsonexample in0:
    wrappers = makeOutputWrappers "DecodeJSONExample" [in0] 1 ""
    TFOutput wrappers.head.get

def sparseadd in0 in1 in2 in3 in4 in5 in6:
    wrappers = makeOutputWrappers "SparseAdd" [in0, in1, in2, in3, in4, in5, in6] 3 ""
    wrappers.each (wrapper: TFOutput wrapper)

def initializetable in0 in1 in2:
    wrappers = makeOutputWrappers "InitializeTable" [in0, in1, in2] 0 ""
    wrappers.each (wrapper: TFOutput wrapper)

def tensorsummary in0:
    wrappers = makeOutputWrappers "TensorSummary" [in0] 1 ""
    TFOutput wrappers.head.get

def imagesummary in0 in1:
    wrappers = makeOutputWrappers "ImageSummary" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def avgpool in0:
    wrappers = makeOutputWrappers "AvgPool" [in0] 1 ""
    TFOutput wrappers.head.get

def mergesummary in0:
    wrappers = makeOutputWrappers "MergeSummary" [in0] 1 ""
    TFOutput wrappers.head.get

def fft in0:
    wrappers = makeOutputWrappers "FFT" [in0] 1 ""
    TFOutput wrappers.head.get

def ifft in0:
    wrappers = makeOutputWrappers "IFFT" [in0] 1 ""
    TFOutput wrappers.head.get

def fft2d in0:
    wrappers = makeOutputWrappers "FFT2D" [in0] 1 ""
    TFOutput wrappers.head.get

def ifft2d in0:
    wrappers = makeOutputWrappers "IFFT2D" [in0] 1 ""
    TFOutput wrappers.head.get

def fill in0 in1:
    wrappers = makeOutputWrappers "Fill" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def tensorlistpushbackbatch in0 in1:
    wrappers = makeOutputWrappers "TensorListPushBackBatch" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def ifft3d in0:
    wrappers = makeOutputWrappers "IFFT3D" [in0] 1 ""
    TFOutput wrappers.head.get

def rfft in0 in1:
    wrappers = makeOutputWrappers "RFFT" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def latencystatsdataset in0 in1:
    wrappers = makeOutputWrappers "LatencyStatsDataset" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def asinh in0:
    wrappers = makeOutputWrappers "Asinh" [in0] 1 ""
    TFOutput wrappers.head.get

def tanhgrad in0 in1:
    wrappers = makeOutputWrappers "TanhGrad" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def scalarsummary in0 in1:
    wrappers = makeOutputWrappers "ScalarSummary" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def irfft2d in0 in1:
    wrappers = makeOutputWrappers "IRFFT2D" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def irfft3d in0 in1:
    wrappers = makeOutputWrappers "IRFFT3D" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def batchifft2d in0:
    wrappers = makeOutputWrappers "BatchIFFT2D" [in0] 1 ""
    TFOutput wrappers.head.get

def uniquewithcounts in0:
    wrappers = makeOutputWrappers "UniqueWithCounts" [in0] 3 ""
    wrappers.each (wrapper: TFOutput wrapper)

def batchifft3d in0:
    wrappers = makeOutputWrappers "BatchIFFT3D" [in0] 1 ""
    TFOutput wrappers.head.get

def decoderaw in0:
    wrappers = makeOutputWrappers "DecodeRaw" [in0] 1 ""
    TFOutput wrappers.head.get

def elugrad in0 in1:
    wrappers = makeOutputWrappers "EluGrad" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def staticregexreplace in0:
    wrappers = makeOutputWrappers "StaticRegexReplace" [in0] 1 ""
    TFOutput wrappers.head.get

def mapdefun in0:
    wrappers = makeOutputWrappers "MapDefun" [in0] 1 ""
    TFOutput wrappers.head.get

def matrixbandpart in0 in1 in2:
    wrappers = makeOutputWrappers "MatrixBandPart" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def decodecompressed in0:
    wrappers = makeOutputWrappers "DecodeCompressed" [in0] 1 ""
    TFOutput wrappers.head.get

def parseexample in0 in1 in2 in3 in4:
    wrappers = makeOutputWrappers "ParseExample" [in0, in1, in2, in3, in4] 4 ""
    wrappers.each (wrapper: TFOutput wrapper)

def parsesingleexample in0 in1:
    wrappers = makeOutputWrappers "ParseSingleExample" [in0, in1] 4 ""
    wrappers.each (wrapper: TFOutput wrapper)

def tensorlistlength in0:
    wrappers = makeOutputWrappers "TensorListLength" [in0] 1 ""
    TFOutput wrappers.head.get

def maxpoolwithargmax in0:
    wrappers = makeOutputWrappers "MaxPoolWithArgmax" [in0] 2 ""
    wrappers.each (wrapper: TFOutput wrapper)

def parsetensor in0:
    wrappers = makeOutputWrappers "ParseTensor" [in0] 1 ""
    TFOutput wrappers.head.get

def decodecsv in0 in1:
    wrappers = makeOutputWrappers "DecodeCSV" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def rank in0:
    wrappers = makeOutputWrappers "Rank" [in0] 1 ""
    TFOutput wrappers.head.get

def angle in0:
    wrappers = makeOutputWrappers "Angle" [in0] 1 ""
    TFOutput wrappers.head.get

def barrierinsertmany in0 in1 in2:
    wrappers = makeOutputWrappers "BarrierInsertMany" [in0, in1, in2] 0 ""
    wrappers.each (wrapper: TFOutput wrapper)

def sparseapplyadagrad in0 in1 in2 in3 in4:
    wrappers = makeOutputWrappers "SparseApplyAdagrad" [in0, in1, in2, in3, in4] 1 ""
    TFOutput wrappers.head.get

def linspace in0 in1 in2:
    wrappers = makeOutputWrappers "LinSpace" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def applyadam in0 in1 in2 in3 in4 in5 in6 in7 in8 in9:
    wrappers = makeOutputWrappers "ApplyAdam" [in0, in1, in2, in3, in4, in5, in6, in7, in8, in9] 1 ""
    TFOutput wrappers.head.get

def pad in0 in1:
    wrappers = makeOutputWrappers "Pad" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def writefile in0 in1:
    wrappers = makeOutputWrappers "WriteFile" [in0, in1] 0 ""
    wrappers.each (wrapper: TFOutput wrapper)

def underscoremklmaximum in0 in1 in2 in3:
    wrappers = makeOutputWrappers "_MklMaximum" [in0, in1, in2, in3] 2 ""
    wrappers.each (wrapper: TFOutput wrapper)

def applyadadelta in0 in1 in2 in3 in4 in5 in6:
    wrappers = makeOutputWrappers "ApplyAdadelta" [in0, in1, in2, in3, in4, in5, in6] 1 ""
    TFOutput wrappers.head.get

def batchmatrixdiag in0:
    wrappers = makeOutputWrappers "BatchMatrixDiag" [in0] 1 ""
    TFOutput wrappers.head.get

def fakequantwithminmaxargsgradient in0 in1:
    wrappers = makeOutputWrappers "FakeQuantWithMinMaxArgsGradient" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def applypowersign in0 in1 in2 in3 in4 in5 in6:
    wrappers = makeOutputWrappers "ApplyPowerSign" [in0, in1, in2, in3, in4, in5, in6] 1 ""
    TFOutput wrappers.head.get

def batchmatmul in0 in1:
    wrappers = makeOutputWrappers "BatchMatMul" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def sdcaoptimizer in0 in1 in2 in3 in4 in5 in6 in7 in8 in9:
    wrappers = makeOutputWrappers "SdcaOptimizer" [in0, in1, in2, in3, in4, in5, in6, in7, in8, in9] 3 ""
    wrappers.each (wrapper: TFOutput wrapper)

def quantizedconcat in0 in1 in2 in3:
    wrappers = makeOutputWrappers "QuantizedConcat" [in0, in1, in2, in3] 3 ""
    wrappers.each (wrapper: TFOutput wrapper)

def sparseslice in0 in1 in2 in3 in4:
    wrappers = makeOutputWrappers "SparseSlice" [in0, in1, in2, in3, in4] 3 ""
    wrappers.each (wrapper: TFOutput wrapper)

def l2loss in0:
    wrappers = makeOutputWrappers "L2Loss" [in0] 1 ""
    TFOutput wrappers.head.get

def densetosparsesetoperation in0 in1 in2 in3:
    wrappers = makeOutputWrappers "DenseToSparseSetOperation" [in0, in1, in2, in3] 3 ""
    wrappers.each (wrapper: TFOutput wrapper)

def sparsetosparsesetoperation in0 in1 in2 in3 in4 in5:
    wrappers = makeOutputWrappers "SparseToSparseSetOperation" [in0, in1, in2, in3, in4, in5] 3 ""
    wrappers.each (wrapper: TFOutput wrapper)

def deserializesparse in0:
    wrappers = makeOutputWrappers "DeserializeSparse" [in0] 3 ""
    wrappers.each (wrapper: TFOutput wrapper)

def deserializemanysparse in0:
    wrappers = makeOutputWrappers "DeserializeManySparse" [in0] 3 ""
    wrappers.each (wrapper: TFOutput wrapper)

def stringjoin in0:
    wrappers = makeOutputWrappers "StringJoin" [in0] 1 ""
    TFOutput wrappers.head.get

def immutableconst:
    wrappers = makeOutputWrappers "ImmutableConst" [] 1 ""
    TFOutput wrappers.head.get

def mapandbatchdatasetv2 in0 in1 in2 in3 in4:
    wrappers = makeOutputWrappers "MapAndBatchDatasetV2" [in0, in1, in2, in3, in4] 1 ""
    TFOutput wrappers.head.get

def sparsetodense in0 in1 in2 in3:
    wrappers = makeOutputWrappers "SparseToDense" [in0, in1, in2, in3] 1 ""
    TFOutput wrappers.head.get

def batchtospace in0 in1:
    wrappers = makeOutputWrappers "BatchToSpace" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def irfft in0 in1:
    wrappers = makeOutputWrappers "IRFFT" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def sparseconcat in0 in1 in2:
    wrappers = makeOutputWrappers "SparseConcat" [in0, in1, in2] 3 ""
    wrappers.each (wrapper: TFOutput wrapper)

def sparsecross in0 in1 in2 in3:
    wrappers = makeOutputWrappers "SparseCross" [in0, in1, in2, in3] 3 ""
    wrappers.each (wrapper: TFOutput wrapper)

def listdiff in0 in1:
    wrappers = makeOutputWrappers "ListDiff" [in0, in1] 2 ""
    wrappers.each (wrapper: TFOutput wrapper)

def sparsesplit in0 in1 in2 in3:
    wrappers = makeOutputWrappers "SparseSplit" [in0, in1, in2, in3] 3 ""
    wrappers.each (wrapper: TFOutput wrapper)

def sparsereorder in0 in1 in2:
    wrappers = makeOutputWrappers "SparseReorder" [in0, in1, in2] 2 ""
    wrappers.each (wrapper: TFOutput wrapper)

def tensorarraysplitv2 in0 in1 in2 in3:
    wrappers = makeOutputWrappers "TensorArraySplitV2" [in0, in1, in2, in3] 1 ""
    TFOutput wrappers.head.get

def sparsereshape in0 in1 in2:
    wrappers = makeOutputWrappers "SparseReshape" [in0, in1, in2] 2 ""
    wrappers.each (wrapper: TFOutput wrapper)

def sparsetensordenseadd in0 in1 in2 in3:
    wrappers = makeOutputWrappers "SparseTensorDenseAdd" [in0, in1, in2, in3] 1 ""
    TFOutput wrappers.head.get

def sparsereducesum in0 in1 in2 in3:
    wrappers = makeOutputWrappers "SparseReduceSum" [in0, in1, in2, in3] 1 ""
    TFOutput wrappers.head.get

def sparsereducesumsparse in0 in1 in2 in3:
    wrappers = makeOutputWrappers "SparseReduceSumSparse" [in0, in1, in2, in3] 3 ""
    wrappers.each (wrapper: TFOutput wrapper)

def mul in0 in1:
    wrappers = makeOutputWrappers "Mul" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def sparsedensecwisemul in0 in1 in2 in3:
    wrappers = makeOutputWrappers "SparseDenseCwiseMul" [in0, in1, in2, in3] 1 ""
    TFOutput wrappers.head.get

def sparsesoftmax in0 in1 in2:
    wrappers = makeOutputWrappers "SparseSoftmax" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def sparsesparseminimum in0 in1 in2 in3 in4 in5:
    wrappers = makeOutputWrappers "SparseSparseMinimum" [in0, in1, in2, in3, in4, in5] 2 ""
    wrappers.each (wrapper: TFOutput wrapper)

def tile in0 in1:
    wrappers = makeOutputWrappers "Tile" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def dilation2dbackpropfilter in0 in1 in2:
    wrappers = makeOutputWrappers "Dilation2DBackpropFilter" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def tensorlistpushback in0 in1:
    wrappers = makeOutputWrappers "TensorListPushBack" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def lookuptableimport in0 in1 in2:
    wrappers = makeOutputWrappers "LookupTableImport" [in0, in1, in2] 0 ""
    wrappers.each (wrapper: TFOutput wrapper)

def const:
    wrappers = makeOutputWrappers "Const" [] 1 ""
    TFOutput wrappers.head.get

def sparsefillemptyrows in0 in1 in2 in3:
    wrappers = makeOutputWrappers "SparseFillEmptyRows" [in0, in1, in2, in3] 4 ""
    wrappers.each (wrapper: TFOutput wrapper)

def reverse in0 in1:
    wrappers = makeOutputWrappers "Reverse" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def logsoftmax in0:
    wrappers = makeOutputWrappers "LogSoftmax" [in0] 1 ""
    TFOutput wrappers.head.get

def invertpermutation in0:
    wrappers = makeOutputWrappers "InvertPermutation" [in0] 1 ""
    TFOutput wrappers.head.get

def mirrorpadgrad in0 in1:
    wrappers = makeOutputWrappers "MirrorPadGrad" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def oneslike in0:
    wrappers = makeOutputWrappers "OnesLike" [in0] 1 ""
    TFOutput wrappers.head.get

def sparsefillemptyrowsgrad in0 in1:
    wrappers = makeOutputWrappers "SparseFillEmptyRowsGrad" [in0, in1] 2 ""
    wrappers.each (wrapper: TFOutput wrapper)

def tensorlistsetitem in0 in1 in2:
    wrappers = makeOutputWrappers "TensorListSetItem" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def diag in0:
    wrappers = makeOutputWrappers "Diag" [in0] 1 ""
    TFOutput wrappers.head.get

def parallelinterleavedataset in0 in1 in2 in3 in4 in5 in6:
    wrappers = makeOutputWrappers "ParallelInterleaveDataset" [in0, in1, in2, in3, in4, in5, in6] 1 ""
    TFOutput wrappers.head.get

def fakequantwithminmaxvarsperchannel in0 in1 in2:
    wrappers = makeOutputWrappers "FakeQuantWithMinMaxVarsPerChannel" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def encodejpeg in0:
    wrappers = makeOutputWrappers "EncodeJpeg" [in0] 1 ""
    TFOutput wrappers.head.get

def quantizedownandshrinkrange in0 in1 in2:
    wrappers = makeOutputWrappers "QuantizeDownAndShrinkRange" [in0, in1, in2] 3 ""
    wrappers.each (wrapper: TFOutput wrapper)

def add in0 in1:
    wrappers = makeOutputWrappers "Add" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def randomgammagrad in0 in1:
    wrappers = makeOutputWrappers "RandomGammaGrad" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def sparseaccumulatortakegradient in0 in1:
    wrappers = makeOutputWrappers "SparseAccumulatorTakeGradient" [in0, in1] 3 ""
    wrappers.each (wrapper: TFOutput wrapper)

def floormod in0 in1:
    wrappers = makeOutputWrappers "FloorMod" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def statelessrandomuniform in0 in1:
    wrappers = makeOutputWrappers "StatelessRandomUniform" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def statelessrandomnormal in0 in1:
    wrappers = makeOutputWrappers "StatelessRandomNormal" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def statelessmultinomial in0 in1 in2:
    wrappers = makeOutputWrappers "StatelessMultinomial" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def regexreplace in0 in1 in2:
    wrappers = makeOutputWrappers "RegexReplace" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def regexfullmatch in0 in1:
    wrappers = makeOutputWrappers "RegexFullMatch" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def tensorlistconcatlists in0 in1:
    wrappers = makeOutputWrappers "TensorListConcatLists" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def tensorarrayscatterv2 in0 in1 in2 in3:
    wrappers = makeOutputWrappers "TensorArrayScatterV2" [in0, in1, in2, in3] 1 ""
    TFOutput wrappers.head.get

def asstring in0:
    wrappers = makeOutputWrappers "AsString" [in0] 1 ""
    TFOutput wrappers.head.get

def stringsplit in0 in1:
    wrappers = makeOutputWrappers "StringSplit" [in0, in1] 3 ""
    wrappers.each (wrapper: TFOutput wrapper)

def stringsplitv2 in0 in1:
    wrappers = makeOutputWrappers "StringSplitV2" [in0, in1] 3 ""
    wrappers.each (wrapper: TFOutput wrapper)

def stringstrip in0:
    wrappers = makeOutputWrappers "StringStrip" [in0] 1 ""
    TFOutput wrappers.head.get

def stringtohashbucketstrong in0:
    wrappers = makeOutputWrappers "StringToHashBucketStrong" [in0] 1 ""
    TFOutput wrappers.head.get

def stringlength in0:
    wrappers = makeOutputWrappers "StringLength" [in0] 1 ""
    TFOutput wrappers.head.get

def windowdataset in0 in1:
    wrappers = makeOutputWrappers "WindowDataset" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def tensorarrayclosev2 in0:
    wrappers = makeOutputWrappers "TensorArrayCloseV2" [in0] 0 ""
    wrappers.each (wrapper: TFOutput wrapper)

def encodebase64 in0:
    wrappers = makeOutputWrappers "EncodeBase64" [in0] 1 ""
    TFOutput wrappers.head.get

def flatmapdataset in0 in1:
    wrappers = makeOutputWrappers "FlatMapDataset" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def applyadamax in0 in1 in2 in3 in4 in5 in6 in7 in8:
    wrappers = makeOutputWrappers "ApplyAdaMax" [in0, in1, in2, in3, in4, in5, in6, in7, in8] 1 ""
    TFOutput wrappers.head.get

def concat in0 in1:
    wrappers = makeOutputWrappers "Concat" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def prod in0 in1:
    wrappers = makeOutputWrappers "Prod" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def isvariableinitialized in0:
    wrappers = makeOutputWrappers "IsVariableInitialized" [in0] 1 ""
    TFOutput wrappers.head.get

def gather in0 in1:
    wrappers = makeOutputWrappers "Gather" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def destroytemporaryvariable in0:
    wrappers = makeOutputWrappers "DestroyTemporaryVariable" [in0] 1 ""
    TFOutput wrappers.head.get

def cast in0:
    wrappers = makeOutputWrappers "Cast" [in0] 1 ""
    TFOutput wrappers.head.get

def assignsub in0 in1:
    wrappers = makeOutputWrappers "AssignSub" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def scatteradd in0 in1 in2:
    wrappers = makeOutputWrappers "ScatterAdd" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def scattermul in0 in1 in2:
    wrappers = makeOutputWrappers "ScatterMul" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def scattermax in0 in1 in2:
    wrappers = makeOutputWrappers "ScatterMax" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def mirrorpad in0 in1:
    wrappers = makeOutputWrappers "MirrorPad" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def batchmatrixdiagpart in0:
    wrappers = makeOutputWrappers "BatchMatrixDiagPart" [in0] 1 ""
    TFOutput wrappers.head.get

def scatterndupdate in0 in1 in2:
    wrappers = makeOutputWrappers "ScatterNdUpdate" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def div in0 in1:
    wrappers = makeOutputWrappers "Div" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def scatterndsub in0 in1 in2:
    wrappers = makeOutputWrappers "ScatterNdSub" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def topk in0:
    wrappers = makeOutputWrappers "TopK" [in0] 2 ""
    wrappers.each (wrapper: TFOutput wrapper)

def applyproximalgradientdescent in0 in1 in2 in3 in4:
    wrappers = makeOutputWrappers "ApplyProximalGradientDescent" [in0, in1, in2, in3, in4] 1 ""
    TFOutput wrappers.head.get

def matchingfiles in0:
    wrappers = makeOutputWrappers "MatchingFiles" [in0] 1 ""
    TFOutput wrappers.head.get

def sparseapplyproximalgradientdescent in0 in1 in2 in3 in4 in5:
    wrappers = makeOutputWrappers "SparseApplyProximalGradientDescent" [in0, in1, in2, in3, in4, in5] 1 ""
    TFOutput wrappers.head.get

def sparseapplyadadelta in0 in1 in2 in3 in4 in5 in6 in7:
    wrappers = makeOutputWrappers "SparseApplyAdadelta" [in0, in1, in2, in3, in4, in5, in6, in7] 1 ""
    TFOutput wrappers.head.get

def quantizev2 in0 in1 in2:
    wrappers = makeOutputWrappers "QuantizeV2" [in0, in1, in2] 3 ""
    wrappers.each (wrapper: TFOutput wrapper)

def audiosummaryv2 in0 in1 in2:
    wrappers = makeOutputWrappers "AudioSummaryV2" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def applyadagrad in0 in1 in2 in3:
    wrappers = makeOutputWrappers "ApplyAdagrad" [in0, in1, in2, in3] 1 ""
    TFOutput wrappers.head.get

def matrixsolvels in0 in1 in2:
    wrappers = makeOutputWrappers "MatrixSolveLs" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def bitwiseor in0 in1:
    wrappers = makeOutputWrappers "BitwiseOr" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def applyproximaladagrad in0 in1 in2 in3 in4 in5:
    wrappers = makeOutputWrappers "ApplyProximalAdagrad" [in0, in1, in2, in3, in4, in5] 1 ""
    TFOutput wrappers.head.get

def sparseapplyftrl in0 in1 in2 in3 in4 in5 in6 in7 in8:
    wrappers = makeOutputWrappers "SparseApplyFtrl" [in0, in1, in2, in3, in4, in5, in6, in7, in8] 1 ""
    TFOutput wrappers.head.get

def sub in0 in1:
    wrappers = makeOutputWrappers "Sub" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def isinf in0:
    wrappers = makeOutputWrappers "IsInf" [in0] 1 ""
    TFOutput wrappers.head.get

def applyftrlv2 in0 in1 in2 in3 in4 in5 in6 in7 in8:
    wrappers = makeOutputWrappers "ApplyFtrlV2" [in0, in1, in2, in3, in4, in5, in6, in7, in8] 1 ""
    TFOutput wrappers.head.get

def bitwisexor in0 in1:
    wrappers = makeOutputWrappers "BitwiseXor" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def stringtonumber in0:
    wrappers = makeOutputWrappers "StringToNumber" [in0] 1 ""
    TFOutput wrappers.head.get

def sparsedensecwisediv in0 in1 in2 in3:
    wrappers = makeOutputWrappers "SparseDenseCwiseDiv" [in0, in1, in2, in3] 1 ""
    TFOutput wrappers.head.get

def applymomentum in0 in1 in2 in3 in4:
    wrappers = makeOutputWrappers "ApplyMomentum" [in0, in1, in2, in3, in4] 1 ""
    TFOutput wrappers.head.get

def sparseapplymomentum in0 in1 in2 in3 in4 in5:
    wrappers = makeOutputWrappers "SparseApplyMomentum" [in0, in1, in2, in3, in4, in5] 1 ""
    TFOutput wrappers.head.get

def crossreplicasum in0 in1:
    wrappers = makeOutputWrappers "CrossReplicaSum" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def applycenteredrmsprop in0 in1 in2 in3 in4 in5 in6 in7 in8:
    wrappers = makeOutputWrappers "ApplyCenteredRMSProp" [in0, in1, in2, in3, in4, in5, in6, in7, in8] 1 ""
    TFOutput wrappers.head.get

def sparseapplyrmsprop in0 in1 in2 in3 in4 in5 in6 in7 in8:
    wrappers = makeOutputWrappers "SparseApplyRMSProp" [in0, in1, in2, in3, in4, in5, in6, in7, in8] 1 ""
    TFOutput wrappers.head.get

def sparseapplycenteredrmsprop in0 in1 in2 in3 in4 in5 in6 in7 in8 in9:
    wrappers = makeOutputWrappers "SparseApplyCenteredRMSProp" [in0, in1, in2, in3, in4, in5, in6, in7, in8, in9] 1 ""
    TFOutput wrappers.head.get

def size in0:
    wrappers = makeOutputWrappers "Size" [in0] 1 ""
    TFOutput wrappers.head.get

def identityn in0:
    wrappers = makeOutputWrappers "IdentityN" [in0] 1 ""
    TFOutput wrappers.head.get

def biasaddv1 in0 in1:
    wrappers = makeOutputWrappers "BiasAddV1" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def reversev2 in0 in1:
    wrappers = makeOutputWrappers "ReverseV2" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def applyaddsign in0 in1 in2 in3 in4 in5 in6:
    wrappers = makeOutputWrappers "ApplyAddSign" [in0, in1, in2, in3, in4, in5, in6] 1 ""
    TFOutput wrappers.head.get

def matrixdeterminant in0:
    wrappers = makeOutputWrappers "MatrixDeterminant" [in0] 1 ""
    TFOutput wrappers.head.get

def readernumworkunitscompleted in0:
    wrappers = makeOutputWrappers "ReaderNumWorkUnitsCompleted" [in0] 1 ""
    TFOutput wrappers.head.get

def gcsconfigurecredentials in0:
    wrappers = makeOutputWrappers "GcsConfigureCredentials" [in0] 0 ""
    wrappers.each (wrapper: TFOutput wrapper)

def softplus in0:
    wrappers = makeOutputWrappers "Softplus" [in0] 1 ""
    TFOutput wrappers.head.get

def expm1 in0:
    wrappers = makeOutputWrappers "Expm1" [in0] 1 ""
    TFOutput wrappers.head.get

def nextiteration in0:
    wrappers = makeOutputWrappers "NextIteration" [in0] 1 ""
    TFOutput wrappers.head.get

def fact:
    wrappers = makeOutputWrappers "Fact" [] 1 ""
    TFOutput wrappers.head.get

def sdcashrinkl1 in0:
    wrappers = makeOutputWrappers "SdcaShrinkL1" [in0] 0 ""
    wrappers.each (wrapper: TFOutput wrapper)

def bitwiseand in0 in1:
    wrappers = makeOutputWrappers "BitwiseAnd" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def leftshift in0 in1:
    wrappers = makeOutputWrappers "LeftShift" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def tensorliststack in0:
    wrappers = makeOutputWrappers "TensorListStack" [in0] 1 ""
    TFOutput wrappers.head.get

def rightshift in0 in1:
    wrappers = makeOutputWrappers "RightShift" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def parallelconcat in0:
    wrappers = makeOutputWrappers "ParallelConcat" [in0] 1 ""
    TFOutput wrappers.head.get

def inplaceupdate in0 in1 in2:
    wrappers = makeOutputWrappers "InplaceUpdate" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def sigmoid in0:
    wrappers = makeOutputWrappers "Sigmoid" [in0] 1 ""
    TFOutput wrappers.head.get

def unbatchdataset in0:
    wrappers = makeOutputWrappers "UnbatchDataset" [in0] 1 ""
    TFOutput wrappers.head.get

def inplaceadd in0 in1 in2:
    wrappers = makeOutputWrappers "InplaceAdd" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def inplacesub in0 in1 in2:
    wrappers = makeOutputWrappers "InplaceSub" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def unravelindex in0 in1:
    wrappers = makeOutputWrappers "UnravelIndex" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def broadcastto in0 in1:
    wrappers = makeOutputWrappers "BroadcastTo" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def split in0 in1:
    wrappers = makeOutputWrappers "Split" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def splitv in0 in1 in2:
    wrappers = makeOutputWrappers "SplitV" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def hostconst:
    wrappers = makeOutputWrappers "HostConst" [] 1 ""
    TFOutput wrappers.head.get

def refnextiteration in0:
    wrappers = makeOutputWrappers "RefNextIteration" [in0] 1 ""
    TFOutput wrappers.head.get

def zeroslike in0:
    wrappers = makeOutputWrappers "ZerosLike" [in0] 1 ""
    TFOutput wrappers.head.get

def invert in0:
    wrappers = makeOutputWrappers "Invert" [in0] 1 ""
    TFOutput wrappers.head.get

def dequantize in0 in1 in2:
    wrappers = makeOutputWrappers "Dequantize" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def matrixdiag in0:
    wrappers = makeOutputWrappers "MatrixDiag" [in0] 1 ""
    TFOutput wrappers.head.get

def floordiv in0 in1:
    wrappers = makeOutputWrappers "FloorDiv" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def editdistance in0 in1 in2 in3 in4 in5:
    wrappers = makeOutputWrappers "EditDistance" [in0, in1, in2, in3, in4, in5] 1 ""
    TFOutput wrappers.head.get

def gatherv2 in0 in1 in2:
    wrappers = makeOutputWrappers "GatherV2" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def erfc in0:
    wrappers = makeOutputWrappers "Erfc" [in0] 1 ""
    TFOutput wrappers.head.get

def gathernd in0 in1:
    wrappers = makeOutputWrappers "GatherNd" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def refidentity in0:
    wrappers = makeOutputWrappers "RefIdentity" [in0] 1 ""
    TFOutput wrappers.head.get

def stopgradient in0:
    wrappers = makeOutputWrappers "StopGradient" [in0] 1 ""
    TFOutput wrappers.head.get

def asin in0:
    wrappers = makeOutputWrappers "Asin" [in0] 1 ""
    TFOutput wrappers.head.get

def preventgradient in0:
    wrappers = makeOutputWrappers "PreventGradient" [in0] 1 ""
    TFOutput wrappers.head.get

def checknumerics in0:
    wrappers = makeOutputWrappers "CheckNumerics" [in0] 1 ""
    TFOutput wrappers.head.get

def conjugatetranspose in0 in1:
    wrappers = makeOutputWrappers "ConjugateTranspose" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def uniquev2 in0 in1:
    wrappers = makeOutputWrappers "UniqueV2" [in0, in1] 2 ""
    wrappers.each (wrapper: TFOutput wrapper)

def uniquewithcountsv2 in0 in1:
    wrappers = makeOutputWrappers "UniqueWithCountsV2" [in0, in1] 3 ""
    wrappers.each (wrapper: TFOutput wrapper)

def reversesequence in0 in1:
    wrappers = makeOutputWrappers "ReverseSequence" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def rsqrtgrad in0 in1:
    wrappers = makeOutputWrappers "RsqrtGrad" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def slice in0 in1 in2:
    wrappers = makeOutputWrappers "Slice" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def copy in0:
    wrappers = makeOutputWrappers "Copy" [in0] 1 ""
    TFOutput wrappers.head.get

def stridedslicegrad in0 in1 in2 in3 in4:
    wrappers = makeOutputWrappers "StridedSliceGrad" [in0, in1, in2, in3, in4] 1 ""
    TFOutput wrappers.head.get

def stridedsliceassign in0 in1 in2 in3 in4:
    wrappers = makeOutputWrappers "StridedSliceAssign" [in0, in1, in2, in3, in4] 1 ""
    TFOutput wrappers.head.get

def tilegrad in0 in1:
    wrappers = makeOutputWrappers "TileGrad" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def dataformatdimmap in0:
    wrappers = makeOutputWrappers "DataFormatDimMap" [in0] 1 ""
    TFOutput wrappers.head.get

def broadcastargs in0 in1:
    wrappers = makeOutputWrappers "BroadcastArgs" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def broadcastgradientargs in0 in1:
    wrappers = makeOutputWrappers "BroadcastGradientArgs" [in0, in1] 2 ""
    wrappers.each (wrapper: TFOutput wrapper)

def placeholderv2:
    wrappers = makeOutputWrappers "PlaceholderV2" [] 1 ""
    TFOutput wrappers.head.get

def expanddims in0 in1:
    wrappers = makeOutputWrappers "ExpandDims" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def squeeze in0:
    wrappers = makeOutputWrappers "Squeeze" [in0] 1 ""
    TFOutput wrappers.head.get

def spacetobatchnd in0 in1 in2:
    wrappers = makeOutputWrappers "SpaceToBatchND" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def quantizeanddequantizev2 in0 in1 in2:
    wrappers = makeOutputWrappers "QuantizeAndDequantizeV2" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def unpack in0:
    wrappers = makeOutputWrappers "Unpack" [in0] 1 ""
    TFOutput wrappers.head.get

def batchtospacend in0 in1 in2:
    wrappers = makeOutputWrappers "BatchToSpaceND" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def extractimagepatches in0:
    wrappers = makeOutputWrappers "ExtractImagePatches" [in0] 1 ""
    TFOutput wrappers.head.get

def bitcast in0:
    wrappers = makeOutputWrappers "Bitcast" [in0] 1 ""
    TFOutput wrappers.head.get

def accumulatornumaccumulated in0:
    wrappers = makeOutputWrappers "AccumulatorNumAccumulated" [in0] 1 ""
    TFOutput wrappers.head.get

def onehot in0 in1 in2 in3:
    wrappers = makeOutputWrappers "OneHot" [in0, in1, in2, in3] 1 ""
    TFOutput wrappers.head.get

def where in0:
    wrappers = makeOutputWrappers "Where" [in0] 1 ""
    TFOutput wrappers.head.get

def quantizeanddequantize in0:
    wrappers = makeOutputWrappers "QuantizeAndDequantize" [in0] 1 ""
    TFOutput wrappers.head.get

def quantizeanddequantizev3 in0 in1 in2 in3:
    wrappers = makeOutputWrappers "QuantizeAndDequantizeV3" [in0, in1, in2, in3] 1 ""
    TFOutput wrappers.head.get

def sparseapplyproximaladagrad in0 in1 in2 in3 in4 in5 in6:
    wrappers = makeOutputWrappers "SparseApplyProximalAdagrad" [in0, in1, in2, in3, in4, in5, in6] 1 ""
    TFOutput wrappers.head.get

def quantizedreshape in0 in1 in2 in3:
    wrappers = makeOutputWrappers "QuantizedReshape" [in0, in1, in2, in3] 3 ""
    wrappers.each (wrapper: TFOutput wrapper)

def diagpart in0:
    wrappers = makeOutputWrappers "DiagPart" [in0] 1 ""
    TFOutput wrappers.head.get

def quantizedinstancenorm in0 in1 in2:
    wrappers = makeOutputWrappers "QuantizedInstanceNorm" [in0, in1, in2] 3 ""
    wrappers.each (wrapper: TFOutput wrapper)

def fakequantwithminmaxvarsperchannelgradient in0 in1 in2 in3:
    wrappers = makeOutputWrappers "FakeQuantWithMinMaxVarsPerChannelGradient" [in0, in1, in2, in3] 3 ""
    wrappers.each (wrapper: TFOutput wrapper)

def batchmatrixsetdiag in0 in1:
    wrappers = makeOutputWrappers "BatchMatrixSetDiag" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def batchmatrixbandpart in0 in1 in2:
    wrappers = makeOutputWrappers "BatchMatrixBandPart" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def batchmatrixdeterminant in0:
    wrappers = makeOutputWrappers "BatchMatrixDeterminant" [in0] 1 ""
    TFOutput wrappers.head.get

def enter in0:
    wrappers = makeOutputWrappers "Enter" [in0] 1 ""
    TFOutput wrappers.head.get

def addn in0:
    wrappers = makeOutputWrappers "AddN" [in0] 1 ""
    TFOutput wrappers.head.get

def accumulatenv2 in0:
    wrappers = makeOutputWrappers "AccumulateNV2" [in0] 1 ""
    TFOutput wrappers.head.get

def neg in0:
    wrappers = makeOutputWrappers "Neg" [in0] 1 ""
    TFOutput wrappers.head.get

def reciprocalgrad in0 in1:
    wrappers = makeOutputWrappers "ReciprocalGrad" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def square in0:
    wrappers = makeOutputWrappers "Square" [in0] 1 ""
    TFOutput wrappers.head.get

def conv3dbackpropfilter in0 in1 in2:
    wrappers = makeOutputWrappers "Conv3DBackpropFilter" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def sqrt in0:
    wrappers = makeOutputWrappers "Sqrt" [in0] 1 ""
    TFOutput wrappers.head.get

def exp in0:
    wrappers = makeOutputWrappers "Exp" [in0] 1 ""
    TFOutput wrappers.head.get

def log in0:
    wrappers = makeOutputWrappers "Log" [in0] 1 ""
    TFOutput wrappers.head.get

def sparsesegmentmeanwithnumsegments in0 in1 in2 in3:
    wrappers = makeOutputWrappers "SparseSegmentMeanWithNumSegments" [in0, in1, in2, in3] 1 ""
    TFOutput wrappers.head.get

def cosh in0:
    wrappers = makeOutputWrappers "Cosh" [in0] 1 ""
    TFOutput wrappers.head.get

def segmentmax in0 in1:
    wrappers = makeOutputWrappers "SegmentMax" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def skipdataset in0 in1:
    wrappers = makeOutputWrappers "SkipDataset" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def tanh in0:
    wrappers = makeOutputWrappers "Tanh" [in0] 1 ""
    TFOutput wrappers.head.get

def hsvtorgb in0:
    wrappers = makeOutputWrappers "HSVToRGB" [in0] 1 ""
    TFOutput wrappers.head.get

def sigmoidgrad in0 in1:
    wrappers = makeOutputWrappers "SigmoidGrad" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def sin in0:
    wrappers = makeOutputWrappers "Sin" [in0] 1 ""
    TFOutput wrappers.head.get

def acos in0:
    wrappers = makeOutputWrappers "Acos" [in0] 1 ""
    TFOutput wrappers.head.get

def scatterdiv in0 in1 in2:
    wrappers = makeOutputWrappers "ScatterDiv" [in0, in1, in2] 1 ""
    TFOutput wrappers.head.get

def encodewav in0 in1:
    wrappers = makeOutputWrappers "EncodeWav" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def atan in0:
    wrappers = makeOutputWrappers "Atan" [in0] 1 ""
    TFOutput wrappers.head.get

def queuedequeuemany in0 in1:
    wrappers = makeOutputWrappers "QueueDequeueMany" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def besseli0e in0:
    wrappers = makeOutputWrappers "BesselI0e" [in0] 1 ""
    TFOutput wrappers.head.get

def min in0 in1:
    wrappers = makeOutputWrappers "Min" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def transpose in0 in1:
    wrappers = makeOutputWrappers "Transpose" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def besseli1e in0:
    wrappers = makeOutputWrappers "BesselI1e" [in0] 1 ""
    TFOutput wrappers.head.get

def underscoreunaryopscomposition in0:
    wrappers = makeOutputWrappers "_UnaryOpsComposition" [in0] 1 ""
    TFOutput wrappers.head.get

def sign in0:
    wrappers = makeOutputWrappers "Sign" [in0] 1 ""
    TFOutput wrappers.head.get

def ceil in0:
    wrappers = makeOutputWrappers "Ceil" [in0] 1 ""
    TFOutput wrappers.head.get

def rint in0:
    wrappers = makeOutputWrappers "Rint" [in0] 1 ""
    TFOutput wrappers.head.get

def addv2 in0 in1:
    wrappers = makeOutputWrappers "AddV2" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def underscoremklsub in0 in1 in2 in3:
    wrappers = makeOutputWrappers "_MklSub" [in0, in1, in2, in3] 2 ""
    wrappers.each (wrapper: TFOutput wrapper)

def encodepng in0:
    wrappers = makeOutputWrappers "EncodePng" [in0] 1 ""
    TFOutput wrappers.head.get

def boostedtreescalculatebestgainsperfeature in0 in1 in2 in3 in4 in5:
    wrappers = makeOutputWrappers "BoostedTreesCalculateBestGainsPerFeature" [in0, in1, in2, in3, in4, in5] 5 ""
    wrappers.each (wrapper: TFOutput wrapper)

def underscoremklmul in0 in1 in2 in3:
    wrappers = makeOutputWrappers "_MklMul" [in0, in1, in2, in3] 2 ""
    wrappers.each (wrapper: TFOutput wrapper)

def tensorarraypack in0 in1:
    wrappers = makeOutputWrappers "TensorArrayPack" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def maximum in0 in1:
    wrappers = makeOutputWrappers "Maximum" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def truncatemod in0 in1:
    wrappers = makeOutputWrappers "TruncateMod" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def sparsesegmentsqrtnwithnumsegments in0 in1 in2 in3:
    wrappers = makeOutputWrappers "SparseSegmentSqrtNWithNumSegments" [in0, in1, in2, in3] 1 ""
    TFOutput wrappers.head.get

def igammac in0 in1:
    wrappers = makeOutputWrappers "Igammac" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def queueenqueuemany in0 in1:
    wrappers = makeOutputWrappers "QueueEnqueueMany" [in0, in1] 0 ""
    wrappers.each (wrapper: TFOutput wrapper)

def concatoffset in0 in1:
    wrappers = makeOutputWrappers "ConcatOffset" [in0, in1] 1 ""
    TFOutput wrappers.head.get

def igamma in0 in1:
    wrappers = makeOutputWrappers "Igamma" [in0, in1] 1 ""
    TFOutput wrappers.head.get
