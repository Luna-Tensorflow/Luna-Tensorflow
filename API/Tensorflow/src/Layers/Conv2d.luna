import Tensorflow.Tensor
import Tensorflow.Types
import Tensorflow.Operations
import Tensorflow.Variables
import Tensorflow.Layers.Activation
import Tensorflow.CWrappers.Helpers

# Internal.
class PaddingType:
    Valid
    Same

    def toText: case (self) of
        Valid: "VALID"
        Same: "SAME"

    def toJSON:
        self.toText.toJSON

# This layer creates a convolution kernel that is convolved (actually cross-correlated) with the previous layer output to produce next layer input.
class Conv2dLayer varT layerT:
    name :: Text
    kernelWeights :: varT # TODO types
    outHeight :: Int
    outWidth :: Int
    outChannels :: Int
    kernelHeight :: Int
    kernelWidth :: Int
    stride :: Tuple2 Int Int
    paddingType :: PaddingType
    parentLayer :: layerT

    # Returns Conv2D layer in Text type.
    # `return` :: Text
    # toText :: Text
    def toText:
        self.name + self.shape.toText + " (TODO more info?)"

    # Returns Conv2D layer in JSON type.
    # `return` :: JSON
    # toJSON :: JSON
    def toJSON:
        name = self.name
        shape = self.shape
        parents = [self.parentLayer]
        props = JSON.empty . insert "kernel" [self.kernelWidth, self.kernelHeight] . insert "stride" self.stride . insert "padding" self.paddingType . insert "out" [self.outHeight, self.outWidth, self.outChannels]
        type = "Conv2d"
        JSON.empty . insert "name" name . insert "shape" shape . insert "parents" parents . insert "type" type . insert "properties" props

    # Returns shape after processing by this layer.
    # `return` :: List Int
    # shape :: List Int
    def shape:
        [self.outHeight, self.outWidth, self.outChannels]

    # Internal. Helper function to compute Conv2D layer output.
    def calculateConv parentsOutput:
        expanded' = Operations.expandDim parentsOutput 0 # expand batch dim as 1
        expanded = if self.parentLayer.shape.length == 2 then (Operations.expandDim expanded' 1.negate) else expanded' #expand channel dim as 1
        convo = Operations.conv2D expanded self.kernelWeights self.stride self.paddingType
        squeezed = Operations.squeeze convo [0] # squeeze back
        squeezed

    # Helper function to run evaluation of model.
    # Arguments:
    # `inp` :: TFOutput a
    # `return` :: TFOutput a
    # eval :: TFOutput a -> TFOutput a
    def eval inp:
        in = self.parentLayer.eval inp
        out = self.calculateConv in
        out

    # Computes output on this layer after feeding with data from previous one.
    # Arguments:
    # `inp` :: TFOutput a
    # `return` :: TFOutput a
    # forward :: TFOutput a -> TFOutput a
    def forward inp:
        in = self.parentLayer.forward inp
        out = self.calculateConv in
        out

    # Returns variables to train, up to this layer. This layer has no new variables.
    # `return` :: List Variable a
    # trainableVariables :: List Variable a
    def trainableVariables:
        Prepend self.kernelWeights.eraseType self.parentLayer.trainableVariables

    # Returns type of output in this layer.
    # `return` :: TypeTag
    # outputType :: TypeTag
    def outputType:
        self.parentLayer.outputType

# Conv2D layer creation and usage.
class Conv2d:
    Conv2d

    # Internal.
    def _fitkern size ksize stride:
        ((size - ksize + 1).toReal / (stride.toReal)).ceiling

    # Conv2D layer constructor.
    # Arguments:
    # `[kernelHeight, kernelWidth]` :: List Int
    # `outChannels` :: Int
    # `(strideY, strideX)` :: Tuple2 Int Int
    # `paddingType` :: PaddingType
    # `parent` :: Layer
    # `return` :: Layer
    # create :: List Int -> Int -> Tuple2 Int Int -> PaddingType -> Layer -> Layer
    def create [kernelHeight, kernelWidth] outChannels (strideY, strideX) paddingType parent:
        [outHeight, outWidth, inChannels] = case parent.shape of
            [h, w]:  case paddingType of
                Valid: [self._fitkern h kernelHeight strideY, self._fitkern w kernelWidth strideX, 1]
                Same: [h, w, 1]
            [h, w, c]: case paddingType of
                Valid: [self._fitkern h kernelHeight strideY, self._fitkern w kernelWidth strideX, c]
                Same:  [h, w, c]
            _: throw $ "conv2d requires parent layer of shape h x w or h x w x c"

        name = getNextName "Conv2D"
        vartype = parent.outputType

        winit = Tensors.random vartype [kernelHeight, kernelWidth, inChannels, outChannels] 0.0 1.0
        w = Variables.make (name + "w") winit

        c = Conv2dLayer name w outHeight outWidth outChannels kernelHeight kernelWidth (strideY, strideX) paddingType parent
        c

    # Conv2D with activation layer constructor.
    # Arguments:
    # `kernelHW` :: List Int
    # `outChannels` :: Int
    # `stride` :: Tuple2 Int Int
    # `paddingType` :: PaddingType
    # `activationFunction` :: TFOutput a -> TFOutput a
    # `parent` :: Layer
    # `return` :: Layer
    # createWithActivation :: List Int -> Int -> Tuple2 Int -> PaddingType -> (TFOutput a -> TFOutput a) -> Layer -> Layer
    def createWithActivation kernelHW outChannels stride paddingType activationFunction parent:
        c = self.create kernelHW outChannels stride paddingType parent
        name = getNextName "Activation"
        a = ActivationLayer name activationFunction c
        a

