import Tensorflow.CWrappers.Operations
import Tensorflow.Tensor

# not sure if we want separate classes for each op type or one class for all?
class TFOperation:
    wrapper :: OperationWrapper

    # ptr :: ManagedPointer None
    def ptr:
        self.wrapper.ptr

    # eval :: Tensor a
    def eval:
        self.wrapper.eval

    # toJSON :: Text
    def toJSON:
        self.eval.toJSON

    # + :: TFOperation a -> TFOperation a
    def + other:
        add self other

    # * :: TFOperation a -> TFOperation a
    def * other:
        mul self other

    # - :: TFOperation a -> TFOperation a
    def - other:
        sub self other

# makePlaceholder :: Text -> TFOperation a
def makePlaceholder name:
    wrapper = makePlaceholderWrapper name
    TFOperation wrapper

# makeConst :: Tensor a -> TFOperation a
def makeConst tensor:
    wrapper = makeConstWrapper tensor
    TFOperation wrapper

# constFromList :: List a -> Tensor a
def constFromList list:
    tensor = tensorFromList list
    makeConst tensor

# constFromScalar :: a -> Tensor a
def constFromScalar x:
    constFromList [x]

# add :: (TFOperation a -> TFOperation a) -> TFOperation a
def add a b:
    wrapper = makeBinaryOpWrapper "Add" a b
    TFOperation wrapper

# mul :: (TFOperation a -> TFOperation a) -> TFOperation a
def mul a b:
    wrapper = makeBinaryOpWrapper "Mul" a b
    TFOperation wrapper

# sub :: (TFOperation a -> TFOperation a) -> TFOperation a
def sub a b:
    wrapper = makeBinaryOpWrapper "Sub" a b
    TFOperation wrapper

# partial :: (TFOperation a -> TFOperation a) -> TFOperation a
def partial a b:
    wrapper = makePartialDerivativeWrapper a b
    TFOperation wrapper

# sigmoid :: TFOperation a -> TFOperation a
def sigmoid a:
    wrapper = makeUnaryOpWrapper "Sigmoid" a
    TFOperation wrapper

