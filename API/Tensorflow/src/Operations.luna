import Tensorflow.CWrappers.Operations
import Tensorflow.CWrappers.Helpers
import Tensorflow.Tensor
import Tensorflow.GeneratedOps
import Tensorflow.Types
import Std.Foreign.C.Value

# not sure if we want separate classes for each op type or one class for all?
class TFOutput:
    wrapper :: OutputWrapper

    # ptr :: ManagedPointer None
    def ptr:
        self.wrapper.ptr

    # eval :: Tensor a
    def eval:
        self.wrapper.eval

    # toJSON :: JSON
    def toJSON:
        self.eval.toJSON

    # + :: TFOutput a -> TFOutput a
    def + other:
        add self other

    # * :: TFOutput a -> TFOutput a
    def * other:
        mul self other

    # - :: TFOutput a -> TFOutput a
    def - other:
        sub self other

    # toText :: Text
    def toText:
        "Operation TODO" # TODO

    # not sure if this is pretty to stay, but for now it's very useful
    def typetag:
        self.wrapper.typetag

# makePlaceholder :: TypeTag -> Text -> TFOutput a
def makePlaceholder typetag name:
    wrapper = makePlaceholderWrapper typetag name
    TFOutput wrapper

# makeConst :: Tensor a -> TFOutput a
def makeConst tensor:
    wrapper = makeConstWrapper tensor
    TFOutput wrapper

# constFromList :: TypeTag a -> List a -> Tensor a
def constFromList typetag list:
    tensor = tensorFromList1d typetag list
    makeConst tensor

# constFromScalar :: a -> Tensor a
def constFromScalar typetag x:
    constFromList typetag [x]

# add :: (TFOutput a -> TFOutput a) -> TFOutput a
def add a b:
    wrapper = makeBinaryOpWrapper "Add" a.wrapper b.wrapper
    TFOutput wrapper

# mul :: (TFOutput a -> TFOutput a) -> TFOutput a
def mul a b:
    wrapper = makeBinaryOpWrapper "Mul" a.wrapper b.wrapper
    TFOutput wrapper

# sub :: (TFOutput a -> TFOutput a) -> TFOutput a
def sub a b:
    wrapper = makeBinaryOpWrapper "Sub" a.wrapper b.wrapper
    TFOutput wrapper

# partial :: (TFOutput a -> TFOutput a) -> TFOutput a
def partial a b:
    wrapper = makePartialDerivativeWrapper a.wrapper b.wrapper
    TFOutput wrapper

# matMul :: (TFOutput a -> TFOutput a) -> TFOutput a
def matMul a b:
    wrapper = makeBinaryOpWrapper "MatMul" a.wrapper b.wrapper
    TFOutput wrapper

# matMul :: (TFOutput a -> TFOutput a) -> TFOutput a
def equal a b:
    wrapper = makeBinaryOpWrapper "Equal" a.wrapper b.wrapper
    TFOutput wrapper

# sqnorm :: TFOutput a -> TFOutput a
def sqnorm a:
    mult = mul a a
    dim = constFromScalar Int32Type 1

    wrapper = makeBinaryOpWrapper "Sum" mult.wrapper dim.wrapper
    TFOutput wrapper

# tanh :: TFOutput a -> TFOutput a
def tanh a:
    wrapper = makeUnaryOpWrapper "Tanh" a.wrapper
    TFOutput wrapper

# sigmoid :: TFOutput a -> TFOutput a
def sigmoid a:
    wrapper = makeUnaryOpWrapper "Sigmoid" a.wrapper
    TFOutput wrapper

# sign :: TFOutput a -> TFOutput a
def sign a:
    wrapper = makeUnaryOpWrapper "Sign" a.wrapper
    TFOutput wrapper

# exp :: TFOutput a -> TFOutput a
def exp a:
    wrapper = makeUnaryOpWrapper "Exp" a.wrapper
    TFOutput wrapper

# log :: TFOutput a -> TFOutput a
def log a:
    wrapper = makeUnaryOpWrapper "Log" a.wrapper
    TFOutput wrapper

# abs :: TFOutput a -> TFOutput a
def abs a:
    wrapper = makeUnaryOpWrapper "Abs" a.wrapper
    TFOutput wrapper

# neg :: TFOutput a -> TFOutput a
def neg a:
    wrapper = makeUnaryOpWrapper "Neg" a.wrapper
    TFOutput wrapper

# sum :: TFOutput a -> TFOutput a
def sum a:
    tensor = tensorFromList1d Int32Type [0, 1]
    b = makeConstWrapper tensor
    wrapper = makeBinaryOpWrapper "Sum" a.wrapper b
    TFOutput wrapper

# mean :: TFOutput a -> TFOutput a
def mean a:
    tensor = tensorFromList1d Int32Type [0, 1]
    b = makeConstWrapper tensor
    wrapper = makeBinaryOpWrapper "Mean" a.wrapper b
    TFOutput wrapper

def outputFromPtr typetag ptr:
    wrapper = outputWrapperFromPtr typetag ptr
    TFOutput wrapper

def qr a:
    wrappers = makeOutputWrappers "Qr" [a] [a.wrapper.typetag, a.wrapper.typetag] nullPtr ""
    wrappers.each (wrapper: TFOutput wrapper)

# expandDims :: TFOutput a -> Int -> TFOutput a
def expandDims a dim:
    dimT = tensorFromList1d Int32Type [dim]
    dimOp = makeConst dimT
    name = getNextName "ExpandDims"
    out = expandDimsGen name a dimOp a.typetag Int32Type
    out

# squeeze :: TFOutput a -> List Int -> TFOutput a
def squeeze a dims:
    dimT = tensorFromList1d Int32Type dims
    dimOp = makeConst dimT
    name = getNextName "Squeeze"
    out = squeezeGen name a a.typetag dimOp
    out

# conv2D :: TFOutput a -> TFOutput a -> Tuple2 Int Int -> Text
def conv2D input kernel (strideY, strideX) padding:
    stridesT = tensorFromList1d Int32Type [strideY, strideX]
    stridesOp = makeConst stridesT

    usegpuT = tensorFromList1d BoolType [True]
    usegpuOp = makeConst usegpuT

    paddingT = tensorFromList1d StringType [padding]
    paddingOp = makeConst paddingT

    dataFormatT = tensorFromList1d StringType ["NHWC"]
    dataFormatOp = makeConst dataFormatT

    dilationsT = tensorFromList1d Int32Type [1,1,1,1]
    dilationsOp = makeConst dilationsT

    name = getNextName "Conv2D"

    out = conv2DGen name input kernel input.typetag stridesOp usegpuOp paddingOp dataFormatOp dilationsOp
    out