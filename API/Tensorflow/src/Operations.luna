import Tensorflow.CWrappers.Operations
import Tensorflow.CWrappers.Helpers
import Tensorflow.Tensor
import Tensorflow.GeneratedOps
import Tensorflow.Types
import Tensorflow.Variables
import Std.Foreign.C.Value

def >> a b:
    a.>> b

# not sure if we want separate classes for each op type or one class for all?
class TFOutput:
    wrapper :: OutputWrapper

    # ptr :: ManagedPointer None
    def ptr:
        self.wrapper.ptr

    # eval :: Tensor a
    def eval:
        self.wrapper.eval

    # toJSON :: JSON
    def toJSON:
        self.eval.toJSON

    # + :: TFOutput a -> TFOutput a
    def + other:
        Operations.add self other

    # * :: TFOutput a -> TFOutput a
    def * other:
        Operations.mul self other

    # - :: TFOutput a -> TFOutput a
    def - other:
        Operations.sub self other

    # / :: TFOutput a -> TFOutput a
    def / other:
        Operations.div self other

    def >> other:
        Variables.sequence self other

    # toText :: Text
    def toText:
        "Operation TODO" # TODO

    # not sure if this is pretty to stay, but for now it's very useful
    def typetag:
        self.wrapper.typetag

class Operations:
    Operations

    # makePlaceholder :: TypeTag -> Text -> TFOutput a
    def makePlaceholder typetag name:
        wrapper = makePlaceholderWrapper typetag name
        TFOutput wrapper

    # makeConst :: Tensor a -> TFOutput a
    def makeConst tensor:
        wrapper = makeConstWrapper tensor
        TFOutput wrapper

    # constFromList :: TypeTag a -> List a -> Tensor a
    def constFromList typetag list:
        tensor = Tensors.fromList1d typetag list
        self.makeConst tensor

    # constFromScalar :: a -> Tensor a
    def constFromScalar typetag x:
        self.makeConst $ Tensors.fromList typetag [] [x]

    def outputFromPtr typetag ptr:
        wrapper = outputWrapperFromPtr typetag ptr
        TFOutput wrapper

    # add :: TFOutput a -> TFOutput a -> TFOutput a
    def add x y:
        chosenName = ""
        out = addGen chosenName x y x.wrapper.typetag
        out

    # mul :: TFOutput a -> TFOutput a -> TFOutput a
    def mul x y:
        chosenName = ""
        out = mulGen chosenName x y x.wrapper.typetag
        out

    # sub :: TFOutput a -> TFOutput a -> TFOutput a
    def sub x y:
        chosenName = ""
        out = subGen chosenName x y x.wrapper.typetag
        out

    # div :: TFOutput a -> TFOutput a -> TFOutput a
    def div x y:
        chosenName = ""
        out = divGen chosenName x y x.wrapper.typetag

    # matMul :: TFOutput a -> TFOutput a -> TFOutput a
    def matMul x y:
        chosenName = ""
        out = matMulGen chosenName x y False False x.wrapper.typetag
        out

    # equal :: TFOutput a -> TFOutput a -> TFOutput a
    def equal x y:
        chosenName = ""
        out = equalGen chosenName x y x.wrapper.typetag
        out

    # tanh :: TFOutput a -> TFOutput a
    def tanh x:
        chosenName = ""
        out = tanhGen chosenName x x.wrapper.typetag
        out

    # relu :: TFOutput a -> TFOutput a
    def relu x:
        chosenName = ""
        out = reluGen chosenName x x.wrapper.typetag
        out

    # sigmoid :: TFOutput a -> TFOutput a
    def sigmoid x:
        chosenName = ""
        out = sigmoidGen chosenName x x.wrapper.typetag
        out

    # sign :: TFOutput a -> TFOutput a
    def sign x:
        chosenName = ""
        out = signGen chosenName x x.wrapper.typetag
        out

    # exp :: TFOutput a -> TFOutput a
    def exp x:
        chosenName = ""
        out = expGen chosenName x x.wrapper.typetag
        out

    # log :: TFOutput a -> TFOutput a
    def log x:
        chosenName = ""
        out = logGen chosenName x x.wrapper.typetag
        out

    # abs :: TFOutput a -> TFOutput a
    def abs x:
        chosenName = ""
        out = absGen chosenName x x.wrapper.typetag
        out

    # neg :: TFOutput a -> TFOutput a
    def neg x:
        chosenName = ""
        out = negGen chosenName x x.wrapper.typetag
        out

    # sum :: TFOutput a -> TFOutput a
    def sum x dims:
        chosenName = ""

        t = Tensors.fromList1d Int32Type dims
        reductionxindices = self.makeConst t

        out = sumGen chosenName x reductionxindices False x.wrapper.typetag Int32Type
        out

    # mean :: TFOutput a -> TFOutput a
    def mean x dims:
        chosenName = ""

        t = Tensors.fromList1d Int32Type dims
        reductionxindices = self.makeConst t

        out = meanGen chosenName x reductionxindices False x.wrapper.typetag Int32Type
        out

    # expandDim :: TFOutput a -> Int -> TFOutput a
    def expandDim x dim:
        chosenName = ""

        t = Tensors.fromList1d Int32Type [dim]
        tdims = self.makeConst t

        out = expandDimsGen chosenName x tdims x.wrapper.typetag Int32Type
        out

    # squeeze :: TFOutput a -> List Int -> TFOutput a
    def squeeze x dims:
        chosenName = ""
        out = squeezeGen chosenName x x.wrapper.typetag dims
        out

    # qr :: TFOutput a -> TFOutput a
    def qr a:
        wrappers = makeOutputWrappers "Qr" [a] [a.wrapper.typetag, a.wrapper.typetag] nullPtr ""
        wrappers.each (wrapper: TFOutput wrapper)

    # partial :: (TFOutput a -> TFOutput a) -> TFOutput a
    def partial a b:
        wrapper = makePartialDerivativeWrapper a.wrapper b.wrapper
        TFOutput wrapper

    # sqnorm :: TFOutput a -> TFOutput a
    def sqnorm a:
        mult = self.mul a a
        dim = self.constFromScalar Int32Type 1

        wrapper = makeBinaryOpWrapper "Sum" mult.wrapper dim.wrapper
        TFOutput wrapper

    # conv2D :: TFOutput a -> TFOutput a -> Tuple2 Int Int -> Text
    def conv2D input kernel (strideY, strideX) padding:
        name = ""
        strides = [1, strideY, strideX, 1]
        usegpu = True
        dataFormat = "NHWC"
        dilations = [1,1,1,1]

        out = conv2DGen name input kernel input.typetag strides usegpu padding.toText dataFormat dilations
        out

    # reshape :: TFOutput a -> List Int -> TFOutput a
    def reshape input newdims:
        name = ""

        shapeT = Tensors.fromList1d Int32Type newdims
        shape = self.makeConst shapeT

        out = reshapeGen name input shape input.typetag Int32Type
        out

    def randomUniform shape typetag:
        name = ""
        attrListPtr = callHandlingError "attr_list_init" (Pointer None) []
        attrList = ManagedPointer None . fromPointer releaseMethod attrListPtr
        CString.with "dtype" nameCStr:
            callHandlingError "add_attr_type" None [attrList.toCArg, nameCStr.toCArg, CInt32.fromInt typetag.num . toCArg]
        wrappers = makeOutputWrappers "RandomUniform" [shape] [typetag] attrList name
        TFOutput wrappers.head.get