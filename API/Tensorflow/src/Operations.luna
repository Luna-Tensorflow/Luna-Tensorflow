import Tensorflow.CWrappers.Operations
import Tensorflow.CWrappers.Helpers
import Tensorflow.Tensor
import Tensorflow.GeneratedOps
import Tensorflow.Types
import Std.Foreign.C.Value

# not sure if we want separate classes for each op type or one class for all?
class TFOutput:
    wrapper :: OutputWrapper

    # ptr :: ManagedPointer None
    def ptr:
        self.wrapper.ptr

    # eval :: Tensor a
    def eval:
        self.wrapper.eval

    # toJSON :: JSON
    def toJSON:
        self.eval.toJSON

    # + :: TFOutput a -> TFOutput a
    def + other:
        add self other

    # * :: TFOutput a -> TFOutput a
    def * other:
        mul self other

    # - :: TFOutput a -> TFOutput a
    def - other:
        sub self other

    # toText :: Text
    def toText:
        "Operation TODO" # TODO

    # not sure if this is pretty to stay, but for now it's very useful
    def typetag:
        self.wrapper.typetag

# makePlaceholder :: TypeTag -> Text -> TFOutput a
def makePlaceholder typetag name:
    wrapper = makePlaceholderWrapper typetag name
    TFOutput wrapper

# makeConst :: Tensor a -> TFOutput a
def makeConst tensor:
    wrapper = makeConstWrapper tensor
    TFOutput wrapper

# constFromList :: TypeTag a -> List a -> Tensor a
def constFromList typetag list:
    tensor = tensorFromList1d typetag list
    makeConst tensor

# constFromScalar :: a -> Tensor a
def constFromScalar typetag x:
    constFromList typetag [x]

def outputFromPtr typetag ptr:
    wrapper = outputWrapperFromPtr typetag ptr
    TFOutput wrapper

# add :: TFOutput a -> TFOutput a -> TFOutput a
def add x y:
    chosenName = ""
    out = addGen chosenName x y x.wrapper.typetag
    out

# mul :: TFOutput a -> TFOutput a -> TFOutput a
def mul x y:
    chosenName = ""
    out = mulGen chosenName x y x.wrapper.typetag
    out

# sub :: TFOutput a -> TFOutput a -> TFOutput a
def sub x y:
    chosenName = ""
    out = subGen chosenName x y x.wrapper.typetag
    out

# matMul :: TFOutput a -> TFOutput a -> TFOutput a
def matMul x y:
    chosenName = ""
    out = matMulGen chosenName x y False False x.wrapper.typetag
    out

# equal :: TFOutput a -> TFOutput a -> TFOutput a
def equal x y:
    chosenName = ""
    out = equalGen chosenName x y x.wrapper.typetag
    out

# tanh :: TFOutput a -> TFOutput a
def tanh x:
    chosenName = ""
    out = tanhGen chosenName x x.wrapper.typetag
    out

# sigmoid :: TFOutput a -> TFOutput a
def sigmoid x:
    chosenName = ""
    out = sigmoidGen chosenName x x.wrapper.typetag
    out

# sign :: TFOutput a -> TFOutput a
def sign x:
    chosenName = ""
    out = signGen chosenName x x.wrapper.typetag
    out

# exp :: TFOutput a -> TFOutput a
def exp x:
    chosenName = ""
    out = expGen chosenName x x.wrapper.typetag
    out

# log :: TFOutput a -> TFOutput a
def log x:
    chosenName = ""
    out = logGen chosenName x x.wrapper.typetag
    out

# abs :: TFOutput a -> TFOutput a
def abs x:
    chosenName = ""
    out = absGen chosenName x x.wrapper.typetag
    out

# neg :: TFOutput a -> TFOutput a
def neg x:
    chosenName = ""
    out = negGen chosenName x x.wrapper.typetag
    out

# sum :: TFOutput a -> TFOutput a
def sum x dims:
    chosenName = ""

    t = tensorFromList1d Int32Type dims
    reductionxindices = makeConst t

    out = sumGen chosenName x reductionxindices False x.wrapper.typetag Int32Type
    out

# mean :: TFOutput a -> TFOutput a
def mean x dims:
    chosenName = ""

    t = tensorFromList1d Int32Type dims
    reductionxindices = makeConst t
    
    out = meanGen chosenName x reductionxindices False x.wrapper.typetag Int32Type
    out

# expandDims :: TFOutput a -> Int -> TFOutput a
def expandDims x dim:
    chosenName = ""
    
    t = tensorFromList1d Int32Type [dim]
    dim = makeConst t

    out = expandDimsGen chosenName x dim x.wrapper.typetag Int32Type
    out

# squeeze :: TFOutput a -> List Int -> TFOutput a
def squeeze x dims:
    chosenName = ""

    t = tensorFromList1d Int32Type dims
    squeezeDims = makeConst t

    out = squeezeGen chosenName x x.wrapper.typetag squeezeDims
    out

# qr :: TFOutput a -> TFOutput a
def qr a:
    wrappers = makeOutputWrappers "Qr" [a] [a.wrapper.typetag, a.wrapper.typetag] nullPtr ""
    wrappers.each (wrapper: TFOutput wrapper)

# partial :: (TFOutput a -> TFOutput a) -> TFOutput a
def partial a b:
    wrapper = makePartialDerivativeWrapper a.wrapper b.wrapper
    TFOutput wrapper

# sqnorm :: TFOutput a -> TFOutput a
def sqnorm a:
    mult = mul a a
    dim = constFromScalar Int32Type 1

    wrapper = makeBinaryOpWrapper "Sum" mult.wrapper dim.wrapper
    TFOutput wrapper

# conv2D :: TFOutput a -> TFOutput a -> Tuple2 Int Int -> Text
def conv2D input kernel (strideY, strideX) padding:
    stridesT = tensorFromList1d Int32Type [strideY, strideX]
    stridesOp = makeConst stridesT

    usegpuT = tensorFromList1d BoolType [True]
    usegpuOp = makeConst usegpuT

    paddingT = tensorFromList1d StringType [padding]
    paddingOp = makeConst paddingT

    dataFormatT = tensorFromList1d StringType ["NHWC"]
    dataFormatOp = makeConst dataFormatT

    dilationsT = tensorFromList1d Int32Type [1,1,1,1]
    dilationsOp = makeConst dilationsT

    name = ""

    out = conv2DGen name input kernel input.typetag stridesOp usegpuOp paddingOp dataFormatOp dilationsOp
    out