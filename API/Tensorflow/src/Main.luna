import Std.Base
import Std.Time

import Tensorflow.Lift
import Tensorflow.Operations
import Tensorflow.Tensor
import Tensorflow.Gradient
import Tensorflow.Types
import Tensorflow.Graph

def forwardStep (weight, bias) layer:
    prod = matMul weight layer
    nextLayer = add prod bias
    nextLayerActivated = tanh nextLayer
    nextLayerActivated

def forward input weights biases:
    layers = weights . zip biases
    netOutput = layers . foldLeft input forwardStep
    netOutput

def backward lr weights biases sqError:
    wGrads = gradients [sqError] weights []
    wNew = (weights.zip wGrads).each((w, g):
        delta = lr * g
        retval = w + delta
        retval)

    bGrads = gradients [sqError] biases []
    bNew = (biases.zip bGrads).each((b, g):
        delta = lr * g
        retval = b + delta
        retval)

    [wNew, bNew]

def neuralNetwork lr in weights biases out:
    netOutput = forward in weights biases
    diff' = netOutput - out
    sqError = diff' * diff'
    new = backward lr weights biases sqError
    new

def liftNet fun layercount:
    lr = makePlaceholder FloatType "lr"
    in = makePlaceholder FloatType "in"

    weights = (1.upto layercount).each (x: makePlaceholder FloatType ("w" + x.toText))

    biases = (1.upto layercount).each (x: makePlaceholder FloatType ("b" + x.toText))

    out = makePlaceholder FloatType "out"

    [resultW, resultB] = fun lr in weights biases out
    graph = makeGraphFromOutputList (resultW + resultB)

    def liftedNet lr in w b out:
        weights = ((1.upto layercount) . zip w).each((i, t): ("w" + i.toText, t))
        biases = ((1.upto layercount) . zip b).each((i, t): ("b" + i.toText, t))

        params = [("lr", lr), ("in", in), ("out", out)]
        inputs = params + weights + biases
        res = graph . evalSubsts inputs
        res1 = res . take layercount
        res2 = res . drop layercount
        [res1, res2]
    liftedNet

def step func (input, output) [weights, biases]:
    func input weights biases output

def main2:
    tensor1 = randomTensor FloatType [4, 1] (1.0 . negate) 1.0
    tensor2 = randomTensor FloatType [4, 1] (1.0 . negate) 1.0
    print tensor1.toJSON
    print tensor2.toJSON
    def matMul' a b:
        x = mul a b
        [x]
    lifted = lift2 matMul'
    tensor3 = lifted tensor1 tensor2
    print tensor3.toJSON

def translate value:
    result = if a > 0.0 then 1.0 else 1.0.negate
    result

def siankoStep (netRes, realRes) acc:
    result = if translate(netRes) == realRes then acc + 1 else acc
    result

def siankoStep (input, output) weights biases:
    func input weights biases output
    
def main:
    print "Classification"

    xValues = [(0.4507476416788847.negate), (0.5969958590309778.negate), (0.34398905484839193.negate), (0.6240256922586305), (0.3040937385047071), (0.018872021631879843), (0.0031373365307758583.negate), (0.359259960917071), (0.5006848914482993.negate), (0.06646267343447243.negate), (0.5085472784962797), (0.8623229886549086.negate), (0.7633879339156004.negate), (0.7727227351356329.negate), (0.6585347037570535), (0.40856708872685155.negate), (0.635333694824358), (0.09179973857873103), (0.5948655704565158.negate), (0.003085858170415623)]

    xValues2 = []

    yValues = [(0.9403949743281002), (0.9713162182251567), (0.6622533225922114.negate), (0.5063481236291545), (0.21999785168427377), (0.9518049582012664), (0.015869240837875997.negate), (0.8011010972911048.negate), (0.29762797477704783), (0.6022923991114066), (0.6178860648209521), (0.15445013622727743), (0.2472492345293622), (0.09242895617036728.negate), (0.8727377572047128.negate), (0.45406010263948215), (0.057347975198381196), (0.8153055577222252), (0.9719571177950874), (0.5869044450485912.negate)]

    inputsZipped = xValues.zip yValues

    inputs = inputsZipped.each ((x, y): tensorFromList FloatType [2, 1] [x, y])

    outs = [(1.0), (1.0), (1.0.negate), (1.0.negate), (1.0.negate), (1.0.negate), (1.0.negate), (1.0.negate), (1.0.negate), (1.0.negate), (1.0.negate), (1.0.negate), (1.0.negate), (1.0.negate), (1.0), (1.0.negate), (1.0.negate), (1.0.negate), (1.0), (1.0.negate)].each (x: tensorFromList FloatType [1, 1] [x.toReal])

    train = inputs.zip outs

    print "Dataset:"
    print train.toJSON

    lr = tensorFromList1d FloatType [(0.001.negate)]

    w1 = randomTensor FloatType [3, 2] (1.0 . negate) 1.0
    w2 = randomTensor FloatType [3, 3] (1.0 . negate) 1.0
    w3 = randomTensor FloatType [1, 3] (1.0 . negate) 1.0

    wInitial = [w1, w2, w3]

    b1 = randomTensor FloatType [3, 1] (1.0 . negate) 1.0
    b2 = randomTensor FloatType [3, 1] (1.0 . negate) 1.0
    b3 = randomTensor FloatType [1, 1] (1.0 . negate) 1.0

    bInitial = [b1, b2, b3]

    lifted = liftNet neuralNetwork 3

    print "Weights:"
    print wInitial.toJSON
    print "Biases:"
    print bInitial.toJSON

    [trainedW, trainedB] = (1.upto 5) . fold [wInitial, bInitial] (n: [w, b]:
        x = train . fold [w, b] (step (lifted lr))
        x)

    print "Weights trained"
    print trainedW.toJSON
    print "Biases trained"
    print trainedB.toJSON
    None #TODO ratio test

