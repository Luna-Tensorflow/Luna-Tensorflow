import Std.Foreign.C.Value
import Std.Foreign

import Tensorflow.CWrappers.Tensor

import Tensorflow.CWrappers.Helpers

def unzip listpair: case listpair of
    Empty: (Empty, Empty)
    Prepend (x,y) tail: case unzip tail of
        (tailx, taily): ((Prepend x tailx), (Prepend y taily))

class StateWrapper:
    ptr :: ManagedPointer None

    def toCArg:
        self.ptr.toCArg

    def values names:
        count = names . length

        varNameArr = Pointer CString . mallocElems phCount
        indexed = 0 . upto phCount . zip names
        indexed . each (idx, elem):
            varNameArr . moveElems idx . write (CString . fromText elem)

        returnedPtr = callHandlingError "get_values_from_state" (Pointer (Pointer None)) [self.toCArg,
                varNameArr.toCArg, (CInt64.fromInt count).toCArg]

        returnedArr = Array (Pointer None) . make count returnedPtr

        retval = returnedArr . toList . each (x: TensorWrapper ManagedPointer None . fromPointer releaseMethod x)

        callHandlingError "free_pointer" None [returnedPtr.toCArg]

        0.upto (phCount - 1) . each (idx: varNameArr . moveElems idx . read . free)
        varNameArr.free

        retval

    def value name:
        retptr = CString.with name nameCStr:
                callHandlingError "get_value_from_state" (Pointer None) [self.toCArg, nameCStr.toCArg]
        managed = ManagedPointer None . fromPointer releaseMethod retptr
        TensorWrapper managed

    def update values: # when this function gets actually implemented, make sure to
        count = values . length

        (valnames, vals) = unzip values
        vals' = vals.each id

        varNameArr = Pointer CString . mallocElems count
        indexed = 0 . upto count . zip names
        indexed . each (idx, elem):
            varNameArr . moveElems idx . write (CString . fromText elem)

        valsArr = Pointer (Pointer None) . mallocElems count
        indexed = 0 . upto (count - 1) . zip substs'
        indexed . each (idx, elem):
            valsArr . moveElems idx . write (elem.ptr.ptr)

        newstatePtr = callHandlingError "update_values_state" (Pointer None) [self.toCArg,
                varNameArr.toCArg, valsArr.toCArg, (CInt64.fromInt count).toCArg]

        0.upto (count - 1) . each (idx: varNameArr . moveElems idx . read . free)
        varNameArr.free
        valsArr.free

        managed = ManagedPointer None . fromPointer releaseMethod newstatePtr
        StateWrapper managed


def emptyState:
    ptr = callHandlingError "make_empty_state" (Pointer None) []
    managed = ManagedPointer None . fromPointer releaseMethod ptr
    StateWrapper managed
