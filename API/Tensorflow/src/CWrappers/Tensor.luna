import Std.Foreign
import Std.Foreign.C.Value
import Tensorflow.Types

import Tensorflow.CWrappers.Helpers

class TensorWrapper a:
    ptr :: ManagedPointer None
    typetag :: a

    def toCArg:
        self.ptr.toCArg

    def numDims:
        res = callHandlingError "get_tensor_num_dims" CInt64 [self.toCArg]

        res.toInt

    def dims:
        n = self.numDims

        dimsPtr = callHandlingError "get_tensor_dims" (Pointer CInt64) [self.toCArg]
        dimsArr = Array CInt64 . make n dimsPtr
        cdims = dimsArr.toList
        dims = cdims.each (i: i.toInt)
        callHandlingError "free_pointer" None [dimsPtr.toCArg]

        dims

    def at indexes:
        cindexes = indexes.map CInt64.fromInt

        cindexesArr = Array CInt64 . fromList cindexes

        res = callHandlingError ("get_tensor_value_at_" + self.typetag.typename) (self.typetag.ctype) [self.toCArg,
                cindexesArr . toCArg, CInt64.fromInt cindexes.length . toCArg]
        ret = self.typetag.fromC res
        self.typetag.cleanupC res

        cindexesArr.free

        ret

    def atIndex index:
        res = callHandlingError ("get_tensor_value_at_index_" + self.typetag.typename) (self.typetag.ctype) [self.toCArg,
                CInt64.fromInt index . toCArg]
        ret = self.typetag.fromC res
        self.typetag.cleanupC res
        ret

    def flatLength:
        res = callHandlingError "get_tensor_flatlist_length" CInt64 [self.toCArg]
        res.toInt

    def toFlatList:
        len = self.flatLength

        ptr = callHandlingError ("tensor_to_flatlist_" + self.typetag.typename) (Pointer (self.typetag.ctype)) [self.toCArg]
        arr = Array (self.typetag.ctype) . make len ptr
        clist = arr.toList
        list = clist.each (self.typetag.fromC)
        clist.each (self.typetag.cleanupC)
        callHandlingError "free_pointer" None [ptr.toCArg]

        list

def createTensorWrapper typetag dims values:
    expectedValuesCount = dims.foldLeft 1 (x: a: a * x)
    if (values.length == expectedValuesCount).not then throw "values must be exactly of the size needed to fill a tensor with dimensions dims" else None

    cvalues = values.each typetag.toC
    cvaluesArray = (Array typetag.ctype) . fromList cvalues

    cdims = dims.map CInt64.fromInt
    cdimsArray = (Array CInt64) . fromList cdims

    tensor = callHandlingError "make_tensor" (Pointer None) [cvaluesArray.toCArg, CInt32.fromInt typetag.num . toCArg,
            cdimsArray.toCArg, CInt64.fromInt cdims.length . toCArg]

    cvalues.each typetag.cleanupLuna
    cvaluesArray.free
    cdimsArray.free

    managedTensor = ManagedPointer None . fromPointer releaseMethod tensor
    TensorWrapper managedTensor typetag

def createRandomTensorWrapper typetag dims minValue maxValue:
    minCVal = typetag.toC minValue
    maxCVal = typetag.toC maxValue

    cdims = dims.map CInt64.fromInt
    cdimsArray = (Array CInt64) . fromList cdims

    tensor = callHandlingError ("make_random_tensor_" + typetag.typename) (Pointer None) [cdimsArray.toCArg,
            CInt64.fromInt cdims.length . toCArg, minCVal . toCArg, maxCVal . toCArg]

    cdimsArray.free

    managedTensor = ManagedPointer None . fromPointer releaseMethod tensor
    TensorWrapper managedTensor typetag

def createConstTensorWrapper typetag dims value:
    cVal = typetag.toC value

    cdims = dims.map CInt64.fromInt
    cdimsArray = (Array CInt64) . fromList cdims

    tensor = callHandlingError ("make_const_tensor_" + typetag.typename) (Pointer None) [cdimsArray.toCArg,
            CInt64.fromInt cdims.length . toCArg, cVal . toCArg]

    cdimsArray.free

    managedTensor = ManagedPointer None . fromPointer releaseMethod tensor
    TensorWrapper managedTensor typetag


